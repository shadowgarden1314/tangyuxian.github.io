<!DOCTYPE html>

<html lang="zh-CN">

<head>
  
  <meta name="baidu-site-verification" content="code-J1Qg17G6wT" />
  <title>vue-diff算法 - 糖羽仙</title>
  <meta charset="UTF-8">
  <meta name="description" content="这是萌糖的官方网站">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  
  

    <!-- Site Verification -->
    <meta name="baidu-site-verification" content="code-J1Qg17G6wT" />

  <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@master/head/head.jpg" type="image/png" />
  <meta name="description" content="diff算法的本质是找出两个对象之间的差异，目的是尽可能复用节点。">
<meta property="og:type" content="article">
<meta property="og:title" content="vue-diff算法">
<meta property="og:url" content="https://www.tangyuxian.com/2021/07/14/%E5%89%8D%E7%AB%AF/vue/vue-diff%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="糖羽仙">
<meta property="og:description" content="diff算法的本质是找出两个对象之间的差异，目的是尽可能复用节点。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140209.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140224.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140235.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140246.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140257.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140303.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140311.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140320.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140325.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140331.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140336.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140345.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140351.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140358.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140404.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140410.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140418.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140428.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140436.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140441.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140449.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140457.jpeg">
<meta property="article:published_time" content="2021-07-14T07:30:02.000Z">
<meta property="article:modified_time" content="2021-09-19T08:40:09.578Z">
<meta property="article:author" content="tangyuxian">
<meta property="article:tag" content="vue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140209.png">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,gh/theme-nexmoe/hexo-theme-nexmoe@latest/source/lib/mdui_043tiny/css/mdui.css,gh/theme-nexmoe/hexo-theme-nexmoe@latest/source/lib/iconfont/iconfont.css,gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css?v=233" crossorigin>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css">
  
    <link rel="stylesheet" href="//at.alicdn.com/t/font_2421060_8z08qcz5sq3.css">
  
  <link rel="stylesheet" href="/css/style.css?v=1649774449249">
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@master/background/xiaomai.jpg)"></div>
    <div class="nexmoe-small" style="background-image: url(https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@master/background/lihui.png)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="tangyuxian" class="mdui-btn mdui-btn-icon"><img src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@master/head/head.jpg" alt="tangyuxian"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="tangyuxian">
            <img src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@master/head/head.jpg" alt="tangyuxian" alt="tangyuxian">
        </a>
    </div>
    <div class="nexmoe-count">
        <div class="nexmoe-count-item"><span>文章</span>60 <div class="item-radius"></div><div class="item-radius item-right"></div> </div>
        <div class="nexmoe-count-item"><span>标签</span>29<div class="item-radius"></div><div class="item-radius item-right"></div></div>
        <div class="nexmoe-count-item"><span>分类</span>4<div class="item-radius"></div><div class="item-radius item-right"></div></div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-meishi"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/archives.html" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-hanbao1"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about.html" title="关于糖糖">
            <i class="mdui-list-item-icon nexmoefont icon-jiubei1"></i>
            <div class="mdui-list-item-content">
                关于糖糖
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/friend.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-cola"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/download.html" title="下载中心">
            <i class="mdui-list-item-icon nexmoefont icon-tangguo"></i>
            <div class="mdui-list-item-content">
                下载中心
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
  
  
<!-- 站内搜索 -->

<div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search" >
        <form id="search-form">
            <label><input type="text" id="local-search-input" name="q" results="0" placeholder="站内搜索" class="input form-control" autocomplete="off" autocorrect="off"/></label>
            <!-- 清空/重置搜索框 -->
            <i class="fa fa-times" onclick="resetSearch()"></i>
        </form>
    </div>
    <div id="local-search-result"></div> <!-- 搜索结果区 -->
    <!-- <p class='no-result'></p> 无匹配时显示，注意在 CSS 中设置默认隐藏 -->
</div>


  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="http://wpa.qq.com/msgrd?v=3&uin=2120252100&site=qq&menu=yes" target="_blank" mdui-tooltip="{content: 'QQ'}" style="color: rgb(64, 196, 255);background-color: rgba(64, 196, 255, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="mailto:tangyuxian@vip.qq.com" target="_blank" mdui-tooltip="{content: 'mail'}" style="color: rgb(249,8,8);background-color: rgba(249,8,8,.1);">
            <i class="nexmoefont icon-mail-fill"></i>
        </a><a class="mdui-ripple" href="https://blog.csdn.net/qq_40621378?type=blog" target="_blank" mdui-tooltip="{content: 'CSDN'}" style="color: rgb(199,29,35);background-color: rgba(199,29,35,.1);">
            <i class="nexmoefont icon-csdn"></i>
        </a><a class="mdui-ripple" href="https://www.cnblogs.com/lovetangyuxian/" target="_blank" mdui-tooltip="{content: '博客园'}" style="color: rgb(66, 214, 29);background-color: rgba(66, 214, 29, .1);">
            <i class="nexmoefont icon-bokeyuan"></i>
        </a><a class="mdui-ripple" href="https://github.com/tangyuxian/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a><a class="mdui-ripple" href="https://gitee.com/tangyuxian" target="_blank" mdui-tooltip="{content: 'gitee'}" style="color: rgb(255, 255, 255);background-color: rgb(199,29,35);">
            <i class="nexmoefont icon-mayun"></i>
        </a>
    </div>
</div>
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/前端/">前端</a>
          <span class="category-list-count">44</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/后端/">后端</a>
          <span class="category-list-count">7</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/开发工具/">开发工具</a>
          <span class="category-list-count">8</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/服务器端/">服务器端</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


  
  
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/JavaScript/" style="font-size: 16.25px;">JavaScript</a> <a href="/tags/Jetbrains/" style="font-size: 10px;">Jetbrains</a> <a href="/tags/TypeScript/" style="font-size: 10px;">TypeScript</a> <a href="/tags/UI%E5%BA%93/" style="font-size: 11.25px;">UI库</a> <a href="/tags/centos/" style="font-size: 10px;">centos</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/elementPlus/" style="font-size: 11.25px;">elementPlus</a> <a href="/tags/es6/" style="font-size: 13.75px;">es6</a> <a href="/tags/git/" style="font-size: 13.75px;">git</a> <a href="/tags/http/" style="font-size: 11.25px;">http</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/markerdown/" style="font-size: 11.25px;">markerdown</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/node/" style="font-size: 11.25px;">node</a> <a href="/tags/vue/" style="font-size: 20px;">vue</a> <a href="/tags/webpack/" style="font-size: 10px;">webpack</a> <a href="/tags/%E4%BA%92%E8%81%94%E7%BD%91/" style="font-size: 10px;">互联网</a> <a href="/tags/%E5%8A%A0%E5%AF%86/" style="font-size: 12.5px;">加密</a> <a href="/tags/%E5%8E%9F%E5%88%9B/" style="font-size: 16.25px;">原创</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 15px;">工具</a> <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 12.5px;">微信小程序</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 12.5px;">总结</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 10px;">服务器</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 17.5px;">浏览器</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/%E7%BC%96%E8%A7%A3%E7%A0%81/" style="font-size: 10px;">编解码</a> <a href="/tags/%E8%BD%AC%E8%BD%BD/" style="font-size: 18.75px;">转载</a>
    </div>
    
  </div>

  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a><span class="archive-list-count">54</span></li></ul>
    </div>
  </div>


<style>
.nexmoe-widget .archive-list-count{
	position : absolute;
	right: 15px;
	top:9px;
	color: #DDD;
}
</style>

  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2022 tangyuxian
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/tangyuxian/hexo-theme-tangyuxian" target="_blank">Tangyuxian</a><br/>
        <a href="http://beian.miit.gov.cn" target="_blank">辽ICP备2021002341号</a><br/>
        
        <div style="font-size: 12px">
            <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            本站总访问量  <a id="busuanzi_value_site_pv"></a> 次<br />
            本站访客数<a id="busuanzi_value_site_uv"></a>人次
        </div>
        
        
    </div>

</div><!-- .nexmoe-drawer -->

  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <div class="nexmoe-post">
    
        <div class="nexmoe-post-cover" style="padding-bottom: 26.666666666666668%;">
            <img data-src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@master/post/vue.jpg" data-sizes="auto" alt="vue-diff算法"
                 class="lazyload">
            <h1>vue-diff算法</h1>
        </div>
    

        <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2021年07月14日</a>
    <a><i class="nexmoefont icon-areachart"></i>6k 字</a>
    <a><i class="nexmoefont icon-time-circle-fill"></i>大概 26 分钟</a>
</div>

        <div class="nexmoe-post-right">
            
        </div>

        <article>
            <p>diff算法的本质是找出两个对象之间的差异，目的是尽可能复用节点。</p>
<span id="more"></span>

<h2 id="引一-virtual-dom"><a href="#引一-virtual-dom" class="headerlink" title="引一 virtual dom"></a>引一 virtual dom</h2><ol>
<li>template</li>
<li>渲染函数</li>
<li>vnode(virtual dom)</li>
<li>patch(diff算法)</li>
<li>view</li>
</ol>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140209.png" alt="3a0a37c86e541c31d2c3ed3884ae6308.png" class="lazyload"></p>
<ul>
<li>Vue.js通过编译将template 模板转换成渲染函数(render ) ，执行渲染函数就可以得到一个虚拟节点树</li>
<li>VNode 虚拟节点：它可以代表一个真实的 dom 节点。通过 createElement 方法能将 VNode 渲染成 dom 节点。简单地说，vnode可以理解成节点描述对象，它描述了应该怎样去创建真实的DOM节点。</li>
<li>patch(也叫做patching算法)：虚拟DOM最核心的部分，它可以将vnode渲染成真实的DOM，这个过程是对比新旧虚拟节点之间有哪些不同，然后根据对比结果找出需要更新的的节点进行更新。这点我们从单词含义就可以看出， patch本身就有补丁、修补的意思，其实际作用是在现有DOM上进行修改来实现更新视图的目的。Vue的Virtual DOM Patching算法是基于Snabbdom的实现，并在些基础上作了很多的调整和改进。</li>
</ul>
<h3 id="什么是virtual-dom"><a href="#什么是virtual-dom" class="headerlink" title="什么是virtual dom"></a><strong>什么是virtual dom</strong></h3><p>通俗易懂的来说就是用一个简单的对象去代替复杂的dom对象。</p>
<p>如果你去打印一下一个真实的DOM节点，就会发现DOM节点上有很多属性，如果Vue每次都生成一个新的真实DOM节点，对性能是巨大的浪费。</p>
<p>Virtual DOM 实际上就是以JavaScript对象(VNode )为基础形成一棵树，对真实DOM的一层抽象。Vue最终的工作就是通过这棵树批量生成真实的DOM节，可以说两者存在一层映射关系。</p>
<p>简单来说，可以把Virtual DOM 理解为一个简单的JS对象，并且最少包含标签名( tag)、属性(attrs)和子元素对象( children)三个属性。不同的框架对这三个属性的命名会有点差别。</p>
<p>对于虚拟DOM，咱们来看一个简单的实例，就是下图所示的这个，详细的阐述了模板 → 渲染函数 → 虚拟DOM树 → 真实DOM的一个过程</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140224.png" alt="dbc527b02888fdd4be3860945e85fa02.png" class="lazyload"></p>
<p>其实虚拟DOM在Vue.js主要做了两件事：</p>
<ul>
<li>提供与真实DOM节点所对应的虚拟节点vnode</li>
<li>将虚拟节点vnode和旧虚拟节点oldVnode进行对比(diff算法)，然后更新视图</li>
</ul>
<p>总结：<strong>「vdom是为了减轻性能压力。dom是昂贵的，昂贵的一方面在dom本身的重量，dom节点在js里的描述是个非常复杂属性很多原型很长的超级对象，另一方面是浏览器渲染进程和js进程是独立分离的，操作dom时的通信和浏览器本身需要重绘的时耗都是很高的。所以大家机智的搞了个轻量的vdom去模拟dom，vdom每个节点都只挂载js操作的必要属性，每次组件update时都先操作vdom，通过vdom的比对，得到一个真实dom的需要操作的集合。整个机制是在JavaScript层面计算，在完成之前并不会操作DOM，等数据稳定之后再实现精准的修改。」</strong></p>
<h2 id="引二-分析diff算法"><a href="#引二-分析diff算法" class="headerlink" title="引二 分析diff算法"></a>引二 分析diff算法</h2><p>由上我们知道了，新的虚拟DOM和旧的虚拟DOm是通过diff算法进行比较之后更新的。</p>
<h3 id="Vue2-x-diff算法"><a href="#Vue2-x-diff算法" class="headerlink" title="Vue2.x diff算法"></a><strong>Vue2.x diff算法</strong></h3><h3 id="Vue2-x-diff算法原理"><a href="#Vue2-x-diff算法原理" class="headerlink" title="Vue2.x diff算法原理"></a><strong>Vue2.x diff算法原理</strong></h3><p>传统diff算法通过循环递归对节点进行依次对比效率低下，算法复杂度达到O(N^3)，主要原因在于其追求完全比对和最小修改，而React、Vue则是放弃了完全比对及最小修改，才实现从O(N^3) =&gt; O(N)。</p>
<p>优化措施有：</p>
<ul>
<li><strong>「分层diff」</strong>：不考虑跨层级移动节点，让新旧两个VDOM树的比对无需循环递归(复杂度大幅优化，直接下降一个数量级的首要条件)。这个前提也是Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。</li>
</ul>
<p>在同层节点中，采用了<strong>「双端比较的算法」</strong>过程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较；</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140235.png" alt="13ce1945ff1e74d43467f5c3ef82b16f.png" class="lazyload"></p>
<p>当发生以下情况则跳过比对，变为插入或删除操作：</p>
<ul>
<li><strong>「组件的Type(Tagname)不一致」</strong>，原因是绝大多数情况拥有相同type的两个组件将会生成相似的树形结构，拥有不同type的两个组件将会生成不同的树形结构，所以type不一致可以放弃继续比对。</li>
<li><strong>「列表组件的Key不一致」</strong>，旧树中无新Key或反之。毕竟key是元素的身份id，能直接对应上是否是同一个节点。</li>
<li>对触发了getter/setter 的组件进行diff，精准减少diff范围</li>
</ul>
<h3 id="Vue3-0-diff"><a href="#Vue3-0-diff" class="headerlink" title="Vue3.0 diff"></a><strong>Vue3.0 diff</strong></h3><h4 id="diff痛点"><a href="#diff痛点" class="headerlink" title="diff痛点"></a><strong>diff痛点</strong></h4><p>vue2.x中的虚拟dom是进行<strong>「全量的对比」</strong>，在运行时会对所有节点生成一个虚拟节点树，当页面数据发生变更好，会遍历判断virtual dom所有节点(包括一些不会变化的节点)有没有发生变化；虽然说diff算法确实减少了多DOM节点的直接操作，但是这个<strong>「减少是有成本的」</strong>，如果是复杂的大型项目，必然存在很复杂的父子关系的VNode,<strong>「而Vue2.x的diff算法，会不断地递归调用 patchVNode，不断堆叠而成的几毫秒，最终就会造成 VNode 更新缓慢」</strong>。</p>
<p>那么Vue3.0是如何解决这些问题的呢</p>
<h5 id="动静结合-PatchFlag"><a href="#动静结合-PatchFlag" class="headerlink" title="动静结合 PatchFlag"></a><strong>动静结合 PatchFlag</strong></h5><p>在Vue3.0中，在这个模版编译时，编译器会在动态标签末尾加上 /* Text*/ PatchFlag。<strong>「也就是在生成VNode的时候，同时打上标记，在这个基础上再进行核心的diff算法」</strong>并且 PatchFlag 会标识动态的属性类型有哪些，比如这里 的TEXT 表示只有节点中的文字是动态的。而patchFlag的类型也很多。这里直接引用一张图片。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140246.png" alt="21d07297b28cf0c636daa79431065f2a.png" class="lazyload"></p>
<p>其中大致可以分为两类：</p>
<ul>
<li>当 patchFlag 的值「大于」 0 时，代表所对应的元素在 patchVNode 时或 render 时是可以被优化生成或更新的。</li>
<li>当 patchFlag 的值「小于」 0 时，代表所对应的元素在 patchVNode 时，是需要被 full diff，即进行递归遍历 VNode tree 的比较更新过程。</li>
</ul>
<p>看源码：</p>
<pre><code>export function render(_ctx, _cache, $props, $setup, $data, $options) &#123;
 return (_openBlock(), _createBlock(&quot;div&quot;, null, [
  _createVNode(&quot;p&quot;, null, &quot;&#39;HelloWorld&#39;&quot;),
  _createVNode(&quot;p&quot;, null, _toDisplayString(_ctx.msg), 1 /* TEXT */)
 
 ]))
&#125;
****
</code></pre>
<p>这里的<code>_createVNode(&quot;p&quot;, null, _toDisplayString(_ctx.msg), 1 /* TEXT */)</code>就是对变量节点进行标记。</p>
<p>总结：<strong>「Vue3.0对于不参与更新的元素，做静态标记并提示，只会被创建一次，在渲染时直接复用。」</strong></p>
<p>可参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45613931/article/details/109470718">CSDN文章:Vue3的diff算法优化部分</a></p>
<hr>
<h2 id="一-什么时候用到了diff算法-diff算法作用域？"><a href="#一-什么时候用到了diff算法-diff算法作用域？" class="headerlink" title="一 什么时候用到了diff算法,diff算法作用域？"></a>一 什么时候用到了diff算法,diff算法作用域？</h2><h3 id="1-1diff算法的作用域"><a href="#1-1diff算法的作用域" class="headerlink" title="1.1diff算法的作用域"></a>1.1diff算法的作用域</h3><p><strong>patch概念引入</strong></p>
<p>在vue update过程中在遍历子代vnode的过程中，会用不同的patch方法来patch新老vnode，如果找到对应的 newVnode 和 oldVnode,就可以复用利用里面的真实dom节点。避免了重复创建元素带来的性能开销。毕竟浏览器创造真实的dom，操纵真实的dom，性能代价是昂贵的。</p>
<p>patch过程中，如果面对当前vnode存在有很多chidren的情况,那么需要分别遍历patch新的children Vnode和老的 children vnode。</p>
<p><strong>存在chidren的vnode类型</strong></p>
<p>首先思考一下什么类型的vnode会存在children。</p>
<p><strong>①element元素类型vnode</strong></p>
<p>第一中情况就是element类型vnode 会存在 children vode，此时的三个span标签就是chidren vnode情况</p>
<pre><code>&lt;div&gt;
   &lt;span&gt; 苹果🍎 &lt;/span&gt; 
   &lt;span&gt; 香蕉🍌 &lt;/span&gt;
   &lt;span&gt; 鸭梨🍐 &lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p><strong>在vue3.0源码中 ，patchElement用于处理element类型的vnode</strong></p>
<p><strong>②flagment碎片类型vnode</strong></p>
<p>在Vue3.0中，引入了一个fragment碎片概念。<br>你可能会问，什么是碎片？如果你创建一个Vue组件，那么它只能有一个根节点。</p>
<pre><code>&lt;template&gt;
   &lt;span&gt; 苹果🍎 &lt;/span&gt; 
   &lt;span&gt; 香蕉🍌 &lt;/span&gt;
   &lt;span&gt; 鸭梨🍐 &lt;/span&gt;
&lt;/template&gt;
</code></pre>
<p>这样可能会报出警告，原因是代表任何Vue组件的Vue实例需要绑定到一个单一的DOM元素中。唯一可以创建一个具有多个DOM节点的组件的方法就是创建一个没有底层Vue实例的功能组件。</p>
<p>flagment出现就是用看起来像一个普通的DOM元素，但它是虚拟的，根本不会在DOM树中呈现。这样我们可以将组件功能绑定到一个单一的元素中，而不需要创建一个多余的DOM节点。</p>
<pre><code> &lt;Fragment&gt;
   &lt;span&gt; 苹果🍎 &lt;/span&gt; 
   &lt;span&gt; 香蕉🍌 &lt;/span&gt;
   &lt;span&gt; 鸭梨🍐 &lt;/span&gt;
&lt;/Fragment&gt;
</code></pre>
<p><strong>在vue3.0源码中 ，processFragment用于处理Fragment类型的vnode</strong></p>
<h3 id="1-2-patchChildren"><a href="#1-2-patchChildren" class="headerlink" title="1.2 patchChildren"></a>1.2 patchChildren</h3><p>从上文中我们得知了存在children的vnode类型，那么存在children就需要patch每一个<br>children vnode依次向下遍历。那么就需要一个patchChildren方法，依次patch子类vnode。</p>
<p><strong>patchChildren</strong></p>
<p>vue3.0中 在patchChildren方法中有这么一段源码</p>
<pre><code>if (patchFlag &gt; 0) &#123;
      if (patchFlag &amp; PatchFlags.KEYED_FRAGMENT) &#123; 
         /* 对于存在key的情况用于diff算法 */
        patchKeyedChildren(
          c1 as VNode[],
          c2 as VNodeArrayChildren,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          optimized
        )
        return
      &#125; else if (patchFlag &amp; PatchFlags.UNKEYED_FRAGMENT) &#123;
         /* 对于不存在key的情况,直接patch  */
        patchUnkeyedChildren( 
          c1 as VNode[],
          c2 as VNodeArrayChildren,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          optimized
        )
        return
      &#125;
    &#125;
</code></pre>
<p><strong>patchChildren根据是否存在key进行真正的diff或者直接patch。</strong></p>
<p><strong>既然diff算法存在patchChildren方法中，而patchChildren方法用在Fragment类型和element类型的vnode中，这样也就解释了diff算法的作用域是什么。</strong></p>
<h3 id="1-3-diff算法作用？"><a href="#1-3-diff算法作用？" class="headerlink" title="1.3 diff算法作用？"></a>1.3 diff算法作用？</h3><p>通过前言我们知道，存在这children的情况的vnode，需要通过patchChildren遍历children依次进行patch操作，如果在patch期间，再发现存在vnode情况，那么会递归的方式依次向下patch，那么找到与新的vnode对应的vnode显的如此重要。</p>
<p>我们用两幅图来向大家展示vnode变化。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140257.jpeg" alt="WechatIMG13940.jpeg" class="lazyload"><br><img data-fancybox="gallery" data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140303.jpeg" alt="WechatIMG13941.jpeg" class="lazyload"></p>
<p>如上两幅图表示在一次更新中新老dom树变化情况。</p>
<p><strong>假设不存在diff算法，依次按照先后顺序patch会发生什么</strong></p>
<p>如果<strong>不存在diff算法</strong>，而是直接patchchildren 就会出现如下图的逻辑。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140311.jpeg" alt="WechatIMG13942.jpeg" class="lazyload"></p>
<p><strong>第一次patchChidren</strong></p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140320.jpeg" alt="WechatIMG13943.jpeg" class="lazyload"></p>
<p><strong>第二次patchChidren</strong></p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140325.jpeg" alt="WechatIMG13944.jpeg" class="lazyload"></p>
<p><strong>第三次patchChidren</strong>‘</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140331.jpeg" alt="WechatIMG13945.jpeg" class="lazyload"></p>
<p><strong>第四次patchChidren</strong></p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140336.jpeg" alt="WechatIMG13947.jpeg" class="lazyload"><br>如果没有用到diff算法，而是依次patch虚拟dom树，那么如上稍微<strong>修改dom顺序</strong>，就会在patch过程中没有一对正确的新老vnode，所以老vnode的节点没有一个可以复用，这样就需要重新创造新的节点，浪费了性能开销，这显然不是我们需要的。</p>
<p>那么diff算法的作用就来了。</p>
<p><strong>diff作用就是在patch子vnode过程中，找到与新vnode对应的老vnode，复用真实的dom节点，避免不必要的性能开销</strong></p>
<h2 id="二-diff算法具体做了什么-重点-？"><a href="#二-diff算法具体做了什么-重点-？" class="headerlink" title="二 diff算法具体做了什么(重点)？"></a>二 diff算法具体做了什么(重点)？</h2><p>在正式讲diff算法之前，在patchChildren的过程中，存在 <strong>patchKeyedChildren</strong><br><strong>patchUnkeyedChildren</strong></p>
<p>patchKeyedChildren 是正式的开启diff的流程，那么patchUnkeyedChildren的作用是什么呢？ 我们来看看针对没有key的情况patchUnkeyedChildren会做什么。</p>
<pre><code> c1 = c1 || EMPTY_ARR
    c2 = c2 || EMPTY_ARR
    const oldLength = c1.length
    const newLength = c2.length
    const commonLength = Math.min(oldLength, newLength)
    let i
    for (i = 0; i &lt; commonLength; i++) &#123; /* 依次遍历新老vnode进行patch */
      const nextChild = (c2[i] = optimized
        ? cloneIfMounted(c2[i] as VNode)
        : normalizeVNode(c2[i]))
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        optimized
      )
    &#125;
    if (oldLength &gt; newLength) &#123; /* 老vnode 数量大于新的vnode，删除多余的节点 */
      unmountChildren(c1, parentComponent, parentSuspense, true, commonLength)
    &#125; else &#123; /* /* 老vnode 数量小于于新的vnode，创造新的即诶安 */
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        optimized,
        commonLength
      )
    &#125;
</code></pre>
<p>我们可以得到结论，对于不存在key情况<br><strong>① 比较新老children的length获取最小值 然后对于公共部分，进行从新patch工作。</strong><br><strong>② 如果老节点数量大于新的节点数量 ，移除多出来的节点。</strong><br><strong>③ 如果新的节点数量大于老节点的数量，从新 mountChildren新增的节点。</strong></p>
<p>那么对于存在key情况呢？ 会用到diff算法 ， diff算法做了什么呢？</p>
<p><strong>patchKeyedChildren方法究竟做了什么？</strong><br>我们先来看看一些声明的变量。</p>
<pre><code>    /*  c1 老的vnode c2 新的vnode  */
    let i = 0              /* 记录索引 */
    const l2 = c2.length   /* 新vnode的数量 */
    let e1 = c1.length - 1 /* 老vnode 最后一个节点的索引 */
    let e2 = l2 - 1        /* 新节点最后一个节点的索引 */
</code></pre>
<h3 id="①第一步从头开始向尾寻找"><a href="#①第一步从头开始向尾寻找" class="headerlink" title="①第一步从头开始向尾寻找"></a>①第一步从头开始向尾寻找</h3><p>(a b) c<br>(a b) d e</p>
<pre><code> /* 从头对比找到有相同的节点 patch ，发现不同，立即跳出*/
    while (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;
      const n1 = c1[i]
      const n2 = (c2[i] = optimized
        ? cloneIfMounted(c2[i] as VNode)
        : normalizeVNode(c2[i]))
        /* 判断key ，type是否相等 */
      if (isSameVNodeType(n1, n2)) &#123;
        patch(
          n1,
          n2,
          container, 
          parentAnchor,
          parentComponent,
          parentSuspense,
          isSVG,
          optimized
        )
      &#125; else &#123;
        break
      &#125;
      i++
    &#125;
</code></pre>
<p>第一步的事情就是从头开始寻找相同的vnode，然后进行patch,如果发现不是相同的节点，那么立即跳出循环。</p>
<p>具体流程如图所示</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140345.jpeg" alt="在这里插入图片描述" class="lazyload"></p>
<p><strong>isSameVNodeType</strong></p>
<pre><code>export function isSameVNodeType(n1: VNode, n2: VNode): boolean &#123;
  return n1.type === n2.type &amp;&amp; n1.key === n2.key
&#125;
</code></pre>
<p>isSameVNodeType 作用就是判断当前vnode类型 和 vnode的 key是否相等</p>
<h3 id="②第二步从尾开始同前diff"><a href="#②第二步从尾开始同前diff" class="headerlink" title="②第二步从尾开始同前diff"></a>②第二步从尾开始同前diff</h3><p>a (b c)<br>d e (b c)</p>
<pre><code class="javascript"> /* 如果第一步没有patch完，立即，从后往前开始patch ,如果发现不同立即跳出循环 */
    while (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;
      const n1 = c1[e1]
      const n2 = (c2[e2] = optimized
        ? cloneIfMounted(c2[e2] as VNode)
        : normalizeVNode(c2[e2]))
      if (isSameVNodeType(n1, n2)) &#123;
        patch(
          n1,
          n2,
          container,
          parentAnchor,
          parentComponent,
          parentSuspense,
          isSVG,
          optimized
        )
      &#125; else &#123;
        break
      &#125;
      e1--
      e2--
    &#125;
</code></pre>
<p>经历第一步操作之后，如果发现没有patch完，那么立即进行第二部，从尾部开始遍历依次向前diff。</p>
<p>如果发现不是相同的节点，那么立即跳出循环。</p>
<p>具体流程如图所示<br><img data-fancybox="gallery" data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140351.jpeg" alt="WechatIMG13952.jpeg" class="lazyload"></p>
<p><strong>③④主要针对新增和删除元素的情况，前提是元素没有发生移动， 如果有元素发生移动就要走⑤逻辑。</strong></p>
<h3 id="③-如果老节点是否全部patch，新节点没有被patch完-创建新的vnode"><a href="#③-如果老节点是否全部patch，新节点没有被patch完-创建新的vnode" class="headerlink" title="③ 如果老节点是否全部patch，新节点没有被patch完,创建新的vnode"></a>③ 如果老节点是否全部patch，新节点没有被patch完,创建新的vnode</h3><p>(a b)<br>(a b) c<br>i = 2, e1 = 1, e2 = 2<br>(a b)<br>c (a b)<br>i = 0, e1 = -1, e2 = 0</p>
<pre><code>/* 如果新的节点大于老的节点数 ，对于剩下的节点全部以新的vnode处理（ 这种情况说明已经patch完相同的vnode  ） */
    if (i &gt; e1) &#123;
      if (i &lt;= e2) &#123;
        const nextPos = e2 + 1
        const anchor = nextPos &lt; l2 ? (c2[nextPos] as VNode).el : parentAnchor
        while (i &lt;= e2) &#123;
          patch( /* 创建新的节点*/
            null,
            (c2[i] = optimized
              ? cloneIfMounted(c2[i] as VNode)
              : normalizeVNode(c2[i])),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG
          )
          i++
        &#125;
      &#125;
    &#125;
</code></pre>
<p><strong>i &gt; e1</strong></p>
<p>如果新的节点大于老的节点数 ，对于剩下的节点全部以新的vnode处理（ 这种情况说明已经patch完相同的vnode ），也就是要全部create新的vnode.</p>
<p>具体逻辑如图所示<br><img data-fancybox="gallery" data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140358.jpeg" alt="WechatIMG13955.jpeg" class="lazyload"></p>
<h3 id="④-如果新节点全部被patch，老节点有剩余，那么卸载所有老节点"><a href="#④-如果新节点全部被patch，老节点有剩余，那么卸载所有老节点" class="headerlink" title="④ 如果新节点全部被patch，老节点有剩余，那么卸载所有老节点"></a>④ 如果新节点全部被patch，老节点有剩余，那么卸载所有老节点</h3><p><strong>i &gt; e2</strong><br>(a b) c<br>(a b)<br>i = 2, e1 = 2, e2 = 1<br>a (b c)<br>(b c)<br>i = 0, e1 = 0, e2 = -1</p>
<pre><code>else if (i &gt; e2) &#123;
   while (i &lt;= e1) &#123;
      unmount(c1[i], parentComponent, parentSuspense, true)
      i++
   &#125;
&#125;
</code></pre>
<p>对于老的节点大于新的节点的情况 ，对于超出的节点全部卸载 （ 这种情况说明已经patch完相同的vnode ）</p>
<p>具体逻辑如图所示<br><img data-fancybox="gallery" data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140404.jpeg" alt="WechatIMG13956.jpeg" class="lazyload"></p>
<h3 id="⑤-不确定的元素-（-这种情况说明没有patch完相同的vnode-），我们可以接着①②的逻辑继续往下看"><a href="#⑤-不确定的元素-（-这种情况说明没有patch完相同的vnode-），我们可以接着①②的逻辑继续往下看" class="headerlink" title="⑤ 不确定的元素 （ 这种情况说明没有patch完相同的vnode ），我们可以接着①②的逻辑继续往下看"></a>⑤ 不确定的元素 （ 这种情况说明没有patch完相同的vnode ），我们可以接着①②的逻辑继续往下看</h3><p><strong>diff核心</strong></p>
<p>在①②情况下没有遍历完的节点如下图所示。<br><img data-fancybox="gallery" data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140410.jpeg" alt="WechatIMG13957.jpeg" class="lazyload"></p>
<p>剩下的节点。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140418.jpeg" alt="WechatIMG13953.jpeg" class="lazyload"></p>
<pre><code class="javascript">      const s1 = i  //第一步遍历到的index
      const s2 = i 
      const keyToNewIndexMap: Map&lt;string | number, number&gt; = new Map()
      /* 把没有比较过的新的vnode节点,通过map保存 */
      for (i = s2; i &lt;= e2; i++) &#123;
        if (nextChild.key != null) &#123;
          keyToNewIndexMap.set(nextChild.key, i)
        &#125;
      &#125;
      let j
      let patched = 0 
      const toBePatched = e2 - s2 + 1 /* 没有经过 path 新的节点的数量 */
      let moved = false /* 证明是否 */
      let maxNewIndexSoFar = 0 
      const newIndexToOldIndexMap = new Array(toBePatched)
       for (i = 0; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = 0
      /* 建立一个数组，每个子元素都是0 [ 0, 0, 0, 0, 0, 0, ] */ 
</code></pre>
<p>遍历所有新节点把索引和对应的key,存入map keyToNewIndexMap中</p>
<p><strong>keyToNewIndexMap</strong> 存放 key -&gt; index 的map</p>
<p><strong>D : 2</strong><br><strong>E : 3</strong><br><strong>C : 4</strong><br><strong>I : 5</strong></p>
<p>接下来声明一个新的指针 <strong>j</strong>,记录剩下新的节点的索引。<br><strong>patched</strong> ,记录在第⑤步patched新节点过的数量<br><strong>toBePatched</strong> 记录⑤步之前，没有经过patched 新的节点的数量。<br><strong>moved</strong>代表是否发生过移动，咱们的demo是已经发生过移动的。</p>
<p><strong>newIndexToOldIndexMap</strong> 用来存放新节点索引和老节点索引的数组。<br>newIndexToOldIndexMap 数组的index是新vnode的索引 ， value是老vnode的索引。</p>
<p>接下来</p>
<pre><code class="javascript"> for (i = s1; i &lt;= e1; i++) &#123; /* 开始遍历老节点 */
        const prevChild = c1[i]
        if (patched &gt;= toBePatched) &#123; /* 已经patch数量大于等于， */
          /* ① 如果 toBePatched新的节点数量为0 ，那么统一卸载老的节点 */
          unmount(prevChild, parentComponent, parentSuspense, true)
          continue
        &#125;
        let newIndex
         /* ② 如果,老节点的key存在 ，通过key找到对应的index */
        if (prevChild.key != null) &#123;
          newIndex = keyToNewIndexMap.get(prevChild.key)
        &#125; else &#123; /*  ③ 如果,老节点的key不存在 */
          for (j = s2; j &lt;= e2; j++) &#123; /* 遍历剩下的所有新节点 */
            if (
              newIndexToOldIndexMap[j - s2] === 0 &amp;&amp; /* newIndexToOldIndexMap[j - s2] === 0 新节点没有被patch */
              isSameVNodeType(prevChild, c2[j] as VNode)
            ) &#123; /* 如果找到与当前老节点对应的新节点那么 ，将新节点的索引，赋值给newIndex  */
              newIndex = j
              break
            &#125;
          &#125;
        &#125;
        if (newIndex === undefined) &#123; /* ①没有找到与老节点对应的新节点，删除当前节点，卸载所有的节点 */
          unmount(prevChild, parentComponent, parentSuspense, true)
        &#125; else &#123;
          /* ②把老节点的索引，记录在存放新节点的数组中， */
          newIndexToOldIndexMap[newIndex - s2] = i + 1
          if (newIndex &gt;= maxNewIndexSoFar) &#123;
            maxNewIndexSoFar = newIndex
          &#125; else &#123;
            /* 证明有节点已经移动了   */
            moved = true
          &#125;
          /* 找到新的节点进行patch节点 */
          patch(
            prevChild,
            c2[newIndex] as VNode,
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVG,
            optimized
          )
          patched++
        &#125;
 &#125;
</code></pre>
<p>这段代码算是diff算法的核心。</p>
<p><strong>第一步： 通过老节点的key找到对应新节点的index:开始遍历老的节点，判断有没有key， 如果存在key通过新节点的keyToNewIndexMap找到与新节点index,如果不存在key那么会遍历剩下来的新节点试图找到对应index。</strong></p>
<p><strong>第二步：如果存在index证明有对应的老节点，那么直接复用老节点进行patch，没有找到与老节点对应的新节点，删除当前老节点。</strong></p>
<p><strong>第三步：newIndexToOldIndexMap找到对应新老节点关系。</strong></p>
<p>到这里，我们patch了一遍，把所有的老vnode都patch了一遍。</p>
<p>如图所示<br><img data-fancybox="gallery" data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140428.jpeg" alt="01B449A5-9B15-4547-8EBF-5A3BA66A1831.jpg" class="lazyload"><br>但是接下来的问题。</p>
<p><strong>1 虽然已经patch过所有的老节点。可以对于已经发生移动的节点，要怎么真正移动dom元素。</strong><br><strong>2 对于新增的节点，（图中节点I）并没有处理，应该怎么处理。</strong></p>
<pre><code class="js">      /*移动老节点创建新节点*/
     /* 根据最长稳定序列移动相对应的节点 */
      const increasingNewIndexSequence = moved
        ? getSequence(newIndexToOldIndexMap)
        : EMPTY_ARR
      j = increasingNewIndexSequence.length - 1
      for (i = toBePatched - 1; i &gt;= 0; i--) &#123;
        const nextIndex = s2 + i
        const nextChild = c2[nextIndex] as VNode
        const anchor =
          nextIndex + 1 &lt; l2 ? (c2[nextIndex + 1] as VNode).el : parentAnchor
        if (newIndexToOldIndexMap[i] === 0) &#123; /* 没有老的节点与新的节点对应，则创建一个新的vnode */
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG
          )
        &#125; else if (moved) &#123;
          if (j &lt; 0 || i !== increasingNewIndexSequence[j]) &#123; /*如果没有在长*/
            /* 需要移动的vnode */
            move(nextChild, container, anchor, MoveType.REORDER)
          &#125; else &#123;
            j--
          &#125;    
</code></pre>
<h3 id="⑥最长稳定序列"><a href="#⑥最长稳定序列" class="headerlink" title="⑥最长稳定序列"></a>⑥最长稳定序列</h3><p>首选通过getSequence得到一个最长稳定序列，对于index === 0 的情况也就是<strong>新增节点（图中I）</strong> 需要从新mount一个新的vnode,然后对于发生移动的节点进行统一的移动操作</p>
<p><strong>什么叫做最长稳定序列</strong></p>
<p>对于以下的原始序列<br>0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15<br>最长递增子序列为<br>0, 2, 6, 9, 11, 15.</p>
<p><strong>为什么要得到最长稳定序列</strong></p>
<p>因为我们需要一个序列作为基础的参照序列，其他未在稳定序列的节点，进行移动。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过上述我们大致知道了diff算法的流程<br><strong>1 从头对比找到有相同的节点 patch ，发现不同，立即跳出。</strong></p>
<p><strong>2如果第一步没有patch完，立即，从后往前开始patch ,如果发现不同立即跳出循环。</strong></p>
<p><strong>3如果新的节点大于老的节点数 ，对于剩下的节点全部以新的vnode处理（ 这种情况说明已经patch完相同的vnode ）。</strong></p>
<p><strong>4 对于老的节点大于新的节点的情况 ， 对于超出的节点全部卸载 （ 这种情况说明已经patch完相同的vnode ）。</strong></p>
<p><strong>5不确定的元素（ 这种情况说明没有patch完相同的vnode ） 与 3 ，4对立关系。</strong></p>
<p>1 把没有比较过的新的vnode节点,通过map保存<br>记录已经patch的新节点的数量 patched<br>没有经过 path 新的节点的数量 toBePatched<br>建立一个数组newIndexToOldIndexMap，每个子元素都是[ 0, 0, 0, 0, 0, 0, ] 里面的数字记录老节点的索引 ，数组索引就是新节点的索引<br><strong>开始遍历老节点</strong><br>① 如果 toBePatched新的节点数量为0 ，那么统一卸载老的节点<br>② 如果,老节点的key存在 ，通过key找到对应的index<br>③ 如果,老节点的key不存在</p>
<pre><code>  1 遍历剩下的所有新节点
  2 如果找到与当前老节点对应的新节点那么 ，将新节点的索引，赋值给newIndex
</code></pre>
<p>④ 没有找到与老节点对应的新节点，卸载当前老节点。<br>⑤ 如果找到与老节点对应的新节点，把老节点的索引，记录在存放新节点的数组中，</p>
<pre><code>  1 如果节点发生移动 记录已经移动了
  2 patch新老节点 找到新的节点进行patch节点    
</code></pre>
<p><strong>遍历结束</strong></p>
<p><strong>如果发生移动</strong></p>
<pre><code>① 根据 newIndexToOldIndexMap 新老节点索引列表找到最长稳定序列
② 对于 newIndexToOldIndexMap -item =0 证明不存在老节点 ，从新形成新的vnode 
③ 对于发生移动的节点进行移动处理。 
</code></pre>
<h2 id="三-key的作用，如何正确key。"><a href="#三-key的作用，如何正确key。" class="headerlink" title="三 key的作用，如何正确key。"></a>三 key的作用，如何正确key。</h2><h3 id="1key的作用"><a href="#1key的作用" class="headerlink" title="1key的作用"></a>1key的作用</h3><p>在我们上述diff算法中，通过isSameVNodeType方法判断，来判断key是否相等判断新老节点。<br>那么由此我们可以总结出？</p>
<p><strong>在v-for循环中，key的作用是：通过判断newVnode和OldVnode的key是否相等，从而复用与新节点对应的老节点，节约性能的开销。</strong></p>
<h3 id="2如何正确使用key"><a href="#2如何正确使用key" class="headerlink" title="2如何正确使用key"></a>2如何正确使用key</h3><h4 id="①错误用法-1：用index做key。"><a href="#①错误用法-1：用index做key。" class="headerlink" title="①错误用法 1：用index做key。"></a>①错误用法 1：用index做key。</h4><p><strong>用index做key的效果实际和没有用diff算法是一样的，为什么这么说呢，下面我就用一幅图来说明：</strong></p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140436.jpeg" alt="WechatIMG10408 1.jpeg" class="lazyload"></p>
<p>如果所示当我们用index作为key的时候，无论我们怎么样移动删除节点，到了diff算法中都会从头到尾依次patch(图中：<strong>所有节点均未有效的复用</strong>)</p>
<h4 id="②错误用法2-：用index拼接其他值作为key。"><a href="#②错误用法2-：用index拼接其他值作为key。" class="headerlink" title="②错误用法2 ：用index拼接其他值作为key。"></a>②错误用法2 ：用index拼接其他值作为key。</h4><p>当已用index拼接其他值作为索引的时候，因为每一个节点都找不到对应的key，导致所有的节点都不能复用,所有的新vnode都需要重新创建。都需要重新create</p>
<p>如图所示。<br><img data-fancybox="gallery" data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140441.jpeg" alt="WechatIMG10531.jpeg" class="lazyload"></p>
<h4 id="③正确用法-：用唯一值id做key-我们可以用前后端交互的数据源的id为key-。"><a href="#③正确用法-：用唯一值id做key-我们可以用前后端交互的数据源的id为key-。" class="headerlink" title="③正确用法 ：用唯一值id做key(我们可以用前后端交互的数据源的id为key)。"></a>③正确用法 ：用唯一值id做key(我们可以用前后端交互的数据源的id为key)。</h4><p>如图所示。每一个节点都做到了复用。起到了diff算法的真正作用。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140449.jpeg" alt="WechatIMG10532.jpeg" class="lazyload"></p>
<h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h2><p>我们在上面，已经把刚开始的问题统统解决了，最后用一张思维脑图来从新整理一下整个流程。<br><img data-fancybox="gallery" data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210812140457.jpeg" alt="7FB635D9-EE62-45D5-8DE9-620CDF74B772.jpg" class="lazyload"></p>
<hr>
<p>参考文章:</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39621975/article/details/111213826">CSDN文章:diff算法_Vue3.0时代你必须了解的：diff算法原理和优化</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000023060173">vue3.0 diff算法详解(超详细)</a></p>

        </article>

        
            
  <div class="nexmoe-post-copyright">
    <strong>本文作者：</strong>tangyuxian<br>
    
    <strong>本文链接：</strong><a href="https://www.tangyuxian.com/2021/07/14/%E5%89%8D%E7%AB%AF/vue/vue-diff%E7%AE%97%E6%B3%95/" title="https:&#x2F;&#x2F;www.tangyuxian.com&#x2F;2021&#x2F;07&#x2F;14&#x2F;%E5%89%8D%E7%AB%AF&#x2F;vue&#x2F;vue-diff%E7%AE%97%E6%B3%95&#x2F;" target="_blank" rel="noopener">https:&#x2F;&#x2F;www.tangyuxian.com&#x2F;2021&#x2F;07&#x2F;14&#x2F;%E5%89%8D%E7%AB%AF&#x2F;vue&#x2F;vue-diff%E7%AE%97%E6%B3%95&#x2F;</a><br>

    
      <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
    
  </div>


        

        <div class="nexmoe-post-meta nexmoe-rainbow">
    
        <a class="nexmoefont icon-appstore-fill -link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/tags/vue/" rel="tag">vue</a>
    
</div>

    <div class="nexmoe-post-footer">
        <section class="nexmoe-comment">
    <div class="valine"></div>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.9/dist/Valine.min.js'></script>
<script>
    // 使用方法 https://valine.js.org/quickstart.html
    new Valine({
        el: '.valine',
        appId: 'r5zxC0st0DDjPA9auXzMV7HY-gzGzoHsz',
        appKey: '3bqCsovpyfTPHUzTHovd3V3V'
    })
</script>
</section>
    </div>
</div>


        <div class="nexmoe-post-right">
          
            <div class="nexmoe-fixed">
              <div class="nexmoe-tool">
                <a href="#" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
              </div>
            </div>
          
        </div>
    </div>
  </div>
  <div id="nexmoe-pendant">
    <div class="nexmoe-drawer mdui-drawer nexmoe-pd" id="drawer">
        
            <div class="nexmoe-pd-item">
                <div class="clock">
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="needle" id="hours"></div>
        <div class="needle" id="minutes"></div>
        <div class="needle" id="seconds"></div>
        <div class="clock_logo">

        </div>

    </div>
<style>
    .clock {
        background-color: #ffffff;
        width: 70vw;
        height: 70vw;
        max-width: 70vh;
        max-height: 70vh;
        border: solid 2.8vw #242424;
        position: relative;
        overflow: hidden;
        border-radius: 50%;
        box-sizing: border-box;
        box-shadow: 0 1.4vw 2.8vw rgba(0, 0, 0, 0.8);
        zoom:0.2
    }

    .memory {
        position: absolute;
        top: 50%;
        left: 50%;
        transform-origin: center;
    }

    .memory:nth-child(1) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(0deg) translateY(-520%);
    }

    .memory:nth-child(2) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(6deg) translateY(-1461%);
    }

    .memory:nth-child(3) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(12deg) translateY(-1461%);
    }

    .memory:nth-child(4) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(18deg) translateY(-1461%);
    }

    .memory:nth-child(5) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(24deg) translateY(-1461%);
    }

    .memory:nth-child(6) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(30deg) translateY(-520%);
    }

    .memory:nth-child(7) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(36deg) translateY(-1461%);
    }

    .memory:nth-child(8) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(42deg) translateY(-1461%);
    }

    .memory:nth-child(9) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(48deg) translateY(-1461%);
    }

    .memory:nth-child(10) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(54deg) translateY(-1461%);
    }

    .memory:nth-child(11) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(60deg) translateY(-520%);
    }

    .memory:nth-child(12) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(66deg) translateY(-1461%);
    }

    .memory:nth-child(13) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(72deg) translateY(-1461%);
    }

    .memory:nth-child(14) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(78deg) translateY(-1461%);
    }

    .memory:nth-child(15) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(84deg) translateY(-1461%);
    }

    .memory:nth-child(16) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(90deg) translateY(-520%);
    }

    .memory:nth-child(17) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(96deg) translateY(-1461%);
    }

    .memory:nth-child(18) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(102deg) translateY(-1461%);
    }

    .memory:nth-child(19) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(108deg) translateY(-1461%);
    }

    .memory:nth-child(20) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(114deg) translateY(-1461%);
    }

    .memory:nth-child(21) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(120deg) translateY(-520%);
    }

    .memory:nth-child(22) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(126deg) translateY(-1461%);
    }

    .memory:nth-child(23) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(132deg) translateY(-1461%);
    }

    .memory:nth-child(24) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(138deg) translateY(-1461%);
    }

    .memory:nth-child(25) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(144deg) translateY(-1461%);
    }

    .memory:nth-child(26) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(150deg) translateY(-520%);
    }

    .memory:nth-child(27) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(156deg) translateY(-1461%);
    }

    .memory:nth-child(28) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(162deg) translateY(-1461%);
    }

    .memory:nth-child(29) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(168deg) translateY(-1461%);
    }

    .memory:nth-child(30) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(174deg) translateY(-1461%);
    }

    .memory:nth-child(31) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(180deg) translateY(-520%);
    }

    .memory:nth-child(32) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(186deg) translateY(-1461%);
    }

    .memory:nth-child(33) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(192deg) translateY(-1461%);
    }

    .memory:nth-child(34) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(198deg) translateY(-1461%);
    }

    .memory:nth-child(35) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(204deg) translateY(-1461%);
    }

    .memory:nth-child(36) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(210deg) translateY(-520%);
    }

    .memory:nth-child(37) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(216deg) translateY(-1461%);
    }

    .memory:nth-child(38) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(222deg) translateY(-1461%);
    }

    .memory:nth-child(39) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(228deg) translateY(-1461%);
    }

    .memory:nth-child(40) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(234deg) translateY(-1461%);
    }

    .memory:nth-child(41) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(240deg) translateY(-520%);
    }

    .memory:nth-child(42) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(246deg) translateY(-1461%);
    }

    .memory:nth-child(43) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(252deg) translateY(-1461%);
    }

    .memory:nth-child(44) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(258deg) translateY(-1461%);
    }

    .memory:nth-child(45) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(264deg) translateY(-1461%);
    }

    .memory:nth-child(46) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(270deg) translateY(-520%);
    }

    .memory:nth-child(47) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(276deg) translateY(-1461%);
    }

    .memory:nth-child(48) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(282deg) translateY(-1461%);
    }

    .memory:nth-child(49) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(288deg) translateY(-1461%);
    }

    .memory:nth-child(50) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(294deg) translateY(-1461%);
    }

    .memory:nth-child(51) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(300deg) translateY(-520%);
    }

    .memory:nth-child(52) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(306deg) translateY(-1461%);
    }

    .memory:nth-child(53) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(312deg) translateY(-1461%);
    }

    .memory:nth-child(54) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(318deg) translateY(-1461%);
    }

    .memory:nth-child(55) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(324deg) translateY(-1461%);
    }

    .memory:nth-child(56) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(330deg) translateY(-520%);
    }

    .memory:nth-child(57) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(336deg) translateY(-1461%);
    }

    .memory:nth-child(58) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(342deg) translateY(-1461%);
    }

    .memory:nth-child(59) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(348deg) translateY(-1461%);
    }

    .memory:nth-child(60) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(354deg) translateY(-1461%);
    }

    .needle {
        position: absolute;
        top: 50%;
        left: 50%;
        transform-origin: center;
    }

    .needle#hours {
        background-color: #1f1f1f;
        width: 4%;
        height: 30%;
        transform-origin: center 75%;
        transform: translate(-50%, -75%);
    }

    .needle#hours.moving {
        transition: transform 150ms ease-out;
    }

    .needle#hours:after {
        content: '';
        background-color: #1f1f1f;
        width: 4vw;
        height: 4vw;
        max-width: 4vh;
        max-height: 4vh;
        display: block;
        position: absolute;
        top: 75%;
        left: 50%;
        box-sizing: border-box;
        border-radius: 50%;
        transform: translate(-50%, -50%);
    }

    .needle#minutes {
        background-color: #1f1f1f;
        width: 2%;
        height: 45%;
        transform-origin: center 75%;
        transform: translate(-50%, -75%);
    }

    .needle#minutes.moving {
        transition: transform 150ms ease-out;
    }

    .needle#minutes:after {
        content: '';
        background-color: #1f1f1f;
        width: 4vw;
        height: 4vw;
        max-width: 4vh;
        max-height: 4vh;
        display: block;
        position: absolute;
        top: 75%;
        left: 50%;
        box-sizing: border-box;
        border-radius: 50%;
        transform: translate(-50%, -50%);
    }

    .needle#seconds {
        background-color: #cb2f2f;
        width: 1%;
        height: 50%;
        transform-origin: center 75%;
        transform: translate(-50%, -75%);
    }

    .needle#seconds.moving {
        transition: transform 150ms ease-out;
    }

    .needle#seconds:after {
        content: '';
        background-color: #cb2f2f;
        width: 2.5vw;
        height: 2.5vw;
        max-width: 2.5vh;
        max-height: 2.5vh;
        display: block;
        position: absolute;
        top: 75%;
        left: 50%;
        box-sizing: border-box;
        border-radius: 50%;
        transform: translate(-50%, -50%);
    }
    .clock_logo{
        width: 10vw;
        height: 10vw;
        max-width: 10vh;
        max-height: 10vh;
        position: absolute;
        top: 50%;
        left: 50%;
        box-sizing: border-box;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        background-size: 100% 100%;
        background-repeat: no-repeat;
    }
    @media (min-width: 100vh) {
        .clock {
            border: solid 2.8vh #242424;
            box-shadow: 0 1.4vh 2.8vh rgba(0, 0, 0, 0.8);
        }
    }

</style>





            </div>
        
            <div class="nexmoe-pd-item">
                <div class="qweather" >
    <div id="he-plugin-standard"></div>
    <div class="qweather-logo">

    </div>

</div>
<style>
    .qweather{
        position: relative;
    }
    .qweather-logo{
        position: absolute;
        right: 0;
        top: -15px;
        width: 40px;
        height: 40px;
        background-size: 100% 100%;
        background-repeat: no-repeat;
    }
</style>
<script>
  WIDGET = {
    "CONFIG": {
      "layout": "2",
      "width": "260",
      "height": "220",
      "background": "5",
      "dataColor": "e67249",
      "borderRadius": "15",
      "key": "f74d1e1690e6432d801e97fa2f05a162"
    }
  }
</script>
<script src="https://widget.qweather.net/standard/static/js/he-standard-common.js?v=2.0"></script>

            </div>
        
</div>
<style>
    .nexmoe-pd {
        left: auto;
        top: 40px;
        right: 0;
    }
    .nexmoe-pd-item{
       display: flex;
        justify-content: center;
        margin-bottom: 30px;
    }
</style>

  </div>
  <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script>
	hljs.initHighlightingOnLoad();
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>


<script src="/js/app.js?v=1649774449250"></script>

<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>

  





<!-- hexo injector body_end start -->
<script src="/js/clock.js"></script>

<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script>

<script src="/lib/codeBlock/codeBlockFuction.js"></script>

<script src="/lib/codeBlock/codeLang.js"></script>

<script src="/lib/codeBlock/codeCopy.js"></script>

<script src="/lib/codeBlock/codeShrink.js"></script>

<link rel="stylesheet" href="/lib/codeBlock/matery.css">

<script src="https://code.jquery.com/jquery-3.6.0.js"></script>

<script src="/js/search.js"></script>

<script src="/js/webapp.js"></script>
<!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/xiaomai.model.json"},"display":{"position":"left","width":200,"height":500},"mobile":{"show":false},"react":{"opacity":0.9},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

<script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/250cb4aa.js","daovoice")</script>
<script>
  daovoice('init', {
    app_id: "250cb4aa"
  });
  daovoice('update');
</script>

