<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浏览器-高度塌陷问题</title>
      <link href="/2022/06/06/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-%E9%A1%B5%E9%9D%A2%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2022/06/06/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-%E9%A1%B5%E9%9D%A2%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>简单总结下高度塌陷问题,加入一些自己对于该问题的思考</p><span id="more"></span><p>最近一直专注于<code>JavaScript</code>方面的知识总结,反而在一定程度上忽略掉<code>dom</code>相关问题,页面铺设本身也是前端开发必备技能,不应随着<code>JavaScript</code>权重提升而忽略.这次本糖想谈谈一个比较老的问题,<strong>高度塌陷</strong>.</p><p><img src="https://img2.baidu.com/it/u=526351266,2803714732&fm=253&fmt=auto&app=138&f=JPEG?w=440&h=438" alt="小埋"></p><h2 id="一-定义"><a href="#一-定义" class="headerlink" title="一 定义"></a>一 定义</h2><p>父级元素在不设置指定高度的情况下, 其高度默认是由其中的子元素撑起,当子元素脱离父级所在的文本流时,会导致父级元素高度坍塌.</p><p>一旦出现高度塌陷,那么父级元素下面的兄弟元素就会上移,影响到页面布局</p><h2 id="二-产生场景"><a href="#二-产生场景" class="headerlink" title="二 产生场景"></a>二 产生场景</h2><ol><li>子元素浮动 <code>float</code>;</li><li>子元素定位 <code>position:absolute</code> <code>position:fixed</code>;</li></ol><h2 id="三-解决办法"><a href="#三-解决办法" class="headerlink" title="三 解决办法"></a>三 解决办法</h2><h4 id="1-父元素设置高度"><a href="#1-父元素设置高度" class="headerlink" title="1 父元素设置高度"></a>1 父元素设置高度</h4><p>尽管这个解决办法看起来跟扯犊子似的,但是不也解决了父元素没有高度的问题了嘛</p><h4 id="2-父元素与子元素处于同一文本流"><a href="#2-父元素与子元素处于同一文本流" class="headerlink" title="2 父元素与子元素处于同一文本流"></a>2 父元素与子元素处于同一文本流</h4><p>如果子元素设置浮动,那么父元素也设置浮动,子元素设置定位,父元素也定位,让父元素和子元素在同一文本流.这个也有点扯,父元素的父元素不就又产生高度塌陷了,很显然这也不是好的解决办法</p><h4 id="3-转成inline-block行内块元素或overflow非默认值"><a href="#3-转成inline-block行内块元素或overflow非默认值" class="headerlink" title="3 转成inline-block行内块元素或overflow非默认值"></a>3 转成<code>inline-block</code>行内块元素或<code>overflow</code>非默认值</h4><pre><code class="css">.parent &#123;        width: 100%        display: inline-block;        overflow: auto;&#125;</code></pre><p>用的是<strong>BFC</strong>特点,会将浮动元素的高度计算在内,来避免高度坍塌,这种方式只能解决子元素是通过浮动产生的高度塌陷问题</p><h2 id="四-其它想说"><a href="#四-其它想说" class="headerlink" title="四 其它想说"></a>四 其它想说</h2><h4 id="1-为何现在很少提到高度塌陷这一问题"><a href="#1-为何现在很少提到高度塌陷这一问题" class="headerlink" title="1 为何现在很少提到高度塌陷这一问题"></a>1 为何现在很少提到高度塌陷这一问题</h4><p>不仅仅是上面提到的解决办法,还有利用伪元素来清除浮动等等;我们研究这个高度塌陷,永远离不开一种情况就是子元素浮动问题;现在我们很少提到高度塌陷很大一部分原因是我们不再采用浮动而是使用<strong>弹性布局</strong>,极大的方便了页面布局,当然也就避免因为浮动而产生的各类问题;至于元素定位,在页面布局掌控中一定注意定位的使用规范,避免出现一个页面所有元素都是定位出来的,那样绝对爆炸</p><h4 id="2-BFC概念"><a href="#2-BFC概念" class="headerlink" title="2 BFC概念"></a>2 BFC概念</h4><p>上面提到BFC的特点在一定程度上解决了因浮动而产生的高度塌陷问题,其实BFC在处理<code>margin属性重叠</code>(毗邻的多个盒元素的margin共享)也会起到作用</p><p>所谓BFC就是块级格式上下文，BFC是一个独立的区域，不会影响其他的区域的布局，每一个被BFC元素的子元素不会对外面的元素产生影响</p><p>触发条件如下</p><div class="table-box"><table><thead><tr><th>元素或属性</th><th>属性值</th></tr></thead><tbody><tr><td>float</td><td>left right （非默认值none）</td></tr><tr><td>position</td><td>absolute、fixed、(非relative)</td></tr><tr><td>块级元素overflow</td><td>scroll、auto、hidden、（非visible）</td></tr><tr><td>display</td><td>flex、inline-block、table-cell、table-caption、grid、（非none、非inline、非block）</td></tr><tr><td>根元素body</td><td>body是bfc元素</td></tr></tbody></table></div><p>网上找来一个表格,作为参考;</p><p>之所以突然想总结这一古老的问题,是因为有一个群友说他最近面试有被问到这个问题,本糖也是一愣,看来现在越来越多的企业对技术人员的基础知识储备越来越看重,我们平时在学习使用新框架新工具的同时,也不要忘记多巩固自己的基础知识,毕竟未来的技术发展也都是基于最基础的技术进行拓展</p><p><img src="https://img2.baidu.com/it/u=735021522,2296488136&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500" alt="小埋"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node-npm,yarn和pnpm区别</title>
      <link href="/2022/06/05/%E5%89%8D%E7%AB%AF/node/node-npm-yarn%E5%92%8Cpnpm%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/06/05/%E5%89%8D%E7%AB%AF/node/node-npm-yarn%E5%92%8Cpnpm%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>简单总结下npm,yarn和pnpm三种包管理器的区别</p><span id="more"></span><h2 id="一-npm"><a href="#一-npm" class="headerlink" title="一 npm"></a>一 npm</h2><h4 id="1-简述"><a href="#1-简述" class="headerlink" title="1 简述"></a>1 简述</h4><p>npm 是 Node Package Manager 的缩写，是一个 NodeJS 包管理和分发工具，我们可以使用它发布、安装和卸载 NodeJS 包。npm 是 JavaScript 运行时环境 Node.js 的默认包管理器。</p><h4 id="2-官网"><a href="#2-官网" class="headerlink" title="2 官网"></a>2 官网</h4><p><a href="https://www.npmjs.com/">https://www.npmjs.com/</a></p><h4 id="3-说明"><a href="#3-说明" class="headerlink" title="3 说明"></a>3 说明</h4><p><strong>npm2</strong>存在很严重的依赖嵌套关系</p><pre><code>node_modules- package-A-- node_modules--- package-B----- node_modules------ package-C-------- some-really-really-really-long-file-name-in-package-c.js</code></pre><p><strong>npm3</strong>扁平依赖</p><pre><code>node_modules- package-A-- node_modules--- package-B----- node_modules------ package-C-------- some-really-really-really-long-file-name-in-package-c.js</code></pre><p><code>npm</code>必须首先遍历所有的项目依赖关系，然后再决定如何生成扁平的<code>node_modules</code>目录结构。npm必须为所有使用到的模块构建一个完整的依赖关系树，这是一个耗时的操作,是<a href="https://link.juejin.cn/?target=https://github.com/npm/npm/issues/8826">npm安装速度慢的一个很重要的原因</a>。本地缓存的内容可以通过<code>npm cache ls</code>命令进行查看。本地缓存的设计有助于减少安装时间。</p><h2 id="二-yarn"><a href="#二-yarn" class="headerlink" title="二 yarn"></a>二 yarn</h2><h4 id="1-简述-1"><a href="#1-简述-1" class="headerlink" title="1 简述"></a>1 简述</h4><p>yarn 是 facebook 等公司在 npm v3 时推出的一个新的开源的 Node Package Manager，它的出现是为了弥补 npm 当时安装速度慢、依赖包版本不一致等问题。</p><h4 id="2-官网-1"><a href="#2-官网-1" class="headerlink" title="2 官网"></a>2 官网</h4><p><a href="https://yarnpkg.com/">https://yarnpkg.com/</a></p><h4 id="3-说明-1"><a href="#3-说明-1" class="headerlink" title="3 说明"></a>3 说明</h4><p>它的出现是为了弥补 npm 当时安装速度慢、依赖包版本不一致等问题。每个yarn安装都会生成一个类似于<code>npm-shrinkwrap.json</code>的<code>yarn.lock</code>文件，而且它是默认创建的。除了常规信息之外，<code>yarn.lock</code>文件还包含要安装的内容的校验和，以确保使用的库的版本相同。<code>yarn</code>无需互联网连接就能安装本地缓存的依赖项，它提供了离线模式。</p><p>yarn 有以下优点：</p><ol><li><p>安装速度快</p><ul><li>并行安装：npm 是按照队列依次安装每个 package，当前一个 package 安装完成之后，才能继续后面的安装。而 Yarn 是同步执行所有任务。</li><li>缓存：如果一个 package 之前已经安装过，yarn 会直接从缓存中获取，而不是重新下载。</li></ul></li><li><p>版本统一</p><p>yarn 创新性的新增了 yarn.lock 文件，它是 yarn 在安装依赖包时，自动生成的一个文件，作用是记录 yarn 安装的每个 package 的版本，保证之后 install 时的版本一致。不过随着后来 npm 也新增了作用相同的 package-lock.json，这个优势已经不太明显。</p></li></ol><h2 id="三-pnpm"><a href="#三-pnpm" class="headerlink" title="三 pnpm"></a>三 pnpm</h2><h4 id="1-简述-2"><a href="#1-简述-2" class="headerlink" title="1 简述"></a>1 简述</h4><p>2017 年 pnpm 推出。全称 Performance NPM，即高性能的 npm。</p><h4 id="2-官网-2"><a href="#2-官网-2" class="headerlink" title="2 官网"></a>2 官网</h4><p><a href="https://pnpm.io/">https://pnpm.io/</a></p><h4 id="3-说明-2"><a href="#3-说明-2" class="headerlink" title="3 说明"></a>3 说明</h4><p>pnpm采用了一种巧妙的方法，利用硬链接和符号链接来避免复制所有本地缓存源文件,同一个包 pnpm 只会安装一次，磁盘中只有一个地方写入，后面再次使用都会直接使 hardlink。即使一个包的不同版本，pnpm 也会极大程度地复用之前版本的代码。举个例子，比如 lodash 有 100 个文件，更新版本之后多了一个文件，那么磁盘当中并不会重新写入 101 个文件，而是保留原来的 100 个文件的 hardlink，仅仅写入那一个新增的文件。</p><h2 id="四-命令对比"><a href="#四-命令对比" class="headerlink" title="四 命令对比"></a>四 命令对比</h2><h3 id="npm-yarn-和-pnpm-之间命令的区别"><a href="#npm-yarn-和-pnpm-之间命令的区别" class="headerlink" title="npm yarn 和 pnpm 之间命令的区别"></a>npm yarn 和 pnpm 之间命令的区别</h3><table><thead><tr><th>-</th><th>npm</th><th>yarn</th><th>pnpm</th></tr></thead><tbody><tr><td>Install all</td><td>npm install</td><td>yarn</td><td>pnpm install</td></tr><tr><td>Install</td><td>npm install [package]</td><td>yarn add [package]</td><td>pnpm add [package]</td></tr><tr><td></td><td>npm install [package] -D</td><td>yarn add [package] -D</td><td>pnpm add -D [package]</td></tr><tr><td></td><td>npm install [package] -g</td><td>yarn global add [package]</td><td>pnpm add -g [package]</td></tr><tr><td>Uninstall</td><td>npm uninstall [package]</td><td>yarn remove [package]</td><td>pnpm remove [package]</td></tr><tr><td>Update</td><td>npm update [package]</td><td>yarn upgrade [package]</td><td>pnpm update [package]</td></tr></tbody></table><blockquote><p>参考文档</p><p><a href="http://events.jianshu.io/p/e02ffa9effe6">npm、 yarn 和 pnpm 的区别 - 简书 (jianshu.io)</a></p><p><a href="https://juejin.cn/post/6844903616109641736">一文看懂npm、yarn、pnpm之间的区别 - 掘金 (juejin.cn)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>echarts-多个折线图拖拽收尾自动闭合操作</title>
      <link href="/2022/06/04/%E5%89%8D%E7%AB%AF/echarts/echarts-%E5%A4%9A%E4%B8%AA%E6%8A%98%E7%BA%BF%E5%9B%BE%E6%8B%96%E6%8B%BD%E6%94%B6%E5%B0%BE%E8%87%AA%E5%8A%A8%E9%97%AD%E5%90%88%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/06/04/%E5%89%8D%E7%AB%AF/echarts/echarts-%E5%A4%9A%E4%B8%AA%E6%8A%98%E7%BA%BF%E5%9B%BE%E6%8B%96%E6%8B%BD%E6%94%B6%E5%B0%BE%E8%87%AA%E5%8A%A8%E9%97%AD%E5%90%88%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>拖拽折线图的收尾自动闭合成面积图</p><span id="more"></span><p>目前有这样一个需求,在一个统计图中,会有多条可拖拽的折线图,当某条折线图的首尾相连时会自动填充内部变成面积图,分开又变回折线图,如下图</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/image-20220604163530022.png" alt="image-20220604163530022"></p><p>图1和图2都是4个端点,当第一个端点和最后一个端点通过拖拽相连后变回变成图2的效果,并自动填充其中颜色</p><h2 id="一-分析"><a href="#一-分析" class="headerlink" title="一 分析"></a>一 分析</h2><p>首先思考的几个问题:</p><ol><li>如何拖拽折线图;</li><li>首个端点和最后一个端点如何正好重合(当数据过大,很难通过拖拽情况下恰好让两个端点的数值完全相同);</li><li>如何填充颜色;</li></ol><p>以下是官方示例</p><ol><li><a href="https://echarts.apache.org/examples/zh/editor.html?c=line-simple">一条普通的折线图示例</a></li><li><a href="https://echarts.apache.org/examples/zh/editor.html?c=line-draggable">一条可拖拽节点的折线图示例</a></li><li><a href="https://echarts.apache.org/examples/zh/editor.html?c=area-basic">基础面积图示例</a></li></ol><h2 id="二-准备工作"><a href="#二-准备工作" class="headerlink" title="二 准备工作"></a>二 准备工作</h2><h4 id="1-如何实现拖拽"><a href="#1-如何实现拖拽" class="headerlink" title="1 如何实现拖拽"></a>1 如何实现拖拽</h4><p>从官方的示例中我们可以发现,它采用的是<code>graphic</code>属性.根据<a href="https://echarts.apache.org/zh/option.html#graphic">官方手册</a>我们可以发现,这个属性可以让我们在<code>echarts</code>图上自由绘制图形区域,以及这些图形的鼠标按下,抬起,鼠标经过,拖拽等等操作回调,借助<a href="https://echarts.apache.org/zh/api.html#echartsInstance.convertToPixel"><code>echartsInstance.convertToPixel</code></a>可进行坐标转换,将每个端点的坐标转换成像素坐标,为我们定点;</p><p>定点实现后后借助<code>graphic</code>中的<code>ondrag</code>回调函数便可知我们目前已拖拽的点的坐标,拿到的是像素坐标,再借助<a href="https://echarts.apache.org/zh/api.html#echartsInstance.convertFromPixel"><code>echartsInstance.convertFromPixel</code></a>将坐标转换成我们目前可用数值</p><h4 id="2-如何实现首尾相连"><a href="#2-如何实现首尾相连" class="headerlink" title="2 如何实现首尾相连"></a>2 如何实现首尾相连</h4><p>如果单靠拖拽来实现首尾两个坐标点一致太难了,因为这中间会产生特别小的误差使其无法完全一致</p><p>可借助下面这个函数算出两个坐标点的距离,可在距离小于一定数值后让两个坐标点相连</p><pre><code class="javascript">    function distant(a, b) &#123;        let dx = Number(a[0]) - Number(b[0])        let dy = Number(a[1]) - Number(b[1])        return Math.pow(dx * dx + dy * dy, .5)    &#125;</code></pre><h4 id="3-如何实现内容填充"><a href="#3-如何实现内容填充" class="headerlink" title="3 如何实现内容填充"></a>3 如何实现内容填充</h4><p>根据官方手册<a href="https://echarts.apache.org/zh/option.html#series-line.areaStyle"><code>series-line.areaStyle</code></a>的配置项可自定义填充颜色,因为存在首尾坐标在拖拽下合并或者分开两种情况随时变换,当我们给这个属性<code>null</code>时会让填充失效,当给<code>&#123;&#125;</code>则会使用默认的填充配置</p><h4 id="4-多条折线图存在的注意事项"><a href="#4-多条折线图存在的注意事项" class="headerlink" title="4 多条折线图存在的注意事项"></a>4 多条折线图存在的注意事项</h4><p>官方示例中均为单条折线,但是在多条线中,我们要考虑的问题便增加了,在拖拽的时候要注意我们拖拽的是第几条线,拖拽完毕还要将拖拽后的数值回填到定义的数据源中</p><h4 id="5-限制拖拽端点数值"><a href="#5-限制拖拽端点数值" class="headerlink" title="5 限制拖拽端点数值"></a>5 限制拖拽端点数值</h4><p>若限制端点拖拽到坐标外,可在<code>ondrag</code>获取到当前数值的最大值最小值判定,然后<code>return</code>即可</p><h2 id="三-示例"><a href="#三-示例" class="headerlink" title="三 示例"></a>三 示例</h2><p>本糖已经开出来有人看的还是有点懵,于是完整代码在下面了,复制到本地运行看看吧;</p><p>也可点击 <a href="https://www.tangyuxian.com/web/line-draggable.html">在线示例</a> ,不过在线示例是放在本糖的服务器上,哪天本糖穷到没钱续费服务器就访问不到了,还是复制到本地看最保险</p><pre><code class="html">&lt;!--    THIS EXAMPLE WAS DOWNLOADED FROM https://echarts.apache.org/examples/zh/editor.html?c=line-draggable&amp;code=MYewdgzgLgBBCeBbARiANgZQJYC8CmMAvDAEwAMA3AFCiSwAmAhlI0TANpUwcAsZANDAC0ARjIBdflw5CAzAOEBWSdPZCA7ADYAdIsHkV3NZtm7BfQzJIltIwYolVx1EAAcoWcGwDe0j1DQ8AC4YX25uKDwADygQgHIAFQAneBgAESTGAHMsrDAsmCgACzwIAgAFEDyoCDipcJhAgDNYmDjgPDBIpLjpAF96wpB0D1cQsPCoJKwcvCSAeTB4sHA8OuluJpAkxGZukKaAVzBgDy8ACldGTMQIAEpQjfCkvChDpLAYc6eGuIANeIwADUP3CVxuEG0TBY7Ak2igIAAYlgonh6OcSA8QQ1fgAeZBJAB8AE1AdicdxwYxblDmIx2CJxPCkSi0Ri7qC7tQGn1-oMstN6OMngixm0ABwAUnWDVQUARiHiIhI0r50iiAEEolgIMKGog8iFRGQBE9dlEQupTQ0oPBXME2gA3RhoQ5rQbcRjaiAAGTyDu8MHAAC05iADi6yjBedwBtJ4FqdXrwgalsJ5B6YOaQpprZM7Q64s7Xe6nl6dX6wAGg2BQ0lwzAmpGCDHo4NoYxg8NFRwnhMbQX4hA0Fh6HMZTjNd6AJJgMcWmB5hpNLBoboAWRAY-Wq16PMz_fz9qHI7HPUz3ATM7n0RCS_CK7Xc0327aKyre_CcYah4ig7aeQQKOpYUlOOqzvOd4Xo2q4bluhbvmsTzfuEv6FP-cSAcBE4NFe4E3gu96bLBz7wTuH7IdIlhlNMpQhJwP6gqO8SMDhR6FiOH7QRAiDDMUIRTG60HXHgjAYLagTJhS2wzIacSdPQn77qCCAoOg2D4CEqmoJguB4NBHYhB2lHcOIVB9NQZRQAkWCIHgICHFA5xHCcZyfOcDwTAA9F5MAavQ9BwEUjD0CAADuMDAFgSTAIEEBfGFRRYMARQwDqMArLAjo6lgyCBA8CIwJ0jB5QQ9CZFk2jSIg8AAMLBUkUDaFZ8zuJ4YDnIeAqMK4SXAEZdLaLsrjOccpztV8WCRIgggdhB0SeaCLxvB8jwUn-x5tFFMWBGxDSuCAQFuSENX1dcTW0I6czWSA5Ssmg5xxAKo51Gl013NB3AQMFm1oQ0wCEZ94TAPAUGgg0SRaUgOkaQQvkkODbaI3k2VAaVAlJEJiPldkWQlZJhSY_piPgDjWQHGNblfPQUSzfAi3reE4CVNUGS43kWTnHNBGCOwxQ6totOFElkLwOIXKIyh0lgLxhxlLxV0U65E0eWtjNBeFCTDGuWAjdz84S4zUs4uAstlA5rQueNFwM-rSVjlrIy61zdLzVEhvrcbDQ4CEYhkKCFnIRysYSwMi4S2FeShWF2ghfQACiV1dH60CdHMj0vEB-CvYcrjQnglRHe1EunQ1TXgI9HZdiAiA53nzAF4dU3F9QVtU7n-eF83Fe26X53Na8rVuZ1Tzdb1yUDSwQ09aNysXFNeAzTA-sLWrEOvO8nx_TAB1F-AJ11WX2iXddWt3aiD1PYKr0L4gwc4oHPL330odUG3E3fZr2ujC7LBu73h9-70B1FcKAKUNTWw6oeW0m04ifzCjZVwbEaJYFKG7MGDQV4Liwf0V-78vD2zwI7HWetXYEQAWdRqUIQHMHAZAkeA5YGEMQZ-F-1BeT4M-MzKoXQ2Y5A5r_RgbtBC71th2dgWDxBsD7lQk-jVET1kQOfPAl9nqKREYdD2PkYAAFV66RGXnSaqgCqEtTahXQ8KC6K9gpNvZibRWJA0MoYlgAcnhmRDuwoAA    请注意，该图表不是 Apache ECharts 官方示例，而是由用户代码生成的。请注意鉴别其内容。--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot; style=&quot;height: 100%&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;style&gt;        body &#123;            height: 100%;        &#125;        .main &#123;            height: 70%;        &#125;        #container &#123;            flex: 1;            height: 100%;            margin: 0        &#125;        .tip &#123;            padding: 10px 100px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;main&quot;&gt;    &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;tip&quot;&gt;        &lt;b&gt;说明:&lt;/b&gt;做了一个简单的示例,可以随意拖拽,拖拽后收尾相连开始判定可围成一个区域,首尾相连过程中会通过坐标计算两点距离,距离小于2时会自动吸附连接&lt;/br&gt;        圈定的范围颜色是根据线的颜色变化&lt;/br&gt;        首尾相连后可一起拖拽,快速拖拽可分离收尾连接,同时判定圈定范围失效&lt;/br&gt;        注意多条线的拖拽逻辑是将所有可拖拽线的点压到一个数组里,处理拖拽后逻辑要根据原始数组下标确定是拖动了哪条线    &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://fastly.jsdelivr.net/npm/echarts@5.3.0/dist/echarts.min.js&quot;&gt;&lt;/script&gt;&lt;!-- Uncomment this line if you want to dataTool extension&lt;script type=&quot;text/javascript&quot; src=&quot;https://fastly.jsdelivr.net/npm/echarts@5.3.2/dist/extension/dataTool.min.js&quot;&gt;&lt;/script&gt;--&gt;&lt;!-- Uncomment this line if you want to use gl extension&lt;script type=&quot;text/javascript&quot; src=&quot;https://fastly.jsdelivr.net/npm/echarts-gl@2/dist/echarts-gl.min.js&quot;&gt;&lt;/script&gt;--&gt;&lt;!-- Uncomment this line if you want to echarts-stat extension&lt;script type=&quot;text/javascript&quot; src=&quot;https://fastly.jsdelivr.net/npm/echarts-stat@latest/dist/ecStat.min.js&quot;&gt;&lt;/script&gt;--&gt;&lt;!-- Uncomment this line if you want to use map&lt;script type=&quot;text/javascript&quot; src=&quot;https://fastly.jsdelivr.net/npm/echarts@4.9.0/map/js/china.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://fastly.jsdelivr.net/npm/echarts@4.9.0/map/js/world.js&quot;&gt;&lt;/script&gt;--&gt;&lt;!-- Uncomment these two lines if you want to use bmap extension&lt;script type=&quot;text/javascript&quot; src=&quot;https://api.map.baidu.com/api?v=3.0&amp;ak=YOUR_API_KEY&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://fastly.jsdelivr.net/npm/echarts@5.3.2/dist/extension/bmap.min.js&quot;&gt;&lt;/script&gt;--&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var dom = document.getElementById(&#39;container&#39;);    var myChart = echarts.init(dom, null, &#123;        renderer: &#39;canvas&#39;,        useDirtyRect: false    &#125;);    var app = &#123;&#125;;    var option;    const symbolSize = 20;    const data = [        [            [10, 56],            [14, 80],            [17, 63],            [22, 60],        ],        [            [47, 156],            [34, 140],            [37, 100],            [40, 80],            [52, 90]        ],        [            [10, 149],            [5, 109],            [20, 100],            [16, 145],        ]    ];    option = &#123;        color: [&#39;green&#39;, &#39;red&#39;,&#39;blue&#39;],        title: &#123;            text: &#39;拖拽示例&#39;,            left: &#39;left&#39;        &#125;,        legend: &#123;            data: data.map((e,i)=&gt;&#39;图&#39;+(i+1))        &#125;,        tooltip: &#123;            triggerOn: &#39;none&#39;,            formatter: function (params) &#123;                return (                    &#39;X: &#39; +                    params.data[0].toFixed(2) +                    &#39;&lt;br&gt;Y: &#39; +                    params.data[1].toFixed(2)                );            &#125;        &#125;,        grid: &#123;            top: &#39;8%&#39;,            bottom: &#39;12%&#39;        &#125;,        xAxis: &#123;            min: -90,            max: 90,            type: &#39;value&#39;,            axisLine: &#123;onZero: false&#125;        &#125;,        yAxis: &#123;            min: -180,            max: 180,            type: &#39;value&#39;,            axisLine: &#123;onZero: false&#125;        &#125;,        dataZoom: [            // &#123;            //     type: &#39;slider&#39;,            //     xAxisIndex: 0,            //     filterMode: &#39;none&#39;            // &#125;,            // &#123;            //     type: &#39;slider&#39;,            //     yAxisIndex: 0,            //     filterMode: &#39;none&#39;            // &#125;,            &#123;                type: &#39;inside&#39;,                xAxisIndex: 0,                start: 30,                filterMode: &#39;none&#39;,            &#125;,            &#123;                type: &#39;inside&#39;,                yAxisIndex: 0,                start: 40,                filterMode: &#39;none&#39;            &#125;        ],        series: data.map((item,index)=&gt;&#123;            return  &#123;                id: &#39;obj&#39;+index,                name: &#39;图&#39;+(index+1),                type: &#39;line&#39;,                smooth: true,                areaStyle: null,                symbolSize: symbolSize,                data: data[index]            &#125;        &#125;)    &#125;;    // Add shadow circles (which is not visible) to enable drag.    dragListener()    function dragListener() &#123;        setTimeout(function () &#123;            let graphicList = []             data.map((dataItem,dataIndex)=&gt;&#123;                 graphicList=[...graphicList,...dataItem.map(function (item, index) &#123;                     return &#123;                         type: &#39;circle&#39;,                         position: myChart.convertToPixel(&#39;grid&#39;, item),                         shape: &#123;                             cx: 0,                             cy: 0,                             r: symbolSize / 2                         &#125;,                         invisible: true,                         draggable: true,                         ondrag: function (dx, dy) &#123;                             onPointDragging(dataIndex, index, [this.x, this.y]);                         &#125;,                         onmousemove: function () &#123;                             showTooltip(dataIndex,index);                         &#125;,                         onmouseout: function () &#123;                             hideTooltip(index);                         &#125;,                         z: 100                     &#125;;                 &#125;)]             &#125;)            myChart.setOption(&#123;                graphic:graphicList            &#125;);        &#125;, 0);    &#125;    function showTooltip(dataIndex,index) &#123;        myChart.dispatchAction(&#123;            type: &#39;showTip&#39;,            seriesIndex: dataIndex,            dataIndex: index        &#125;);    &#125;    function hideTooltip(dataIndex) &#123;        myChart.dispatchAction(&#123;            type: &#39;hideTip&#39;        &#125;);    &#125;    function distant(a, b) &#123;        let dx = Number(a[0]) - Number(b[0])        let dy = Number(a[1]) - Number(b[1])        return Math.pow(dx * dx + dy * dy, .5)    &#125;    function onPointDragging(dataIndex, index, pos) &#123;        let dataPos = myChart.convertFromPixel(&#39;grid&#39;, pos);        if (dataPos[0] &gt; option.xAxis.max || dataPos[0] &lt; option.xAxis.min || dataPos[1] &gt; option.yAxis.max || dataPos[1] &lt; option.yAxis.min) &#123;            return dragListener()        &#125;        data[dataIndex][index] = myChart.convertFromPixel(&#39;grid&#39;, pos);        if (distant(data[dataIndex][0], data[dataIndex][data[dataIndex].length - 1]) &lt; 2) &#123;            data[dataIndex][0] = data[dataIndex][data[dataIndex].length - 1];        &#125;        // Update data        option.series[dataIndex].data = data[dataIndex]        option.series[dataIndex].areaStyle = distant(data[dataIndex][0], data[dataIndex][data[dataIndex].length - 1]) == 0 ? &#123;&#125; : null        myChart.setOption(&#123;            series: option.series        &#125;);        dragListener()    &#125;    if (option &amp;&amp; typeof option === &#39;object&#39;) &#123;        myChart.setOption(option);    &#125;    window.addEventListener(&#39;resize&#39;, dragListener);    myChart.on(&#39;dataZoom&#39;, dragListener);    window.addEventListener(&#39;resize&#39;, myChart.resize);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://img0.baidu.com/it/u=999648122,2374306559&fm=253&fmt=auto&app=138&f=JPEG?w=400&h=400" alt="小埋"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> echarts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-栈溢出与内存溢出小总结</title>
      <link href="/2022/05/31/%E5%89%8D%E7%AB%AF/JavaScript/js-%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2022/05/31/%E5%89%8D%E7%AB%AF/JavaScript/js-%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>总结栈溢出和内存溢出两种情况</p><span id="more"></span><h2 id="一-栈溢出"><a href="#一-栈溢出" class="headerlink" title="一 栈溢出"></a>一 栈溢出</h2><pre><code class="javascript">    var a = 1;    function test()&#123;        console.log(a++)        test()    &#125;    test()</code></pre><p>在谷歌浏览器当中计数达到10470左右,会出现<code>Uncaught RangeError: Maximum call stack size exceeded</code>错误,不同系统不同浏览器计数上限可能有所不同,但都会有一个上限值</p><p>调用栈是有大小限制,当入栈执行的上下文超过一定数目便会出现栈溢出</p><p><code>js</code>代码执行过程中会创建全局上下文,遇到函数会取出函数代码进行编译并创建函数执行的上下文,也就是产生了新的<strong>调用栈</strong>,不断执行上下文压<strong>入栈</strong>,代码执行完毕会<strong>出栈</strong></p><p>上述示例中,函数不断递归调用本身,会不断入栈生成新的调用栈,却一直不出栈,达到栈帧上限便会栈溢出</p><h2 id="二-内存溢出"><a href="#二-内存溢出" class="headerlink" title="二 内存溢出"></a>二 内存溢出</h2><pre><code class="javascript">var obj = &#123;&#125;for(var i = 0; i &lt; 100000000000; i++)&#123;    obj[i] = new Array(100000000000)&#125;</code></pre><p>程序目前需要的内存大于环境目前所能提供的内存，从而导致程序抛出内存溢出的错误信息</p><p>如果在<strong>node</strong>环境下出现内存溢出情况,可适当的调整当前内存上限,通过<code>require(&#39;v8&#39;).getHeapStatistics()</code>查看目前内存情况,具体返回参数情况可参照<a href="https://nodejs.org/api/v8.html#v8_v8_getheapstatistics">官方文档</a></p><pre><code class="javascript">&#123;  total_heap_size: 6090752,  total_heap_size_executable: 573440,  total_physical_size: 6090752,  total_available_size: 4340763536,  used_heap_size: 4169232,  heap_size_limit: 4345298944,  malloced_memory: 8192,  peak_malloced_memory: 712992,  does_zap_garbage: 0,  number_of_native_contexts: 2,  number_of_detached_contexts: 0&#125;</code></pre><ul><li><strong>total_heap_size</strong>：一个数字，表示总堆大小。</li><li><strong>total_heap_size_executable</strong>：一个数字，表示可执行堆的总大小。</li><li><strong>total_physical_size</strong>：一个数字，表示总的物理尺寸。</li><li><strong>total_available_size</strong>：一个数字，表示总可用大小。</li><li><strong>used_heap_size</strong>：一个数字，表示已用堆大小。</li><li><strong>heap_size_limit</strong>：一个数字，表示堆大小限制。</li><li><strong>malloced_memory</strong>：一个数字，表示已分配的内存。</li><li><strong>peak_malloced_memory</strong>：一个数字，表示最大分配的内存。</li><li><strong>does_zap_garbage</strong>：一个数字，特别是一个布尔值，表示-zap_code_space选项是否已启用。</li><li><strong>number_of_native_contexts</strong>：数字，表示许多本机上下文或当前活动的顶级上下文。内存泄漏可能通过测量该数字随时间的增量来指示。</li><li><strong>number_of_detached_contexts</strong>：一个数字，表示多个分离的上下文或已分离但尚未进行垃圾回收的上下文。如果内存泄漏值为非零值，则可能表明该错误。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-内存泄漏出现情况总结</title>
      <link href="/2022/05/30/%E5%89%8D%E7%AB%AF/JavaScript/js-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%87%BA%E7%8E%B0%E6%83%85%E5%86%B5%E6%80%BB%E7%BB%93/"/>
      <url>/2022/05/30/%E5%89%8D%E7%AB%AF/JavaScript/js-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%87%BA%E7%8E%B0%E6%83%85%E5%86%B5%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>总结内存泄漏出现的情况和如何避免</p><span id="more"></span><h2 id="一-定义"><a href="#一-定义" class="headerlink" title="一 定义"></a>一 定义</h2><p>内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p><p>垃圾回收方式一般有两种,分别是<strong>引用计数</strong>和<strong>标记清除</strong></p><p><strong>引用计数</strong>:语言引擎中的引用表会标记内存资源的引用次数,当引用的计数为0代表资源没有被引用获取,则释放该资源</p><p><strong>标记清除</strong>:当变量进入执行环境会做标记,当离开执行环境脱离当前上下文会被释放</p><p>但并不是什么时候内存都能够正确释放,以下几种情况会出现内存泄漏情况</p><h2 id="二-出现内存泄漏的几种情况"><a href="#二-出现内存泄漏的几种情况" class="headerlink" title="二 出现内存泄漏的几种情况"></a>二 出现内存泄漏的几种情况</h2><h4 id="1-全局变量定义问题"><a href="#1-全局变量定义问题" class="headerlink" title="1 全局变量定义问题"></a>1 全局变量定义问题</h4><pre><code class="javascript">function a()&#123;    a=10;&#125;</code></pre><p>函数中未使用变量定义命令会直接定义为全局变量,定义过多会导致内存泄漏,规范变量定义,函数内部注意不要丢失变量定义命令 <code>var</code>,或者<code>let</code>,<code>const</code>定义局部变量常量的方式</p><pre><code class="javascript">function foo() &#123;    this.a = &quot;a&quot;;&#125;foo();</code></pre><p>非严格模式,this 指向了全局对象（window）,使用严格模式可避免</p><h4 id="2-闭包问题"><a href="#2-闭包问题" class="headerlink" title="2 闭包问题"></a>2 闭包问题</h4><pre><code class="javascript">　　function f1()&#123;　　　　var n=999;　　　　nAdd=function()&#123;n+=1&#125;　　　　function f2()&#123;　　　　　　alert(n);　　　　&#125;　　　　return f2;　　&#125;　　var result=f1();　　result(); // 999　　nAdd();　　result(); // 1000</code></pre><p>闭包的一大作用就是暂存变量到内存,但是如果使用后没有及时将赋值的外部变量为<code>null</code>减少引用计数,也将导致内存泄漏</p><h4 id="3-事件监听未移除"><a href="#3-事件监听未移除" class="headerlink" title="3 事件监听未移除"></a>3 事件监听未移除</h4><pre><code class="javascript">function addEvent ()&#123; const node =  document.getElementById(&#39;warp&#39;);    node.addEventListener(&#39;touchmove&#39;,()=&gt;&#123;        console.log(&#39;In Move&#39;);    &#125;)&#125;const onTouchEnd = ()&#123;   const node =  document.getElementById(&#39;warp&#39;);   node.&#125;useEffect(()=&gt;()=&gt;&#123;     const node =  document.getElementById(&#39;warp&#39;);     node.removeEventListener(&#39;touchmove&#39;);&#125;) // 类似react 生命周期函数： componentWillUnmountrender(&lt;div id=&#39;warp&#39; onTouchEnd=&#123;onTouchEnd&#125;&gt; // code...&lt;/div&gt;&#39;)</code></pre><h4 id="4-计时器相关"><a href="#4-计时器相关" class="headerlink" title="4 计时器相关"></a>4 计时器相关</h4><p>定时器<code>setInterval</code>或者<code>setTimeout</code>在不需要使用的时候，没有被clear，导致定时器的回调函数及其内部依赖的变量都不能被回收，这就会造成内存泄漏。</p><p>解决方式：当不需要interval或者timeout的时候，调用<code>clearInterval</code>或者<code>clearTimeout</code></p><h4 id="5-DOM元素可能出现的引用问题"><a href="#5-DOM元素可能出现的引用问题" class="headerlink" title="5 DOM元素可能出现的引用问题"></a>5 DOM元素可能出现的引用问题</h4><pre><code class="javascript">let a = document.getElementById(&#39;a&#39;);document.body.removeChild(a); // dom删除了console.log(a, &#39;a&#39;); // 但是还存在引用能console出整个div 没有被回收a = null;// 解除引用</code></pre><p> <code>dom</code>虽然移除了,但是依然保持引用关系,注意将变量的引用计数减少</p><pre><code class="javascript">var a = &#123;&#125;;document.getElementById(&#39;id&#39;).diyProp = a;</code></pre><p>在<code>window.unonload</code>事件中加上 <code>document.getElementById(&#39;id&#39;).diyProp = null</code>减少引用计数</p><h2 id="三-内存泄漏识别方法"><a href="#三-内存泄漏识别方法" class="headerlink" title="三 内存泄漏识别方法"></a>三 内存泄漏识别方法</h2><p>怎样可以观察到内存泄漏呢?</p><p><a href="https://www.toptal.com/nodejs/debugging-memory-leaks-node-js-applications">经验法则</a>是，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存占用。</p><h4 id="1-浏览器"><a href="#1-浏览器" class="headerlink" title="1 浏览器"></a>1 浏览器</h4><p>Chrome 浏览器查看内存占用，按照以下步骤操作。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017041704.png" alt="img"></p><blockquote><ol><li>打开开发者工具，选择 Timeline(现在已更名为Performance ) 面板</li><li>在顶部的<code>Capture</code>字段里面勾选 Memory</li><li>点击左上角的录制按钮。</li><li>在页面上进行各种操作，模拟用户的使用情况。</li><li>一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。</li></ol></blockquote><p>如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017041705.png" alt="img"></p><p>反之，就是内存泄漏了。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017041706.png" alt="img"></p><h4 id="2-命令行"><a href="#2-命令行" class="headerlink" title="2 命令行"></a>2 命令行</h4><p>命令行可以使用 Node 提供的<a href="https://nodejs.org/api/process.html#process_process_memoryusage"><code>process.memoryUsage</code></a>方法。</p><blockquote><pre><code class="javascript">console.log(process.memoryUsage());// &#123; rss: 27709440,//  heapTotal: 5685248,//  heapUsed: 3449392,//  external: 8772 &#125;</code></pre></blockquote><p><code>process.memoryUsage</code>返回一个对象，包含了 Node 进程的内存占用信息。该对象包含四个字段，单位是字节，<a href="https://stackoverflow.com/questions/12023359/what-do-the-return-values-of-node-js-process-memoryusage-stand-for">含义</a>如下。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017041702-1.png" alt="img"></p><blockquote><ul><li>rss（resident set size）：所有内存占用，包括指令区和堆栈。</li><li>heapTotal：”堆”占用的内存，包括用到的和没用到的。</li><li>heapUsed：用到的堆的部分。</li><li>external： V8 引擎内部的 C++ 对象占用的内存。</li></ul></blockquote><p>判断内存泄漏，以<code>heapUsed</code>字段为准。</p><blockquote><p>参考文档:</p><p><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html">JavaScript 内存泄漏教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p><p><a href="https://fe.ecool.fun/topic/cecf2aa7-4281-4255-95c9-e8ae487760f1?orderBy=updateTime&order=desc&titleKey=%E5%86%85%E5%AD%98">说说 JavaScript 中内存泄漏有哪几种情况？- 题目详情 - 前端面试题宝典 (ecool.fun)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美化-在PC上使用PS5的界面UI管理游戏</title>
      <link href="/2022/05/27/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E7%BE%8E%E5%8C%96/%E7%BE%8E%E5%8C%96-%E5%9C%A8PC%E4%B8%8A%E4%BD%BF%E7%94%A8PS5%E7%9A%84%E7%95%8C%E9%9D%A2UI%E7%AE%A1%E7%90%86%E6%B8%B8%E6%88%8F/"/>
      <url>/2022/05/27/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E7%BE%8E%E5%8C%96/%E7%BE%8E%E5%8C%96-%E5%9C%A8PC%E4%B8%8A%E4%BD%BF%E7%94%A8PS5%E7%9A%84%E7%95%8C%E9%9D%A2UI%E7%AE%A1%E7%90%86%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用Playnite游戏管理工具和PS5主题包将PC打造成”PS5”游戏主机</p><span id="more"></span><p>先来几张效果图（图片较大,请耐心等待)</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/image-20220527193454566.png" alt="image-20220527193454566"></p><p><img src="http://cdn.tangyuxian.com/PicGoImages/image-20220527193746276.png" alt="image-20220527193746276"></p><p><img src="http://cdn.tangyuxian.com/PicGoImages/image-20220527194032818.png" alt="image-20220527194032818"></p><h2 id="一-准备工作"><a href="#一-准备工作" class="headerlink" title="一 准备工作"></a>一 准备工作</h2><p>核心软件:<a href="https://www.playnite.link/">playnite游戏管理工具</a></p><p>必备插件:<a href="https://github.com/davidkgriggs/PS5ish/releases/">PS5ish</a>;<a href="https://github.com/davidkgriggs/DKG-Theme-Modifier/releases">DKG Theme Modifier</a></p><p>请先安装好playnite游戏管理工具,再下载好下面两个插件,拖拽到游戏管理工具界面安装</p><h2 id="二-playnite基本用法"><a href="#二-playnite基本用法" class="headerlink" title="二 playnite基本用法"></a>二 playnite基本用法</h2><h4 id="1-导入游戏"><a href="#1-导入游戏" class="headerlink" title="1 导入游戏"></a>1 导入游戏</h4><p>在软件界面左上角点击<strong>添加游戏</strong>,并选择<strong>自动扫描</strong>,在该界面可选择浏览安装在本地的游戏启动程序或者扫描指定的文件夹;</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/image-20220527195132979.png" alt="image-20220527195132979"></p><p>勾选导入的游戏后确认<strong>添加游戏</strong></p><h4 id="2-自定义编辑或下载游戏信息"><a href="#2-自定义编辑或下载游戏信息" class="headerlink" title="2 自定义编辑或下载游戏信息"></a>2 自定义编辑或下载游戏信息</h4><p><img src="http://cdn.tangyuxian.com/PicGoImages/image-20220527200725094.png" alt="image-20220527200725094"></p><p><img src="http://cdn.tangyuxian.com/PicGoImages/image-20220527200707126.png" alt="image-20220527200707126"></p><p>点击旁边的<strong>笔</strong>符号可修改游戏的基本信息,在该界面点击左下角可直接下载该游戏的相关数据</p><p>具体用法不一一赘述,可访问<a href="https://github.com/JosefNemec/Playnite/wiki">wiki</a>阅读官方文档</p><h2 id="三-主题使用方法"><a href="#三-主题使用方法" class="headerlink" title="三 主题使用方法"></a>三 主题使用方法</h2><h4 id="1-确认插件已安装完毕"><a href="#1-确认插件已安装完毕" class="headerlink" title="1 确认插件已安装完毕"></a>1 确认插件已安装完毕</h4><p><img src="http://cdn.tangyuxian.com/PicGoImages/image-20220527201135849.png" alt="image-20220527201135849"></p><p>在点击左上角,选择<strong>附加组件</strong>可看到自己新增的插件</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20220527201421.png" alt="img"></p><p>确保图中这两个插件均已安装并已经是启用状态</p><h4 id="2-激活插件"><a href="#2-激活插件" class="headerlink" title="2 激活插件"></a>2 激活插件</h4><p>主题包的官方英文文档地址: <a href="https://playnite.link/forum/thread-492.html">PS5ish - A PS5 UI Inspired Theme</a></p><p><img src="http://cdn.tangyuxian.com/PicGoImages/image-20220527201852314.png" alt="image-20220527201852314"></p><p>在当前界面,选择 <strong>Apply Change</strong>,弹出成功对话框后,点击保存,回到游戏列表界面,此时按<strong>F11</strong>进入全屏模式</p><h4 id="3-全屏模式切换主题"><a href="#3-全屏模式切换主题" class="headerlink" title="3 全屏模式切换主题"></a>3 全屏模式切换主题</h4><p>在全屏模式下点击右上角<strong>菜单图标</strong>,或者按手柄的<strong>start键</strong>,唤出菜单;</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/image-20220527202456753.png" alt="image-20220527202456753"></p><p><img src="http://cdn.tangyuxian.com/PicGoImages/image-20220527202531028.png" alt="image-20220527202531028"></p><p><strong>设置-&gt;画面-&gt;主题</strong></p><p>在主题中切换使用<strong>PS5ish</strong>,返回界面根据提示重启程序</p><h4 id="4-布局调整"><a href="#4-布局调整" class="headerlink" title="4 布局调整"></a>4 布局调整</h4><p>若在重启程序后界面出现如下信息</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/image-20220527202921557.png" alt="image-20220527202921557"></p><p>则代表需要关闭横向滚动,请到 <strong>设置&gt;布局&gt;水平滚动</strong>  取消勾选即可</p><p>如此便完成了PS5主题的基本使用</p><h2 id="四-进阶"><a href="#四-进阶" class="headerlink" title="四 进阶"></a>四 进阶</h2><h4 id="1-添加预告片和游戏徽标"><a href="#1-添加预告片和游戏徽标" class="headerlink" title="1 添加预告片和游戏徽标"></a>1 添加预告片和游戏徽标</h4><p>项目地址:<a href="https://github.com/darklinkpower/PlayniteExtensionsCollection/releases">PlayniteExtensionsCollection</a></p><p>教程地址:<a href="https://playnite.link/forum/thread-575.html">Extra Metadata Fullscreen Mode Helper</a></p><p><img src="http://cdn.tangyuxian.com/PicGoImages/image-20220527203753708.png" alt="image-20220527203753708"></p><p>请根据教程下载相关程序包,在新添加游戏后,插件将执行程序抓取steam上的视频和游戏徽标资料,徽标资料可能需要您提供SteamGridDB API密钥才可使用</p><h4 id="2通关时长预分析"><a href="#2通关时长预分析" class="headerlink" title="2通关时长预分析"></a>2通关时长预分析</h4><p>项目地址:<a href="https://github.com/Lacro59/playnite-howlongtobeat-plugin/releases">playnite-howlongtobeat-plugin</a></p><p>教程地址:<a href="https://playnite.link/forum/thread-309.html">HowLongToBeat</a></p><p><img src="http://cdn.tangyuxian.com/PicGoImages/image-20220527204757898.png" alt="image-20220527204757898"></p><p>将记录您目前的游戏时长和需通关该游戏以及游戏白金时长,做基本的数据对比分析</p><p>更多高阶玩法等您来挖掘,比如使用任天堂switch的UI界面…</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/image-20220527210306464.png" alt="image-20220527210306464"></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于jsdelivr失效的紧急修复方案</title>
      <link href="/2022/05/17/%E5%85%B6%E5%AE%83/%E5%85%B3%E4%BA%8Ejsdelivr%E5%A4%B1%E6%95%88%E7%B4%A7%E6%80%A5%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88/"/>
      <url>/2022/05/17/%E5%85%B6%E5%AE%83/%E5%85%B3%E4%BA%8Ejsdelivr%E5%A4%B1%E6%95%88%E7%B4%A7%E6%80%A5%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>jsdelivr失效后的补救计划</p><span id="more"></span><p>目前,<code>jsdelivr</code>处于十分不稳定状态,为了网站的长期发展,将去除所有与jsdelivr有关的cdn加速服务;</p><h2 id="一-停用jsdelivr改用unpkg"><a href="#一-停用jsdelivr改用unpkg" class="headerlink" title="一 停用jsdelivr改用unpkg"></a>一 停用jsdelivr改用unpkg</h2><p>将原本的依赖地址前缀 <code>https://cdn.jsdelivr.net/npm/</code> 替换为 <code>https://unpkg.com/</code></p><h2 id="二-使用github创建的图床请及时迁移"><a href="#二-使用github创建的图床请及时迁移" class="headerlink" title="二 使用github创建的图床请及时迁移"></a>二 使用github创建的图床请及时迁移</h2><p>所有使用<code>jsdelivr</code>配合<code>github</code>做的图床将失效,请采用以下方式做图床迁移</p><ol><li><a href="https://github.com/Suxiaogang/WeiboPicBed">微博图床</a>:使用微博提供的上传接口实现,图片上传后可在插件中看到返回的图片地址</li><li><a href="https://github.com/xlzy520/typora-plugin-bilibili">哔哩哔哩图床</a>:在typora编辑器上或浏览器插件中随时上传图片,并返回图片地址</li><li><a href="https://www.imgurl.org/">imgurl</a>:免费图片外链工具</li><li><a href="https://sm.ms/">sm.ms</a>:老牌图床网站,依然免费,但是有收费服务</li><li><a href="https://www.imagehub.cc/">imagehub</a>:免费图片托管,但是要注意是否能持续提供服务,并及时备份自己的图片资源</li></ol><h2 id="三-最新的开源主题已在github上发布-请及时更新"><a href="#三-最新的开源主题已在github上发布-请及时更新" class="headerlink" title="三 最新的开源主题已在github上发布,请及时更新"></a>三 最新的开源主题已在github上发布,请及时更新</h2><p><a href="https://github.com/tangyuxian/hexo-theme-tangyuxian">tangyuxian/hexo-theme-tangyuxian: Dedicated theme for Hexo (github.com)</a></p><p align="left"><img style="display: inline" alt="star" src="https://img.shields.io/github/stars/tangyuxian/hexo-theme-tangyuxian.svg"/><img style="display: inline" alt="fork" src="https://img.shields.io/github/forks/tangyuxian/hexo-theme-tangyuxian.svg"/><img style="display: inline" alt="GitHub last commit" src="https://img.shields.io/github/last-commit/tangyuxian/hexo-theme-tangyuxian.svg?label=commits"><img style="display: inline" alt="issues" src="https://img.shields.io/github/issues/tangyuxian/hexo-theme-tangyuxian.svg"/><a href="https://www.tangyuxian.com"><img style="display: inline" alt="Author" src="https://img.shields.io/badge/author-糖羽仙-red.svg"/></a><a href="http://wpa.qq.com/msgrd?v=3&uin=2120252100&site=qq&menu=yes"><img style="display: inline" alt="QQ" src="https://img.shields.io/badge/QQ-2120252100-red.svg"/></a><a href="https://github.com/tangyuxian/hexo-theme-tangyuxian/blob/master/LICENSE"><img style="display: inline" alt="license" src="https://img.shields.io/github/license/tangyuxian/hexo-theme-tangyuxian.svg"/></a><img style="display: inline" alt="hexo" src="https://img.shields.io/badge/hexo-blue.svg"/><img style="display: inline" alt="Download" src="https://img.shields.io/badge/download-29.9KB-brightgreen.svg"/></p>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-vuex中Mutation和Action小总结</title>
      <link href="/2022/05/09/%E5%89%8D%E7%AB%AF/vue/vue-vuex%E4%B8%ADMutation%E5%92%8CAction%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2022/05/09/%E5%89%8D%E7%AB%AF/vue/vue-vuex%E4%B8%ADMutation%E5%92%8CAction%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>针对Vuex中Mutation和Action使用小总结</p><span id="more"></span><p>“为什么在<strong>Vuex</strong>中<strong>Mutation</strong>只能是同步?可以异步吗?<strong>Action</strong>可以直接修改<strong>State</strong>吗?能修改还要<strong>Mutaition</strong>有什么用?”面试官不动声色道.这咄咄逼人的问题一个接着一个抛出,让本糖一瞬间哑然,当时我瞬间想拍桌站起来喊道:”为什么?哪那么多为什么,犹大定的规则你问他啊?”当然只是想想.</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/202205092010196.jpeg" alt="img"></p><p>平时使用本糖也从来没考虑这么多,使用的时候一直将这些当成游戏规则来看待,现在一起看下游戏规则为什么会这么制定</p><h2 id="一-为什么Mutation中是同步函数"><a href="#一-为什么Mutation中是同步函数" class="headerlink" title="一 为什么Mutation中是同步函数"></a>一 为什么Mutation中是同步函数</h2><p>其实这如果看官方文档,就能找到其中的缘由,在 <a href="https://vuex.vuejs.org/zh/guide/mutations.html#mutation-%E5%BF%85%E9%A1%BB%E6%98%AF%E5%90%8C%E6%AD%A5%E5%87%BD%E6%95%B0">Vuex:mutation-必须是同步函数</a>中明确提到,<strong>Mustation</strong>是<strong>可以写</strong>异步函数,但是问题在于<strong>Mustation</strong>本身的任务,就是用来修改<strong>State</strong>中的值,使命单一且重要,同步修改可以让 <a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd">devtools</a> (下载插件需要代理访问)捕捉到整个<strong>State</strong>状态值的变化情况,并做出快照,异步函数中的回调函数中修改虽然也可以,但是却让整个修改过程无法追踪</p><h2 id="二-Action可以直接修改State吗"><a href="#二-Action可以直接修改State吗" class="headerlink" title="二 Action可以直接修改State吗?"></a>二 Action可以直接修改State吗?</h2><p>答案依然是可以,但不推荐.就像上面说的,它们都被分配了不同的使命,来各司其职,<strong>Action</strong>更多的时候是呈现逻辑性质的操作,比如文章的获取,用户登录后的信息等,如果要被记录在状态管理器中,那么在<strong>Action</strong>中处理就再合适不过,存<strong>State</strong>时通过<strong>commit</strong>提交到<strong>Mutation</strong>,将存值这一任务交给专业人士处理.</p><p><a href="https://vuex.vuejs.org/zh/guide/strict.html">严格模式</a>的开启与否将决定着<strong>Action</strong>是否有资格直接跳过<strong>Mutation</strong>直接修改<strong>State</strong>值.</p><p>总结来说,无论是Mutation还是Action都可以修改State值,也都可以异步或同步操作.为何对二者的要求却各不相同呢?之所以这么做,一是要做到规范化开发,做到各司其职,二是便于调试和Debug,提高代码稳定性.</p><p>既然<strong>Mutation</strong>的作用是修改<strong>State</strong>,同时方便devtools记录快照进行debug,那可不可以让<strong>Mutation</strong>和<strong>Action</strong>合二为一,即能直接修改State,也能记录修改状态方便debug呢?</p><p><a href="https://pinia.vuejs.org/"><strong>Pinia</strong></a>你值得拥有,看到这个可爱的小菠萝了嘛?</p><p><img src="https://pinia.vuejs.org/logo.svg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> xuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器-事件流理解总结</title>
      <link href="/2022/05/06/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%90%86%E8%A7%A3%E6%80%BB%E7%BB%93/"/>
      <url>/2022/05/06/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%90%86%E8%A7%A3%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>关于事件流机制的理解以及对e.target 和 e.currentTarget问题处理</p><span id="more"></span><h2 id="一-DOM事件流"><a href="#一-DOM事件流" class="headerlink" title="一 DOM事件流"></a>一 DOM事件流</h2><p>DOM(文档对象模型)结构是一个树型结构，当一个HTML元素产生一个事件时，该事件会在元素节点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为DOM事件流。</p><p>上面这句话来自<a href="https://baike.baidu.com/item/DOM%E4%BA%8B%E4%BB%B6%E6%B5%81/7508053?fr=aladdin">百度百科:DOM事件流</a>,该如何理解这句话呢,如图所示,</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/202205072002999.jpeg" alt="img"></p><p>当有事件触发时,从DOM的根节点开始,向内传递,这一过程可以理解成<strong>①②③④</strong>的<strong>捕获阶段</strong>;如果图中的<strong>d</strong>节点被触发,事件整个传递到达<strong>目标阶段</strong>,该阶段结束后,事件会向上传递,这一过程按照水底的气泡一样向上漂,称之为的<strong>⑤⑥⑦⑧</strong> <strong>冒泡阶段</strong></p><p>结合图和上面的描述可以总结为</p><p>在DOM兼容浏览器中，事件流分为3个阶段：</p><ol><li>捕获阶段：事件从Document节点自上而下向目标节点传播的阶段；</li><li>目标阶段：真正的目标节点正在处理事件的阶段；</li><li>冒泡阶段：事件从目标节点自下而上向Document节点传播的阶段</li></ol><h2 id="二-捕获事件流"><a href="#二-捕获事件流" class="headerlink" title="二 捕获事件流"></a>二 捕获事件流</h2><p>捕获事件流可以在支持<a href="https://www.w3.org/">W3C </a> 标准的浏览器中使用<strong>addEventListener</strong>处理,在<a href="https://www.runoob.com/jsref/met-element-addeventlistener.html">菜鸟教程:addEventListener</a> 中在线体验.</p><p>该函数有三个参数:</p><ol><li>事件名</li><li>触发执行函数</li><li>冒泡阶段还是捕获阶段执行,默认是在冒泡阶段执行</li></ol><p>为了理解这个问题,我在网上看到一道十分有意思的题 <a href="https://fe.ecool.fun/topic/4b1cefdc-57fd-443e-94ff-df06135cf5ac?orderBy=updateTime&order=desc&tagId=0">事件流经典问题:e.target 和 e.currentTarget 有什么区别？</a> ,一起来看下,加深理解.</p><pre><code class="html">    &lt;div id=&quot;a&quot;&gt;      &lt;div id=&quot;b&quot;&gt;        &lt;div id=&quot;c&quot;&gt;          &lt;div id=&quot;d&quot;&gt;点击这里&lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;</code></pre><pre><code class="javascript">const a = document.getElementById(&#39;a&#39;)const b = document.getElementById(&#39;b&#39;)const c = document.getElementById(&#39;c&#39;)const d = document.getElementById(&#39;d&#39;)a.addEventListener(&#39;click&#39;, (e) =&gt; &#123;  const &#123;    target,    currentTarget  &#125; = e  console.log(`target是$&#123;target.id&#125;`)  console.log(`currentTarget是$&#123;currentTarget.id&#125;`)&#125;)b.addEventListener(&#39;click&#39;, (e) =&gt; &#123;  const &#123;    target,    currentTarget  &#125; = e  console.log(`target是$&#123;target.id&#125;`)  console.log(`currentTarget是$&#123;currentTarget.id&#125;`)&#125;)c.addEventListener(&#39;click&#39;, (e) =&gt; &#123;  const &#123;    target,    currentTarget  &#125; = e  console.log(`target是$&#123;target.id&#125;`)  console.log(`currentTarget是$&#123;currentTarget.id&#125;`)&#125;)d.addEventListener(&#39;click&#39;, (e) =&gt; &#123;  const &#123;    target,    currentTarget  &#125; = e  console.log(`target是$&#123;target.id&#125;`)  console.log(`currentTarget是$&#123;currentTarget.id&#125;`)&#125;)</code></pre><p>想想输出的结果是什么?</p><p><strong>addEventListener</strong>第三个参数不设置默认是冒泡顺序,当触发d时,呈现的结果如下</p><pre><code>target是d currentTarget是dtarget是d currentTarget是ctarget是d currentTarget是btarget是d currentTarget是a</code></pre><p>将<strong>addEventListener</strong>第三个参数设置为true,看看捕获阶段呢?</p><pre><code>target是d currentTarget是atarget是d currentTarget是btarget是d currentTarget是ctarget是d currentTarget是d</code></pre><p>总结如下:</p><ol><li><code>e.target</code>：<strong>触发</strong>事件的元素</li><li><code>e.currentTarget</code>：<strong>绑定</strong>事件的元素</li></ol><h2 id="三-事件委托"><a href="#三-事件委托" class="headerlink" title="三 事件委托"></a>三 事件委托</h2><p>通过上面的例子,我们可以很清晰的发现,如果当前父级元素下有若干个子级元素,对父级做监听后,当我们通过<strong>addEventListener</strong>回调函数返回的<code>e.tartget</code>便能得到触发事件的元素.</p><pre><code class="html">    &lt;div id=&#39;list&#39;&gt;        &lt;div id=&#39;item-1&#39;&gt;item-1&lt;/div&gt;        &lt;div id=&#39;item-2&#39;&gt;item-2&lt;/div&gt;        &lt;div id=&#39;item-3&#39;&gt;item-3&lt;/div&gt;        &lt;div id=&#39;item-4&#39;&gt;item-4&lt;/div&gt;    &lt;/div&gt;</code></pre><p>通过给id为list的元素添加监听,在点击列表中的元素,便可实现事件委托,事件委托便是<strong>处理事件处理程序过多</strong>问题的一种解决方案</p><h2 id="四-阻止事件流"><a href="#四-阻止事件流" class="headerlink" title="四 阻止事件流"></a>四 阻止事件流</h2><p>阻止事件流常用的两种种方式</p><p><strong>e.stopPropagation()</strong>:阻止目标元素的事件冒泡到父级元素;</p><p><strong>e.preventDefault()</strong>:取消一个目标元素的默认行为(例如:<code>a</code>链接,<code>input</code>标签的<code>submit</code>等)</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 浏览器 </tag>
            
            <tag> 事件流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-关于变量与函数解析规则总结</title>
      <link href="/2022/05/05/%E5%89%8D%E7%AB%AF/JavaScript/js-%E5%85%B3%E4%BA%8E%E5%8F%98%E9%87%8F%E4%B8%8E%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93/"/>
      <url>/2022/05/05/%E5%89%8D%E7%AB%AF/JavaScript/js-%E5%85%B3%E4%BA%8E%E5%8F%98%E9%87%8F%E4%B8%8E%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>通过变量和函数重名这一情况理解和分析二者的解析规则</p><span id="more"></span><h2 id="一-解析规则"><a href="#一-解析规则" class="headerlink" title="一 解析规则"></a>一 解析规则</h2><ol><li>函数声明会置顶</li><li>变量声明会置顶</li><li><strong>函数</strong>声明优先级<strong>高于</strong>变量<strong>声明,重名时</strong>函数是<strong>一等公民</strong></li><li>变量和赋值语句一起书写,在js引擎解析时，会将其拆成声明和赋值两个部分,声明置顶,赋值保留在原来位置(参考: <a href="https://www.runoob.com/js/js-hoisting.html">菜鸟教程:JavaScript 声明提升</a>)</li><li>声明过的变量不会重复声明</li></ol><h2 id="二-根据解析规则测试几种情况"><a href="#二-根据解析规则测试几种情况" class="headerlink" title="二 根据解析规则测试几种情况"></a>二 根据解析规则测试几种情况</h2><h4 id="1-函数和变量重名下执行情况"><a href="#1-函数和变量重名下执行情况" class="headerlink" title="1 函数和变量重名下执行情况"></a>1 函数和变量重名下执行情况</h4><pre><code class="javascript">foo();var foo;function foo()&#123;  console.log(1);&#125;foo = function()&#123;  console.log(2);&#125;foo()//结果:1</code></pre><p>函数和变量都会提升,但函数优先于变量,再次声明变量foo,因已存在不会重复声明,最上面的函数执行输出1,在重新赋值后,再次执行将输出2</p><h4 id="2-立即执行函数情况"><a href="#2-立即执行函数情况" class="headerlink" title="2 立即执行函数情况"></a>2 立即执行函数情况</h4><pre><code class="javascript">var a = 5;var b = 10;(function b()&#123;    b = 20;    console.log(a);    console.log(b); &#125;)();//结果:5 funciton b</code></pre><p>立即执行的函数名不允许修改,被认为是匿名自执行函数,非严格模式静默修改失败,严格模式(<code>&quot;use strict&quot;</code>)抛出<code>&quot;Uncaught TypeError: Assignment to constant variable.&quot;</code>错误</p><p>参照 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/IIFE">MDN:IIFE（立即调用函数表达式）</a> </p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美化-个性化百度搜索结果</title>
      <link href="/2022/05/03/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E7%BE%8E%E5%8C%96/%E7%BE%8E%E5%8C%96-%E4%B8%AA%E6%80%A7%E5%8C%96%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C/"/>
      <url>/2022/05/03/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E7%BE%8E%E5%8C%96/%E7%BE%8E%E5%8C%96-%E4%B8%AA%E6%80%A7%E5%8C%96%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用脚本注入方式个性化处理搜索结果,屏蔽推广</p><span id="more"></span><p>首先来两张美图,提前预览下最终效果</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/202205030928615.png" alt="image-20220503092849142"></p><p><img src="http://cdn.tangyuxian.com/PicGoImages/202205030929583.png" alt="image-20220503092912031"></p><p><img src="http://cdn.tangyuxian.com/PicGoImages/202205031144059.png" alt="image-20220503114405105"></p><p>能够看出来,经过美化后的搜索结果,更清新更美观,而且不仅仅是美观这么简单,还屏蔽掉系统推广等信息.</p><p>接下来简单说下实现步骤</p><h2 id="一-依赖工具"><a href="#一-依赖工具" class="headerlink" title="一 依赖工具"></a>一 依赖工具</h2><p>这种可以修改网页内容信息其实通过的是脚本注入的方式实现,将我们当前的脚本注入到指定网站当中,替换和抓取当前网站元素,然后替换或追加信息,从而实现个性化自定义功能.</p><p>这里采用的是<a href="https://www.tampermonkey.net/">tampermonkey</a>这是一款免费的<strong>用户脚本管理器</strong>,可以通过它来创建脚本,在网站载入时执行.</p><p>除了通过官网下载,也可通过浏览器带的扩展程序市场下载:</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/202205030938743.png" alt="image-20220503093818755"></p><h2 id="二-获取和添加脚本"><a href="#二-获取和添加脚本" class="headerlink" title="二 获取和添加脚本"></a>二 获取和添加脚本</h2><p>安装好依赖后,便准备开始添加脚本信息.在浏览器顶部位置点击该扩展程序,会有如下界面:</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/202205030940133.png" alt="image-20220503094044319"></p><p>在管理面板中可随时管理已下载安装的脚本.</p><p>接下来简单说说创建脚本信息.</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/202205030948660.png" alt="image-20220503094833076"></p><p>创建脚本信息本质是在自执行函数中编写JavaScript脚本,在该脚本中可获取dom元素,追加样式信息来实现一些屏蔽和美化的功能.</p><p>写好的脚本保存好后,注意别忘记设置要注入的网站,</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/202205030953988.png" alt="image-20220503095259577"></p><h2 id="三-进一步美化"><a href="#三-进一步美化" class="headerlink" title="三 进一步美化"></a>三 进一步美化</h2><h4 id="以下是对百度搜索结果的部分美化"><a href="#以下是对百度搜索结果的部分美化" class="headerlink" title="以下是对百度搜索结果的部分美化"></a>以下是对百度搜索结果的部分美化</h4><pre><code class="css"> body&#123; position:reactive; &#125;/*自定义背景图*/ body:before&#123; content:&#39;&#39;; width:100%; height:100%; position:fixed; background-image:url(&#39;&#39;); background-size:100% 100%; top:0; left:0; z-index:0; &#125;/*模糊每一项*/ .new-pmd.c-container&#123; border-radius:10px !important; background: linear-gradient(90deg, white, transparent) !important; backdrop-filter: blur(15px); &#125; #wrapper_wrapper #container #content_left&gt;.result, .result-op, .op-vmp-zxenterprise&#123; background: linear-gradient(90deg, white, transparent) !important; &#125; #wrapper_wrapper #container #content_left&gt;.result:hover&#123; background:#fff !important; &#125; .c-container.xpath-log:hover&#123; background:#fff !important; &#125; .blur-search-bg&#123; display:none; &#125; .new-pmd.c-container:hover&#123; backdrop-filter: blur(15px) !important; background: #fff !important; box-shadow:none !important; &#125; .c-result-content&#123; display:none; &#125;/*预选项和翻页*/ #s_tab,#page,.rs-link_2DE3Q&#123; position: relative; z-index:2; background: linear-gradient(45deg, white, transparent) !important; backdrop-filter: blur(5px); &#125; .rs-col_8Qlx- a&#123; background: linear-gradient(45deg, #ffbfaa, transparent) !important; color:#fff !important; &#125; .rs-col_8Qlx- a:hover&#123; color:#ffbfaa !important; background: linear-gradient(45deg, #fff, transparent) !important; &#125; .container_l #content_right&#123; border-radius:10px !important; background: linear-gradient(45deg, #000, transparent) !important; padding:10px !important; backdrop-filter: blur(15px); &#125; .container_l #content_right:hover&#123; background:none !important; &#125; #content_right a&#123; color:#fff !important; &#125; .page_2muyV strong&#123; background-color: #ffbfaa !important; border:none !important; border-radius:50%;&#125;.page_2muyV a&#123;background-color: #fff !important;border:none !important;border-radius:50%;color:#ffbfaa !important;&#125;.page_2muyV a:hover, .page_2muyV a:hover .page-item_M4MDr&#123;background: #ffbfaa !important;color:#fff !important;&#125;#page .pc, #page .n&#123;border:none;&#125;</code></pre><h4 id="匹配移除广告推广"><a href="#匹配移除广告推广" class="headerlink" title="匹配移除广告推广"></a>匹配移除广告推广</h4><pre><code class="Javascript">//参照已有的脚本处理$(&quot;.c-container&gt;.f13&quot;).each(function () &#123;    var text = $(this).text();    if (text.indexOf(&#39;广告&#39;) != -1) &#123;        $(this).parents(&#39;.c-container&#39;).remove();    &#125;&#125;);$(&quot;.c-span-last span&quot;).each(function () &#123;    var text = $(this).text();    if (text.indexOf(&#39;广告&#39;) != -1) &#123;        $(this).parents(&#39;.c-container&#39;).remove();    &#125;&#125;);$(&quot;font[class*=ec_tuiguang] span&quot;).each(function () &#123;    var text = $(this).text();    if (text.indexOf(&#39;广告&#39;) != -1) &#123;        $(this).parents(&#39;.c-container&#39;).remove();    &#125;&#125;);</code></pre><h4 id="推荐几款不错的百度脚本"><a href="#推荐几款不错的百度脚本" class="headerlink" title="推荐几款不错的百度脚本:"></a>推荐几款不错的百度脚本:</h4><p><a href="https://greasyfork.org/zh-CN/scripts/370756-%E7%99%BE%E5%BA%A6%E5%8E%BB%E5%B9%BF%E5%91%8A-blur-%E6%AF%9B%E7%8E%BB%E7%92%83-%E6%90%9C%E7%B4%A2%E6%A1%86-%E7%BE%8E%E5%8C%96">百度去广告,blur毛玻璃</a></p><p><a href="https://github.com/shitianshiwa/baidu-tieba-userscript/tree/master/%E8%B4%B4%E5%90%A7%E5%85%A8%E8%83%BD%E5%8A%A9%E6%89%8B">贴吧全能小助手</a></p><h4 id="推荐几个不错的二次元随机图片API"><a href="#推荐几个不错的二次元随机图片API" class="headerlink" title="推荐几个不错的二次元随机图片API"></a>推荐几个不错的二次元随机图片API</h4><p><a href="https://www.dmoe.cc/random.php">樱花图片</a></p><p><a href="https://img.paulzzh.com/">东方project</a></p><p><a href="https://img.r10086.com/">樱道</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UI库-使用scss处理多主题切换功能</title>
      <link href="/2022/04/12/%E5%89%8D%E7%AB%AF/UI%E5%BA%93/UI%E5%BA%93-%E4%BD%BF%E7%94%A8scss%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2%E5%8A%9F%E8%83%BD/"/>
      <url>/2022/04/12/%E5%89%8D%E7%AB%AF/UI%E5%BA%93/UI%E5%BA%93-%E4%BD%BF%E7%94%A8scss%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用scss处理多主题的问题总结,拿来即用,少走弯路</p><span id="more"></span><p>项目当中有类似白天黑夜或者其它主题的切换需求,这类工作最好在项目构建之初便考虑到并且提前配置好,这里结合我在网上查到的一些方法还有实际工作需求,做一个总结.</p><h2 id="一-定义主题文件"><a href="#一-定义主题文件" class="headerlink" title="一 定义主题文件"></a>一 定义主题文件</h2><p>既然是多主题,就需要我们一开始就需要考虑到提前将UI中的色系及字体等情况做一个统一的配置,如下图,创建一个<code>_themes.scss</code>文件在静态资源目录下,我们一般放在工程中的<code>/src/assets/css</code>下.</p><pre><code class="css">$themes: (  default:(    /*字体*/    font-size-lg : 18px,    /*颜色*/    bg-color: #fff,    font-color:#000  ),  dark:(    /*字体*/    font-size-lg : 36px,    /*颜色*/    bg-color: #000,    font-color:#fff  ))</code></pre><p>在该文件我们定义两套主题,分别为<code>default</code>和<code>dark</code></p><h2 id="二-定义主题匹配文件"><a href="#二-定义主题匹配文件" class="headerlink" title="二 定义主题匹配文件"></a>二 定义主题匹配文件</h2><p>在实际项目中,通过调用<code>scss</code>函数来匹配不同的主题,创建一个<code>_themeify.scss</code>文件</p><pre><code class="css">@import &quot;./_themes.scss&quot;;@mixin themeify &#123;  @each $theme-name, $theme-map in $themes &#123;    $theme-map: $theme-map !global;    [data-theme=#&#123;$theme-name&#125;] &amp; &#123;      @content;    &#125;  &#125;&#125;@function themed($key) &#123;  @return map-get($theme-map, $key);&#125;</code></pre><p>具体<code>scss</code>函数方法使用规则可以参照<a href="https://www.sass.hk/">sass官网</a>,这里用到了预处理中的控制指令,遍历每一项,<code>!global</code>关键词提权到全局.</p><h2 id="三-如何使用"><a href="#三-如何使用" class="headerlink" title="三 如何使用"></a>三 如何使用</h2><h4 id="1-定义一个其它的scss文件-我们暂且取名为other-scss-使用方法如下"><a href="#1-定义一个其它的scss文件-我们暂且取名为other-scss-使用方法如下" class="headerlink" title="1 定义一个其它的scss文件,我们暂且取名为other.scss,使用方法如下:"></a>1 定义一个其它的<code>scss</code>文件,我们暂且取名为<code>other.scss</code>,使用方法如下:</h4><pre><code class="css">@mixin home()&#123;    width: 100px;    height: 100px;    @include themeify&#123;        background-color: themed(&#39;bg-color&#39;);        font-size: themed(&#39;font-size-lg&#39;)    &#125;&#125;</code></pre><p>这里我们注意到,想要调用配置的主题颜色需要通过<code>@include</code>调用,并通过<code>themed()</code>函数将配置的变量名传入即可.</p><h4 id="2-统一导出"><a href="#2-统一导出" class="headerlink" title="2 统一导出"></a>2 统一导出</h4><p>创建一个<code>index.scss</code>用于统一的样式导出</p><pre><code class="css">@import &quot;./_themeify.scss&quot;;@import &quot;./other.scss&quot;;</code></pre><p>这样做的目的便于统一管理,结构清晰,此时<code>css</code>文件夹下应该是这几个文件</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/202204122236763.png" alt="image-20220412223652204"></p><h4 id="3-配置全局引入"><a href="#3-配置全局引入" class="headerlink" title="3 配置全局引入"></a>3 配置全局引入</h4><p>这里用<code>vite</code>举例,通过下述方式即可</p><pre><code class="json">export default defineConfig(&#123;    css:&#123;        preprocessorOptions:&#123;          scss:&#123;            additionalData:&#39;@import &quot;@/assets/css/index.scss&quot;;&#39;          &#125;        &#125;  &#125;&#125;)</code></pre><h4 id="4-修改当前主题"><a href="#4-修改当前主题" class="headerlink" title="4 修改当前主题"></a>4 修改当前主题</h4><p>在vue3工程中,可在根目录下修改<code>index.html</code>给body标签增加<code>data-theme=&quot;default&quot;</code>属性</p><h4 id="5-使用"><a href="#5-使用" class="headerlink" title="5 使用"></a>5 使用</h4><p>在<code>vue</code>项目中,可以像下面例子直接使用,无论是正常调用定义的预处理函数,还是直接调用主题颜色都可.</p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;wrapper&quot;&gt;    &lt;div class=&quot;box&quot;&gt;      测试文字    &lt;/div&gt;    &lt;div&gt;      &lt;button @click=&quot;changeTheme&quot;&gt;切换主题&lt;/button&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;ref&#125; from &quot;vue&quot;;   //定义主题状态   let themeType = ref&lt;string&gt;(&#39;default&#39;);   /**    * 改变主题    */   const changeTheme = ():void =&gt;&#123;     themeType.value = themeType.value == &#39;default&#39;?&#39;dark&#39;:&#39;default&#39;      document.getElementsByTagName(&#39;body&#39;)[0].setAttribute(&#39;data-theme&#39;,themeType.value)   &#125;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt; .box&#123;   @include home();   @include themeify&#123;    color: themed(&#39;font-color&#39;);   &#125; &#125;&lt;/style&gt;</code></pre><p>示例:</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/202204122233957.png" alt="image-20220412223312012"></p><p><img src="http://cdn.tangyuxian.com/PicGoImages/202204122234753.png" alt="image-20220412223407052"></p><p><img src="http://cdn.tangyuxian.com/PicGoImages/202204122234153.png" alt="image-20220412223423699"></p><p><img src="http://cdn.tangyuxian.com/PicGoImages/202204122234354.png" alt="image-20220412223449701"></p><p>看了不少教程,决定还是好好总结一番,写一篇拿来就能用的文章,让同样碰到该问题的小伙伴能够少走弯路.</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> elementPlus </tag>
            
            <tag> UI库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-类型相关总结</title>
      <link href="/2022/03/22/%E5%89%8D%E7%AB%AF/JavaScript/js-%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
      <url>/2022/03/22/%E5%89%8D%E7%AB%AF/JavaScript/js-%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>总结前端类型和与类型相关的常见问题</p><span id="more"></span><h2 id="一-数据类型"><a href="#一-数据类型" class="headerlink" title="一 数据类型"></a>一 数据类型</h2><h4 id="1-值类型-基本类型"><a href="#1-值类型-基本类型" class="headerlink" title="1.值类型(基本类型)"></a>1.值类型(基本类型)</h4><p>字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。</p><h4 id="2-引用数据类型（对象类型）"><a href="#2-引用数据类型（对象类型）" class="headerlink" title="2.引用数据类型（对象类型）"></a>2.引用数据类型（对象类型）</h4><p>对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）。</p><h2 id="二-隐式转换"><a href="#二-隐式转换" class="headerlink" title="二 隐式转换"></a>二 隐式转换</h2><h4 id="1-对象和布尔值比较"><a href="#1-对象和布尔值比较" class="headerlink" title="1. 对象和布尔值比较"></a>1. 对象和布尔值比较</h4><p>对象和布尔值进行比较时，对象先转换为字符串，然后再转换为数字，布尔值直接转换为数字</p><pre><code class="bash">[] == true;  //false  []转换为字符串&#39;&#39;,然后转换为数字0,true转换为数字1，所以为false</code></pre><h4 id="2-对象和字符串比较"><a href="#2-对象和字符串比较" class="headerlink" title="2. 对象和字符串比较"></a>2. 对象和字符串比较</h4><p>对象和字符串进行比较时，对象转换为字符串，然后两者进行比较。</p><pre><code class="bash">[1,2,3] == &#39;1,2,3&#39;; // true  [1,2,3]转化为&#39;1,2,3&#39;，然后和&#39;1,2,3&#39;， so结果为true;</code></pre><h4 id="3-对象和数字比较"><a href="#3-对象和数字比较" class="headerlink" title="3. 对象和数字比较"></a>3. 对象和数字比较</h4><p>对象和数字进行比较时，对象先转换为字符串，然后转换为数字，再和数字进行比较。</p><pre><code class="bash">[1] == 1;  // true  `对象先转换为字符串再转换为数字，二者再比较 [1] =&gt; &#39;1&#39; =&gt; 1 所以结果为true</code></pre><h4 id="4-字符串和数字比较"><a href="#4-字符串和数字比较" class="headerlink" title="4. 字符串和数字比较"></a>4. 字符串和数字比较</h4><p>字符串和数字进行比较时，字符串转换成数字，二者再比较。</p><pre><code class="bash">&#39;1&#39; == 1; // true</code></pre><h4 id="5-字符串和布尔值比较"><a href="#5-字符串和布尔值比较" class="headerlink" title="5. 字符串和布尔值比较"></a>5. 字符串和布尔值比较</h4><p>字符串和布尔值进行比较时，二者全部转换成数值再比较。</p><pre><code class="bash">&#39;1&#39; == true; // true </code></pre><h4 id="6-布尔值和数字比较"><a href="#6-布尔值和数字比较" class="headerlink" title="6. 布尔值和数字比较"></a>6. 布尔值和数字比较</h4><p>布尔值和数字进行比较时，布尔转换为数字，二者比较。</p><pre><code class="bash">true == 1; // true</code></pre><h2 id="三-数据类型相加问题"><a href="#三-数据类型相加问题" class="headerlink" title="三 数据类型相加问题"></a>三 数据类型相加问题</h2><h4 id="1-字符串拼接"><a href="#1-字符串拼接" class="headerlink" title="1.字符串拼接"></a>1.字符串拼接</h4><p>多个字符串之间可以使用+进行拼接，其拼接方式为 字符串+任何类型 = 拼接之后的新字符串。拼接前会把与字符串相加的任何类型转为字符串，在拼接成一个新的字符串。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/202203232104897.png" alt="img"></p><p>+号总结口诀：数值相加，字符相连</p><h4 id="2-布尔类型相加"><a href="#2-布尔类型相加" class="headerlink" title="2.布尔类型相加"></a>2.布尔类型相加</h4><p><img src="http://cdn.tangyuxian.com/PicGoImages/202203232104800.png"></p><h4 id="3-未定义类型undefined"><a href="#3-未定义类型undefined" class="headerlink" title="3.未定义类型undefined"></a>3.未定义类型undefined</h4><p><img src="http://cdn.tangyuxian.com/PicGoImages/202203232104905.png" alt="img"></p><h4 id="4-null空值"><a href="#4-null空值" class="headerlink" title="4.null空值"></a>4.null空值</h4><p><img src="http://cdn.tangyuxian.com/PicGoImages/202203232104173.png" alt="img"></p><h2 id="四-主动类型转换"><a href="#四-主动类型转换" class="headerlink" title="四 主动类型转换"></a>四 主动类型转换</h2><p>除了上述的隐式转换和自动类型转换,我们可通过函数转换</p><p><code>Number()</code> 转换数值，<code>String()</code> 转换字符串，<code>Boolean()</code> 转换布尔值。</p><p>可通过<a href="https://www.w3school.com.cn/js/js_type_conversion.asp">w3school</a>在线转换亲自试试</p><h2 id="五-类型判断"><a href="#五-类型判断" class="headerlink" title="五 类型判断"></a>五 类型判断</h2><h4 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1.typeof"></a>1.typeof</h4><p>用途:用于检测数据类型,可检测出<code>string，number，boolean，symbol，bigint，undefined，object，function</code>类型</p><p>用法:<code>typeof [value]</code> (表达式运算符)或<code>typeof([value])</code>(变量运算符)</p><p>弊端:<code>typeof null</code>结果是<code>object</code>,null是一个只有一个值的特殊类型。表示一个空对象引用.浏览器默认把前三位是000的当做对象，null的二进制编码前三位是000，被误当做对象判断；<code>Object.prototype.__proto__==null;``Object</code>类的原型对象的原型指向<code>null</code></p><h4 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2.instanceof"></a>2.instanceof</h4><p>用途:判断一个对象的引用类型,也可以说这个实例是否属于这个类</p><p>用法:<code>[ example ] instanceof [ class ]</code> </p><h4 id="3-constructor"><a href="#3-constructor" class="headerlink" title="3.constructor"></a>3.constructor</h4><p>用途:检测实例和类的关系，从而检测数据类型，实例的原型<code>_proto_</code>与类的原型对象指向一样，类的原型对象上有constructor属性指向类本身；</p><p>用法:<code>[ example ].constructor === [ class ]</code></p><h4 id="4Object-prototype-toString-call"><a href="#4Object-prototype-toString-call" class="headerlink" title="4Object.prototype.toString.call"></a>4Object.prototype.toString.call</h4><p>用途:利用Object上的原形对象方法toString检测数据类型</p><p>用法:<code>Object.prototype.toString.call( [value] )</code></p><blockquote><p>参考文档:</p><p><a href="https://www.cnblogs.com/chenmeng0818/p/5954215.html">https://www.cnblogs.com/chenmeng0818/p/5954215.html</a></p><p><a href="https://blog.csdn.net/qq_46037481/article/details/109683219">https://blog.csdn.net/qq_46037481/article/details/109683219</a></p><p><a href="https://blog.csdn.net/zhangank/article/details/106792671">https://blog.csdn.net/zhangank/article/details/106792671</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UI库-elementPlus的虚拟树TreeV2使用技巧和避坑</title>
      <link href="/2022/03/12/%E5%89%8D%E7%AB%AF/UI%E5%BA%93/UI%E5%BA%93-elementPlus%E7%9A%84%E8%99%9A%E6%8B%9F%E6%A0%91TreeV2%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%92%8C%E9%81%BF%E5%9D%91/"/>
      <url>/2022/03/12/%E5%89%8D%E7%AB%AF/UI%E5%BA%93/UI%E5%BA%93-elementPlus%E7%9A%84%E8%99%9A%E6%8B%9F%E6%A0%91TreeV2%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%92%8C%E9%81%BF%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>总结elementPlus框架VUE3版中的虚拟树使用情况</p><span id="more"></span><h2 id="一-分析"><a href="#一-分析" class="headerlink" title="一 分析"></a>一 分析</h2><p>vue2时期PC端的UI库封神之作elementUI随着vue3的到来,发布了其续作elementPlus,并在2022年发布正式版本(根据更新日志的信息,全新的稳定版2.0.0于2022-02-07发布).<a href="https://element-plus.gitee.io/">点这里一键跳转至官方网站</a>.</p><p>在elementPlus中,为了解决普通树形组件无法容纳大量数据的情况,提供了一款新的组件,来解决大量数据用树形组件展示问题,该组件便是我们今天要介绍的主角,<a href="https://element-plus.gitee.io/zh-CN/component/tree-v2.html">Tree V2 虚拟化树形控件</a>.</p><p>一般来说,在处理大量数据的渲染问题,我们一般采用两种方式,要么”<a href="https://www.tangyuxian.com/2021/04/16/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-%E9%AB%98%E6%80%A7%E8%83%BD%E6%B8%B2%E6%9F%93%E5%8D%81%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE-%E6%97%B6%E9%97%B4%E5%88%86%E7%89%87/">时间分片</a>“,要么”虚拟列表”,虚拟树组件则采用<a href="https://www.tangyuxian.com/2021/04/16/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-%E9%AB%98%E6%80%A7%E8%83%BD%E6%B8%B2%E6%9F%93%E5%8D%81%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE-%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8/">“虚拟列表”</a>技术,避免一次性展示大量数据造成dom渲染过多最后导致浏览器崩溃问题.不过相对于普通的树组件,虚拟树组件虽然部分api相同,但是需要注意的是,虚拟树因为其”虚拟”的特性,要比普通树组件缺少一些功能,这些功能都主要与DOM操作有关.</p><p>在普通树组件中通过提供的<code>node-click</code>事件,可以获得当前树的真实dom节点信息:</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/202203121600563.png" alt="image-20220312154903653"></p><p>对比虚拟树组件</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/202203121600742.png" alt="image-20220312155120083"></p><p>缺少是否选中属性,是否半选状态,以及子组件真实node节点信息;</p><p>基于上述对比,如果在实际项目中,想要实现普通树组件向虚拟树做迁移,需要注意所有<strong>对dom节点操作的功能都将失效</strong>.</p><p>例:获取子节点全选的父节点信息,<a href="https://www.cnblogs.com/csji/p/13750545.html">其封装函数如下</a></p><pre><code class="javascript">getSimpleCheckedNodes(store) &#123;    const checkedNodes = [];    const traverse = function(node) &#123;        const childNodes = node.root ? node.root.childNodes : node.childNodes;        childNodes.forEach(child =&gt; &#123;            if (child.checked) &#123;                checkedNodes.push(child.data);            &#125;            if (child.indeterminate) &#123;                traverse(child);            &#125;        &#125;);    &#125;;    traverse(store)    return checkedNodes;&#125;....// 调用const tree = ref()getSimpleCheckedNodes(tree.value.store);// el-tree的ref是tree</code></pre><h2 id="二-总结"><a href="#二-总结" class="headerlink" title="二 总结"></a>二 总结</h2><p>以下是总结的关于虚拟树存在的问题及解决方法:</p><h4 id="1-获取子节点全选的父节点信息"><a href="#1-获取子节点全选的父节点信息" class="headerlink" title="1 获取子节点全选的父节点信息"></a>1 获取子节点全选的父节点信息</h4><pre><code class="javascript">const getSimpleCheckedNodes = (checkedNodes)=&gt;&#123;  const traverse = (list) =&gt; &#123;    list.forEach(item=&gt;&#123;      if(item.children &amp;&amp; item.children.length&gt;0)&#123;        item.children.forEach(childItem=&gt;&#123;          let checkedNodesIndex = checkedNodes.findIndex(e=&gt;e &amp;&amp; e.id == childItem.id)           if(checkedNodesIndex &gt;= 0)&#123;             Reflect.deleteProperty(checkedNodes,checkedNodesIndex)           &#125;        &#125;)        traverse(item.children)      &#125;    &#125;)  &#125;  traverse(checkedNodes)  return checkedNodes.filter(e=&gt;e);&#125;//调用const tree = ref()getSimpleCheckedNodes(tree.value.getCheckedNodes())</code></pre><p>实现思路是调用官方的api获取所有勾选项,再利用父级勾选状态必然父级下的子也是勾选,然后从所有勾选集合中排除子级</p><h4 id="2-只获取勾选子节点信息-不包含勾选的父级信息"><a href="#2-只获取勾选子节点信息-不包含勾选的父级信息" class="headerlink" title="2 只获取勾选子节点信息,不包含勾选的父级信息"></a>2 只获取勾选子节点信息,不包含勾选的父级信息</h4><pre><code class="javascript">const tree = ref()tree.value.getCheckedNodes(false) //默认是true,传入false则只获取子节点勾选集合</code></pre><h4 id="3-异步获取数据情况下default-checked-keys无效问题"><a href="#3-异步获取数据情况下default-checked-keys无效问题" class="headerlink" title="3 异步获取数据情况下default-checked-keys无效问题"></a>3 异步获取数据情况下default-checked-keys无效问题</h4><p>方法一:</p><p>利用<code>setCheckedKeys</code>方法为树组件动态设置勾选情况</p><p>方法二:</p><p>设置一个开关,并作用于树组件上,使用 <code>v-if</code> 进行控制,在确保数据和勾选项的数据都获取到后再将开关置于<code>true</code>,此方法同样适用于<code>default-expanded-keys</code>属性无效问题.因虚拟树在渲染前就需要提供默认的勾选和展开情况用于计算虚拟列表的高度</p><h4 id="4-default-expanded-keys默认展开异常"><a href="#4-default-expanded-keys默认展开异常" class="headerlink" title="4 default-expanded-keys默认展开异常"></a>4 default-expanded-keys默认展开异常</h4><p>为虚拟树组件设置默认展开节点发现如果设置最外层的父级节点可以展开,而只设置里面的子节点却发现无法展开.在普通树组件中,如果设置了子级节点,会自动展开子级节点之上的所有父级节点,但是在虚拟树组件却无法做到,目前想到的做法是利用递归方式,拿到当前需要展开的子组件上层的父组件,一层层递归至最外层,拿到所有需要展开的层级.可以静待官方完善该方法.</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fc-ssl.duitang.com%2Fuploads%2Fitem%2F201801%2F17%2F20180117134909_fyhrc.thumb.400_0.gif&refer=http%3A%2F%2Fc-ssl.duitang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1649665724&t=bac66ff8ada0cd9c5171ae0dbfc15fb9" alt="img"></p><p>目前踩坑这么多,帮助到各位欧尼酱的话,就给糖糖点个赞吧</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> elementPlus </tag>
            
            <tag> UI库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-vue3与vue2对比分析(下)</title>
      <link href="/2022/02/27/%E5%89%8D%E7%AB%AF/vue/vue-vue3%E4%B8%8Evue2%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90(%E4%B8%8B)/"/>
      <url>/2022/02/27/%E5%89%8D%E7%AB%AF/vue/vue-vue3%E4%B8%8Evue2%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90(%E4%B8%8B)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>从使用和原理两方面分析</p><span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h4 id="1-响应式原理"><a href="#1-响应式原理" class="headerlink" title="1 响应式原理"></a>1 响应式原理</h4><h6 id="VUE2根据数据类型来做不同处理，数组和对象类型当值变化时如何劫持。"><a href="#VUE2根据数据类型来做不同处理，数组和对象类型当值变化时如何劫持。" class="headerlink" title="VUE2根据数据类型来做不同处理，数组和对象类型当值变化时如何劫持。"></a>VUE2根据数据类型来做不同处理，数组和对象类型当值变化时如何劫持。</h6><ol><li>对象内部通过<code>defineReactive</code>方法，使用 <code>Object.defineProperty()</code> 监听数据属性的 get 来进行数据依赖收集，再通过 set 来完成数据更新的派发；</li><li>数组则通过重写数组方法来实现的。扩展它的 7 个变更⽅法(<code>pop,push,reverse,shift,sort,splice,unshift</code>)，通过监听这些方法可以做到依赖收集和派发更新；</li></ol><p>具体可参照本文分析:<a href="https://www.tangyuxian.com/2021/02/23/%E5%89%8D%E7%AB%AF/vue/vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/">vue-响应式原理</a></p><h6 id="VUE3使用Proxy-Proxy是ES6新特性，通过第2个参数handler拦截目标对象的行为"><a href="#VUE3使用Proxy-Proxy是ES6新特性，通过第2个参数handler拦截目标对象的行为" class="headerlink" title="VUE3使用Proxy,Proxy是ES6新特性，通过第2个参数handler拦截目标对象的行为"></a>VUE3使用Proxy,<code>Proxy</code>是ES6新特性，通过第2个参数<code>handler</code>拦截目标对象的行为</h6><p>Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）,但在兼容性上放弃了IE11浏览器,具体兼容性可参照 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">MDN</a>.</p><p>进一步了解Proxy可参照本文: <a href="https://www.tangyuxian.com/2021/05/27/%E5%89%8D%E7%AB%AF/es6/es6-Proxy%E7%9B%B8%E5%85%B3/">es6-Proxy相关</a></p><h4 id="2-打包优化tree-shaking"><a href="#2-打包优化tree-shaking" class="headerlink" title="2 打包优化tree-shaking"></a>2 打包优化tree-shaking</h4><p><code>Tree shaking</code>是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫 <code>Dead code elimination</code>,它是基于<code>ES6</code>模板语法（<code>import</code>与<code>exports</code>）,主要是借助<code>ES6</code>模块的静态编译思想，在编译时利用<code>ES6 Module</code>确定模块加载情况,以及它们的依赖关系,确认未被使用或引用的模块和变量,进而进行删除.</p><p>进一步了解tree-shaking: <a href="https://github.com/wuomzfx/tree-shaking-test">tree-shaking-test</a></p><h4 id="3-静态标记PatchFlag"><a href="#3-静态标记PatchFlag" class="headerlink" title="3 静态标记PatchFlag"></a>3 静态标记PatchFlag</h4><p>在Vue3.0中，模版编译时，编译器会在动态标签末尾加上 <code>/* TEXT*/</code> PatchFlag。也就是在生成VNode的时候，同时打上标记，在这个基础上再进行核心的diff算法,并且 PatchFlag 会标识动态的属性类型有哪些;而Vue2.x的diff算法，会不断地递归调用 patchVNode，不断堆叠而成的几毫秒，最终就会造成 VNode 更新缓慢</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/202203012024549.png" alt="img"></p><p>进一步了解diff算法:<a href="https://www.tangyuxian.com/2021/07/14/%E5%89%8D%E7%AB%AF/vue/vue-diff%E7%AE%97%E6%B3%95/">vue-diff算法</a></p><h4 id="4-静态提升hoistStatic"><a href="#4-静态提升hoistStatic" class="headerlink" title="4 静态提升hoistStatic"></a>4 静态提升hoistStatic</h4><p>在Vue中无论元素是否参与更新，每次都会重新创建，然后再渲染。如下图所示，每次都会createVNode;在Vue3中使用了静态提升后，对于不参与更新的元素，只会被创建一次，并打上打上 <code>/*#__PURE__*/</code> 标记在渲染时直接复用即可</p><pre><code class="javascript">const &#123; createVNode: _createVNode, createStaticVNode: _createStaticVNode, openBlock: _openBlock, createBlock: _createBlock &#125; = Vueconst _hoisted_1 = /*#__PURE__*/_createStaticVNode(&quot;&lt;div&gt;&lt;span class=\&quot;foo\&quot;&gt;&lt;/span&gt;&lt;span class=\&quot;foo\&quot;&gt;&lt;/span&gt;&lt;span class=\&quot;foo\&quot;&gt;&lt;/span&gt;&lt;span class=\&quot;foo\&quot;&gt;&lt;/span&gt;&lt;span class=\&quot;foo\&quot;&gt;&lt;/span&gt;&lt;/div&gt;&quot;, 1)return function render(_ctx, _cache) &#123;  return (_openBlock(), _createBlock(&quot;div&quot;, null, [    _hoisted_1  ]))&#125;</code></pre><h4 id="5-事件缓存cacheHandler"><a href="#5-事件缓存cacheHandler" class="headerlink" title="5 事件缓存cacheHandler"></a>5 事件缓存cacheHandler</h4><p><img src="http://cdn.tangyuxian.com/PicGoImages/202203022038548.png" alt="img"></p><p>在vue3中,cacheHandler在首次渲染后缓存事件,并打上<code>/*PROIPS*/</code>标记</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> vue </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-vue3与vue2对比分析(上)</title>
      <link href="/2022/02/24/%E5%89%8D%E7%AB%AF/vue/vue-vue3%E4%B8%8Evue2%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90(%E4%B8%8A)/"/>
      <url>/2022/02/24/%E5%89%8D%E7%AB%AF/vue/vue-vue3%E4%B8%8Evue2%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90(%E4%B8%8A)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>从使用和原理两方面分析</p><span id="more"></span><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h4 id="1-vue2-选项式API与vue3组合式API"><a href="#1-vue2-选项式API与vue3组合式API" class="headerlink" title="1 vue2 选项式API与vue3组合式API"></a>1 vue2 选项式API与vue3组合式API</h4><p><img src="http://cdn.tangyuxian.com/PicGoImages/202202242015382.png" alt="img"></p><p>​    官方文档:<a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html#%E5%9C%A8-setup-%E5%86%85%E6%B3%A8%E5%86%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90">什么是组合式API</a></p><p>​    为什么选择组合式API?通过上图可以看出,随着项目的迭代更新,必然会存在如下问题:</p><ul><li>代码横跳,响应式数据与方法割裂开,需要反复横跳代码维护,可读性越来越差</li><li>采用Mixin混入后,属性和函数有冲突的可能性,数据来源不明,多Mixin引入将带来灾难性的维护难题</li><li>对强类型约束Typescirpt的支持问题,<a href="https://cn.vuejs.org/v2/guide/typescript.html">参照官方文档</a></li></ul><p>组合式API恰恰解决了上述的痛点,逻辑可以整合在一起,使得代码编写的更加规整,而逻辑抽离部分可以采用hooks方式,<a href="https://zhuanlan.zhihu.com/p/394159778">具体可参照本文</a>.</p><h4 id="2-生命周期变化"><a href="#2-生命周期变化" class="headerlink" title="2 生命周期变化"></a>2 生命周期变化</h4><h6 id="vue2生命周期图"><a href="#vue2生命周期图" class="headerlink" title="vue2生命周期图"></a>vue2生命周期图</h6><p><img src="http://cdn.tangyuxian.com/PicGoImages/202202242117395.jpeg" alt="img"></p><h6 id="vue3生命周期图"><a href="#vue3生命周期图" class="headerlink" title="vue3生命周期图"></a>vue3生命周期图</h6><p><img src="http://cdn.tangyuxian.com/PicGoImages/202202242120711.png" alt="img"></p><p>vue2和vue3生命周期对比图</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/202202242122974.png" alt="img"></p><p>官方文档:<a href="https://v3.cn.vuejs.org/api/composition-api.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90">生命周期钩子</a></p><h4 id="3-多根节点"><a href="#3-多根节点" class="headerlink" title="3 多根节点"></a>3 多根节点</h4><pre><code class="html">&lt;!-- Layout.vue --&gt;&lt;template&gt;  &lt;header&gt;...&lt;/header&gt;  &lt;main&gt;...&lt;/main&gt;  &lt;footer&gt;...&lt;/footer&gt;&lt;/template&gt;</code></pre><h4 id="4-传送门Teleport"><a href="#4-传送门Teleport" class="headerlink" title="4 传送门Teleport"></a>4 传送门Teleport</h4><p>类似<code>toast</code>,<code>dialog</code>等元素,使用模板中的值,但是希望挂载到最外层或者其它节点下而不是嵌套在组件内.</p><pre><code class="html">  &lt;button @click=&quot;showToast&quot;&gt;showToast&lt;/button&gt;  &lt;!-- to 目标位置 --&gt;  &lt;teleport to=&quot;body&quot;&gt;    &lt;div v-if=&quot;isShow&quot; class=&quot;toast&quot;&gt;      &lt;div class=&quot;toast-text&quot;&gt;我是一个 Toast 文案&lt;/div&gt;    &lt;/div&gt;  &lt;/teleport&gt;</code></pre><p>官方文档:<a href="https://v3.cn.vuejs.org/guide/teleport.html#%E4%B8%8E-vue-components-%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8">Teleport</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> vue </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器-在网页中使用自定义截图功能</title>
      <link href="/2022/02/09/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%88%AA%E5%9B%BE%E5%8A%9F%E8%83%BD/"/>
      <url>/2022/02/09/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%88%AA%E5%9B%BE%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>总结目前网页使用截图功能的方法</p><span id="more"></span><p>总结一下目前了解到的网页截图功能实现</p><h2 id="一-dom-to-image"><a href="#一-dom-to-image" class="headerlink" title="一 dom-to-image"></a>一 dom-to-image</h2><h4 id="1-npm地址"><a href="#1-npm地址" class="headerlink" title="1 npm地址:"></a>1 npm地址:</h4><p><a href="https://www.npmjs.com/package/dom-to-image">https://www.npmjs.com/package/dom-to-image</a></p><h4 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2 介绍:"></a>2 介绍:</h4><p>dom-to-image 是一个JS类库，它可以将任意DOM节点转换成 SVG/PNG/JPEG 格式的图像。它基于 domvas by Paul Bakaus 进行重写，修复了一些一至错误，并添加了部分功能（如web字体和图像支持）。</p><h4 id="3-基本原理"><a href="#3-基本原理" class="headerlink" title="3 基本原理:"></a>3 基本原理:</h4><p>SVG的foreignObject标签可以包裹任意的html内容</p><ol><li><p>递归地拷贝原始dom节点和后代节点；</p></li><li><p>把原始节点以及后代节点的样式递归的应用到对应的拷贝后的节点和后代节点上；</p></li><li><p>字体处理；</p></li><li><p>图片处理；</p></li><li><p>序列化拷贝后的节点，把它插入到foreignObject里面，然后组成一个svg，然后生成一个data URL；</p></li><li><p>如果想得到PNG内容或原始像素值，可以先使用data URL创建一个图片，使用一个离屏canvas渲染这张图片，然后从canvas中获取想要的数据。</p></li></ol><h4 id="4-弊端"><a href="#4-弊端" class="headerlink" title="4 弊端:"></a>4 弊端:</h4><p>​    1.长时间未维护更新,最近更新是在4年前</p><p>​    2.存在外部资源无法正确加载情况</p><h2 id="二-html2canvas"><a href="#二-html2canvas" class="headerlink" title="二 html2canvas"></a>二 html2canvas</h2><h4 id="1-npm地址-1"><a href="#1-npm地址-1" class="headerlink" title="1 npm地址:"></a>1 npm地址:</h4><p>​    <a href="https://www.npmjs.com/package/html2canvas">https://www.npmjs.com/package/html2canvas</a></p><h4 id="2-官网及文档"><a href="#2-官网及文档" class="headerlink" title="2 官网及文档:"></a>2 官网及文档:</h4><p>​    <a href="http://html2canvas.hertzen.com/">http://html2canvas.hertzen.com/</a>    </p><h4 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3 实现原理"></a>3 实现原理</h4><ol><li>递归取出目标模版的所有DOM节点，填充到一个<code>rederList</code>，并附加是否为顶层元素/包含内容的容器 等信息    </li><li>通过<code>z-index</code> <code>postion</code> <code>float</code>等css属性和元素的层级信息将<code>rederList</code>排序，计算出一个canvas的renderQueue</li><li>遍历renderQueue，将css样式转为<code>setFillStyle</code>可识别的参数，依据nodeType调用相对应canvas方法，如文本则调用<code>fillText</code>，图片<code>drawImage</code>，设置背景色的div调用<code>fillRect</code>等 </li><li>将画好的canvas填充进页面</li></ol><h4 id="4-部分问题处理"><a href="#4-部分问题处理" class="headerlink" title="4 部分问题处理"></a>4 部分问题处理</h4><ol><li><p>跨域方面: 配置<code>allowTaint: false</code></p></li><li><p>截图锯齿:根据设备像素比进行缩放 <code>const scale = window.devicePixelRatio;</code></p></li><li><p>对 css3 支持不好:不支持部分css3样式,如<code>background-blend-mode、background-clip: text、box-decoration-break、repeating-linear-gradient()、font-variant-ligatures、mix-blend-mode、writing-mode、writing-mode、border-image、box-shadow、filter、zoom、transform</code>等</p><p>但是好在该工具目前仍活跃更新,从最初不支持跨域到后来通过配置来解决跨域问题,是非常知名的截图库</p></li></ol><h2 id="三-js-web-screen-shot"><a href="#三-js-web-screen-shot" class="headerlink" title="三 js-web-screen-shot"></a>三 js-web-screen-shot</h2><h4 id="1-npm地址-2"><a href="#1-npm地址-2" class="headerlink" title="1 npm地址:"></a>1 npm地址:</h4><p><a href="https://www.npmjs.com/package/js-web-screen-shot">https://www.npmjs.com/package/js-web-screen-shot</a></p><h4 id="2-介绍-1"><a href="#2-介绍-1" class="headerlink" title="2 介绍:"></a>2 介绍:</h4><p>一款带有工具条的功能十分强大的网页截图工具,目前仍在积极维护中,经历了近三十个版本迭代,最初版本于一年前发布,因功能完整,维护频繁,使用时需多留意更新版本,截取浏览器界面外部留意开启<a href="https://webrtc.org.cn/">webRTC</a>支持</p><h4 id="3-原理分析"><a href="#3-原理分析" class="headerlink" title="3 原理分析:"></a>3 原理分析:</h4><p><a href="https://juejin.cn/post/6924368956950052877">https://juejin.cn/post/6924368956950052877</a></p><h4 id="4-其它"><a href="#4-其它" class="headerlink" title="4 其它:"></a>4 其它:</h4><p>该库有对应的vue3版本可选择,如果在实际项目中有复杂的截图需求,并且项目是使用vue3开发的,可以使用该库:<a href="https://www.npmjs.com/package/vue-web-screen-shot">vue-web-screen-shot</a></p><blockquote><p>参考文档:<br><a href="https://juejin.cn/post/6844903465756393486">https://juejin.cn/post/6844903465756393486</a><br><a href="https://segmentfault.com/a/1190000037673677">https://segmentfault.com/a/1190000037673677</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts-记录自己用ts封装一个最萌最轻量的类库</title>
      <link href="/2021/09/25/%E5%89%8D%E7%AB%AF/TypeScript/ts-%E8%AE%B0%E5%BD%95%E8%87%AA%E5%B7%B1%E7%94%A8ts%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E6%9C%80%E8%90%8C%E6%9C%80%E8%BD%BB%E9%87%8F%E7%9A%84%E7%B1%BB%E5%BA%93/"/>
      <url>/2021/09/25/%E5%89%8D%E7%AB%AF/TypeScript/ts-%E8%AE%B0%E5%BD%95%E8%87%AA%E5%B7%B1%E7%94%A8ts%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E6%9C%80%E8%90%8C%E6%9C%80%E8%BD%BB%E9%87%8F%E7%9A%84%E7%B1%BB%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>糖糖的tangyuxian-js-socket</p><span id="more"></span><p>某天项目要用到websocket,糖糖就在想又要自己去处理断线重新和发心跳,有没有现成的,轻量化的类库呢,找了很多都没有合适的,好波,那就自己亲自动手写一个吧</p><p>npm地址:<a href="https://www.npmjs.com/package/tangyuxian-js-socket">tangyuxian-js-socket</a></p><p>github仓库地址:<a href="https://github.com/tangyuxian/tangyuxian-js-socket">tangyuxian-js-socket</a></p><p>注意升级成ts后会有<strong>小蓝标</strong>哦</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/202109251759451.png" alt="image-20210925175939243"></p><p><img src="http://cdn.tangyuxian.com/PicGoImages/202109251748028.jpeg" alt="img"></p><h2 id="一-创建并拉取仓库"><a href="#一-创建并拉取仓库" class="headerlink" title="一 创建并拉取仓库"></a>一 创建并拉取仓库</h2><pre><code>git clone https://github.com/tangyuxian/tangyuxian-js-socket.git</code></pre><h2 id="二-初始化NPM"><a href="#二-初始化NPM" class="headerlink" title="二 初始化NPM"></a>二 初始化NPM</h2><pre><code>npm init</code></pre><h2 id="三-这样配置项目并安装依赖"><a href="#三-这样配置项目并安装依赖" class="headerlink" title="三 这样配置项目并安装依赖"></a>三 这样配置项目并安装依赖</h2><pre><code class="json">//package.json&#123;  &quot;name&quot;: &quot;tangyuxian-js-socket&quot;, //项目名  &quot;version&quot;: &quot;2.0.0&quot;, //版本号  &quot;description&quot;: &quot;Encapsulating socket class for TS&quot;, //描述  &quot;keywords&quot;: [    &quot;websocket&quot;,    &quot;es6&quot;,    &quot;socket&quot;,    &quot;typescirpt&quot;  ], //标签  &quot;author&quot;: &#123;    &quot;name&quot;: &quot;tangyuxian&quot;,     &quot;email&quot;: &quot;tangyuxian@vip.qq.com&quot;,    &quot;url&quot;: &quot;http://www.tangyuxian.com&quot;  &#125;, //作者联系方式  &quot;repository&quot;: &#123;    &quot;type&quot;: &quot;git&quot;,    &quot;url&quot;: &quot;git+https://github.com/tangyuxian/tangyuxian-js-socket.git&quot;  &#125;, //项目地址  &quot;main&quot;: &quot;lib/Socket.js&quot;, //主程序入口  &quot;publishConfig&quot;: &#123;    &quot;access&quot;: &quot;public&quot;  &#125;,  &quot;engines&quot;: &#123;    &quot;node&quot;: &quot;&gt; 8&quot;  &#125;,  &quot;files&quot;: [    &quot;dist&quot;,    &quot;lib&quot;,    &quot;@types&quot;  ], //涉及文件位置  &quot;unpkg&quot;: &quot;./dist/index.min.js&quot;, //upkg路径  &quot;types&quot;: &quot;@types/index.d.ts&quot;,  &quot;license&quot;: &quot;MIT&quot;, //开源声明  &quot;bugs&quot;: &#123;    &quot;url&quot;: &quot;https://github.com/tangyuxian/tangyuxian-js-socket/issues&quot;  &#125;, //bug收集地址  &quot;homepage&quot;: &quot;https://github.com/tangyuxian/tangyuxian-js-socket#readme&quot;, //介绍文档主地址  &quot;scripts&quot;: &#123;    &quot;bootstrap&quot;: &quot;yarn || npm i&quot;,    &quot;build&quot;: &quot;rollup -c rollup.config.js&quot;,    &quot;test&quot;: &quot;jest&quot;,    &quot;release&quot;: &quot;standard-version&quot;  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;@babel/plugin-transform-modules-commonjs&quot;: &quot;^7.15.4&quot;,    &quot;@babel/preset-env&quot;: &quot;^7.15.0&quot;,    &quot;@rollup/plugin-babel&quot;: &quot;^5.3.0&quot;,    &quot;@types/jest&quot;: &quot;^27.0.0&quot;,     &quot;@types/jsdom&quot;: &quot;^16.2.13&quot;,     &quot;@typescript-eslint/eslint-plugin&quot;: &quot;^4.29.1&quot;,    &quot;@typescript-eslint/parser&quot;: &quot;^4.29.1&quot;,    &quot;eslint&quot;: &quot;^7.32.0&quot;,    &quot;eslint-config-prettier&quot;: &quot;^8.3.0&quot;,    &quot;eslint-plugin-prettier&quot;: &quot;^3.4.0&quot;,    &quot;jest&quot;: &quot;^27.0.6&quot;,//单元测试工具    &quot;prettier&quot;: &quot;^2.3.2&quot;,    &quot;rollup&quot;: &quot;^2.56.2&quot;,    &quot;rollup-plugin-terser&quot;: &quot;^7.0.2&quot;,    &quot;rollup-plugin-typescript2&quot;: &quot;^0.30.0&quot;,    &quot;standard-version&quot;: &quot;^9.3.1&quot;,    &quot;ts-jest&quot;: &quot;^27.0.4&quot;,    &quot;tslib&quot;: &quot;^2.3.1&quot;,    &quot;typescript&quot;: &quot;^4.3.5&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;jsdom&quot;: &quot;^17.0.0&quot;//模拟dom操作库  &#125;&#125;</code></pre><h2 id="四-编写代码"><a href="#四-编写代码" class="headerlink" title="四 编写代码"></a>四 编写代码</h2><p>一开始糖糖是用js写的,后来使用ts进行了重写</p><p>原版:</p><pre><code class="javascript">class Socket &#123;  constructor(socketUrl, option) &#123;    this.socketUrl = socketUrl    this.option = &#123;      onOpenAutoSendMsg:&quot;&quot;,      heartTime: 5000, // 心跳时间间隔      heartMsg: &#39;ping&#39;, // 心跳信息,默认为&#39;ping&#39;      isReconnect: true, // 是否自动重连      reconnectTime: 5000, // 重连时间间隔      reconnectCount: -1, // 重连次数 -1 则不限制      openCallback: null, // 连接成功的回调      closeCallback: null, // 关闭的回调      messageCallback: null, // 消息的回调      errorCallback: null, // 错误的回调      debug: false,  //是否打开debug模式      ...option,    &#125;    this.websocket = null    this.sendPingInterval = null  //心跳定时器    this.reconnectInterval = null  //重连定时器    this.activeLink = true  //socket对象是否可用    this.reconnectNum = 0 //重连次数限制    this.init()  &#125;  /**   * 初始化   */  init() &#123;    if (!(&#39;WebSocket&#39; in window)) &#123;      throw new Error(&#39;当前浏览器不支持&#39;)    &#125;    if (!this.socketUrl) &#123;      throw new Error(&#39;请配置连接地址&#39;)    &#125;    Reflect.deleteProperty(this, this.websocket)    this.websocket = new WebSocket(this.socketUrl)    this.websocketOnOpen()    this.websocketOnMessage()    this.websocketOnError()    this.websocketOnClose()  &#125;  /**   * 连接成功   */  websocketOnOpen(callback) &#123;    this.websocket.onopen = (event) =&gt; &#123;      if (this.option.debug) console.log(&#39;%c websocket链接成功&#39;, &#39;color:green&#39;)      this.sendPing(this.option.heartTime, this.option.heartMsg);      if(this.option.onOpenAutoSendMsg)&#123;        this.send(this.option.onOpenAutoSendMsg)      &#125;      if (typeof callback === &#39;function&#39;) &#123;        callback(event)      &#125; else &#123;        (typeof this.option.openCallback === &#39;function&#39;) &amp;&amp; this.option.openCallback(event)      &#125;    &#125;  &#125;  /**   * 发送数据   * @param message   */  send (message)&#123;    if (this.websocket.readyState !== this.websocket.OPEN) &#123;      new Error(&#39;没有连接到服务器，无法发送消息&#39;)      return    &#125;    this.websocket.send(message)  &#125;  /**   * 触发接收消息事件   * @param callback   */  websocketOnMessage(callback) &#123;    this.websocket.onmessage = (event) =&gt; &#123;      // 收到任何消息，重新开始倒计时心跳检测      if (typeof callback === &#39;function&#39;) &#123;        callback(event.data)      &#125; else &#123;        (typeof this.option.messageCallback === &#39;function&#39;) &amp;&amp; this.option.messageCallback(event.data)      &#125;    &#125;  &#125;  /**   * 连接错误   * @param callback   */  websocketOnError(callback) &#123;    this.websocket.onerror = (event) =&gt; &#123;      if (this.option.debug) console.error(&#39;连接发生错误&#39;, event)      if (typeof callback === &#39;function&#39;) &#123;        callback(event)      &#125; else &#123;        (typeof this.option.errorCallback === &#39;function&#39;) &amp;&amp; this.option.errorCallback(event)      &#125;    &#125;  &#125;  /**   * 连接关闭   */  websocketOnClose(e) &#123;    this.websocket.onclose = (event) =&gt; &#123;      if (this.option.debug) console.warn(&#39;socket连接关闭,关于原因:&#39;, event)      clearInterval(this.sendPingInterval)      clearInterval(this.reconnectInterval);      if (this.activeLink &amp;&amp; this.option.isReconnect) &#123;        this.onReconnect()      &#125; else &#123;        this.activeLink = false;        if (this.option.debug) console.log(&#39;%c websocket链接完全关闭&#39;, &#39;color:green&#39;)      &#125;      if (typeof callback === &#39;function&#39;) &#123;        callback(event)      &#125; else &#123;        (typeof this.option.closeCallback === &#39;function&#39;) &amp;&amp; this.option.closeCallback(event)      &#125;    &#125;  &#125;  /**   * 连接事件   */  onReconnect() &#123;    if (this.option.debug) console.warn(`非正常关闭,$&#123;this.option.reconnectTime&#125;毫秒后触发重连事件`)    if (this.option.reconnectCount === -1 || this.option.reconnectCount &gt; this.reconnectNum) &#123;      this.reconnectInterval = setTimeout(() =&gt; &#123;        this.reconnectNum++        if (this.option.debug) console.warn(`正在准备第$&#123;this.reconnectNum&#125;次重连`)        this.init()      &#125;, this.option.reconnectTime)    &#125; else &#123;      this.activeLink = false;      if (this.option.debug) console.warn(`已重连$&#123;this.reconnectNum&#125;次仍然没有响应,取消重连`)      clearInterval(this.reconnectInterval);    &#125;  &#125;  /**   * 移除socket并关闭   */  removeSocket() &#123;    this.activeLink = false    this.websocket.close(1000)  &#125;  /**   * 心跳机制   * @param time   * @param ping   */  sendPing (time = 5000, ping = &#39;ping&#39;)&#123;    clearInterval(this.sendPingInterval);    if (time === -1) return    this.send(ping)    this.sendPingInterval = setInterval(() =&gt; &#123;      this.send(ping)    &#125;, time)  &#125;  /**   * 返回websocket实例   * @returns &#123;null&#125;   */  getWebsocket() &#123;    return this.websocket  &#125;  /**   * 查看连接状态   */  getActiveLink() &#123;    return this.activeLink  &#125;&#125;export default Socket</code></pre><p>其实改成<strong>typescript</strong>也非常简单,注意增加了强类型约束,方便类型推导</p><pre><code class="typescript">class Socket &#123;  private socketUrl: string;  private option: &#123;    heartTime: number;    errorCallback: Function | null;    openCallback: Function | null;    debug: boolean;    reconnectTime: number;    reconnectCount: number;    closeCallback: Function | null;    heartMsg: string;    onOpenAutoSendMsg: string;    isReconnect: boolean;    messageCallback: Function | null;  &#125;;  private websocket: WebSocket | null;  private sendPingInterval: any;  private reconnectInterval: any;  private activeLink: boolean;  private reconnectNum: number = 0;  constructor(socketUrl: string, option: object) &#123;    this.socketUrl = socketUrl;    this.option = &#123;      onOpenAutoSendMsg: &quot;&quot;,      heartTime: 5000, // 心跳时间间隔      heartMsg: &quot;ping&quot;, // 心跳信息,默认为&#39;ping&#39;      isReconnect: true, // 是否自动重连      reconnectTime: 5000, // 重连时间间隔      reconnectCount: -1, // 重连次数 -1 则不限制      openCallback: null, // 连接成功的回调      closeCallback: null, // 关闭的回调      messageCallback: null, // 消息的回调      errorCallback: null, // 错误的回调      debug: false,  //是否打开debug模式      ...option    &#125;;    this.websocket = null;    this.sendPingInterval = null;  //心跳定时器    this.reconnectInterval = null;  //重连定时器    this.activeLink = true;  //socket对象是否可用    this.reconnectNum = 0; //重连次数限制    this.init();  &#125;  /**   * 初始化   */  init() &#123;    if (!(&quot;WebSocket&quot; in window)) &#123;      throw new Error(&quot;当前浏览器不支持&quot;);    &#125;    if (!this.socketUrl) &#123;      throw new Error(&quot;请配置连接地址&quot;);    &#125;    this.websocket = null;    this.websocket = new window.WebSocket(this.socketUrl);    this.websocketOnOpen(null);    this.websocketOnMessage(null);    this.websocketOnError(null);    this.websocketOnClose(null);  &#125;  /**   * 连接成功   */  websocketOnOpen(callback: Function | null) &#123;    if(!(this.websocket instanceof window.WebSocket)) return;    this.websocket.onopen = (event) =&gt; &#123;      if (this.option.debug) console.log(&quot;%c websocket链接成功&quot;, &quot;color:green&quot;);      this.sendPing(this.option.heartTime, this.option.heartMsg);      if (this.option.onOpenAutoSendMsg) &#123;        this.send(this.option.onOpenAutoSendMsg);      &#125;      if (typeof callback === &quot;function&quot;) &#123;        callback(event);      &#125; else &#123;        (typeof this.option.openCallback === &quot;function&quot;) &amp;&amp; this.option.openCallback(event);      &#125;    &#125;;  &#125;  /**   * 发送数据   * @param message   */  send(message: any) &#123;    if(!(this.websocket instanceof window.WebSocket)) return;    if (this.websocket.readyState !== this.websocket.OPEN) &#123;      new Error(&quot;没有连接到服务器，无法发送消息&quot;);      return;    &#125;    this.websocket.send(message);  &#125;  /**   * 触发接收消息事件   * @param callback   */  websocketOnMessage(callback: Function | null) &#123;    if(!(this.websocket instanceof window.WebSocket)) return;    this.websocket.onmessage = (event) =&gt; &#123;      // 收到任何消息，重新开始倒计时心跳检测      if (typeof callback === &quot;function&quot;) &#123;        callback(event.data);      &#125; else &#123;        (typeof this.option.messageCallback === &quot;function&quot;) &amp;&amp; this.option.messageCallback(event.data);      &#125;    &#125;;  &#125;  /**   * 连接错误   * @param callback   */  websocketOnError(callback: Function | null) &#123;    if(!(this.websocket instanceof window.WebSocket)) return;    this.websocket.onerror = (event) =&gt; &#123;      if (this.option.debug) console.error(&quot;连接发生错误&quot;, event);      if (typeof callback === &quot;function&quot;) &#123;        callback(event);      &#125; else &#123;        (typeof this.option.errorCallback === &quot;function&quot;) &amp;&amp; this.option.errorCallback(event);      &#125;    &#125;;  &#125;  /**   * 连接关闭   */  websocketOnClose(callback: Function | null) &#123;    if(!(this.websocket instanceof window.WebSocket)) return;    this.websocket.onclose = (event) =&gt; &#123;      if (this.option.debug) console.warn(&quot;socket连接关闭,关于原因:&quot;, event);      clearInterval(this.sendPingInterval);      clearInterval(this.reconnectInterval);      if (this.activeLink &amp;&amp; this.option.isReconnect) &#123;        this.onReconnect();      &#125; else &#123;        this.activeLink = false;        if (this.option.debug) console.log(&quot;%c websocket链接完全关闭&quot;, &quot;color:green&quot;);      &#125;      if (typeof callback === &quot;function&quot;) &#123;        callback(event);      &#125; else &#123;        (typeof this.option.closeCallback === &quot;function&quot;) &amp;&amp; this.option.closeCallback(event);      &#125;    &#125;;  &#125;  /**   * 连接事件   */  onReconnect() &#123;    if (this.option.debug) console.warn(`非正常关闭,$&#123;this.option.reconnectTime&#125;毫秒后触发重连事件`);    if (this.option.reconnectCount === -1 || this.option.reconnectCount &gt; this.reconnectNum) &#123;      this.reconnectInterval = setTimeout(() =&gt; &#123;        this.reconnectNum++;        if (this.option.debug) console.warn(`正在准备第$&#123;this.reconnectNum&#125;次重连`);        this.init();      &#125;, this.option.reconnectTime);    &#125; else &#123;      this.activeLink = false;      if (this.option.debug) console.warn(`已重连$&#123;this.reconnectNum&#125;次仍然没有响应,取消重连`);      clearInterval(this.reconnectInterval);    &#125;  &#125;  /**   * 移除socket并关闭   */  removeSocket() &#123;    this.activeLink = false;    if(!(this.websocket instanceof window.WebSocket)) return;    this.websocket.close(1000);  &#125;  /**   * 心跳机制   * @param time   * @param ping   */  sendPing(time = 5000, ping = &quot;ping&quot;) &#123;    clearInterval(this.sendPingInterval);    if (time === -1) return;    this.send(ping);    this.sendPingInterval = setInterval(() =&gt; &#123;      this.send(ping);    &#125;, time);  &#125;  /**   * 返回websocket实例   * @returns &#123;null&#125;   */  getWebsocket() &#123;    return this.websocket;  &#125;  /**   * 查看连接状态   */  getActiveLink() &#123;    return this.activeLink;  &#125;&#125;export default Socket;</code></pre><h2 id="五-打包"><a href="#五-打包" class="headerlink" title="五 打包"></a>五 打包</h2><p>在rollup.config.js配置两种打包方式</p><pre><code class="javascript">import typescript from &#39;rollup-plugin-typescript2&#39;import babel from &#39;@rollup/plugin-babel&#39;import &#123; terser as uglify &#125; from &#39;rollup-plugin-terser&#39;import path from &#39;path&#39;/** * @type &#123;import(&#39;rollup&#39;).RollupOptions[]&#125; */const config = [    //打包成js文件,可通过npm安装使用  &#123;    input: path.resolve(&#39;./src/main.ts&#39;),    cache: true,    output: [      &#123;        // file: path.resolve(&#39;./lib/main.js&#39;),        file: path.resolve(&#39;./lib/Socket.js&#39;),        format: &#39;es&#39;      &#125;    ],    plugins: [      typescript(&#123;        tsconfig: path.resolve(&#39;./tsconfig.json&#39;)      &#125;),      babel(&#123;        extensions: [&#39;.ts&#39;]      &#125;)    ]  &#125;,    //通过umd形式打包,可打包成压缩版,通过script标签直接引入使用,并将类注册到全局  &#123;    input: path.resolve(&#39;./src/main.ts&#39;),    output: &#123;      file: path.resolve(&#39;./dist/index.min.js&#39;),      format: &#39;umd&#39;,      name: &#39;Socket&#39;    &#125;,    plugins: [      typescript(&#123;        tsconfig: path.resolve(&#39;./tsconfig.json&#39;)      &#125;),      babel(&#123;        babelrc: false,        presets: [          [            &#39;@babel/env&#39;,            &#123;              useBuiltIns: &#39;usage&#39;,              targets: &#123;                node: 8,                browsers: [&#39;ie &gt; 8&#39;]              &#125;            &#125;          ]        ],        extensions: [&#39;.ts&#39;]      &#125;),      uglify()    ]  &#125;]export default config</code></pre><h2 id="六-编写测试类"><a href="#六-编写测试类" class="headerlink" title="六 编写测试类"></a>六 编写测试类</h2><p>因为糖糖封装的类库是依赖浏览器的window对象,那怎么办呢,可以使用jsdom,即可拿到window对象并挂载到全局</p><pre><code class="javascript">import TsSocket from &#39;../src/main&#39;import JsSocket from &#39;../lib/Socket.js&#39;import &#123;JSDOM&#125; from &#39;jsdom&#39;const &#123; window &#125; = new JSDOM(&#39;&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#39;); //导出JSDOM中的window对象// @ts-ignoreglobal.window = window; //将window对象设置为nodejs中全局对象;describe(&#39;Socket&#39;, () =&gt; &#123;  const url = &#39;ws://127.0.0.101:8888/websocket&#39;  const option = &#123;    debug: true,    onOpenAutoSendMsg: JSON.stringify(&#123; id: &#39;123456&#39;, type: &#39;login&#39; &#125;),    openCallback: (res: any) =&gt; &#123;      console.log(&#39;建立连接成功&#39;, res)      //...    &#125;,    messageCallback: (res: any) =&gt; &#123;      console.log(&#39;接收到的消息&#39;, res)      //...    &#125;    //...  &#125;  /**   * @jest-environment jsdom   */  it(&#39;typeScript&#39;, () =&gt; &#123;    const ws = new TsSocket(url, option)    //...    jest.setTimeout(5000)    // ws.removeSocket()    let getActiveLink = ws.getActiveLink();    expect(getActiveLink).toBe(true)  &#125;)  /**   * @jest-environment jsdom   */  it(&#39;javascript&#39;, () =&gt; &#123;    const ws = new JsSocket(url, option)    //...    jest.setTimeout(5000)    // ws.removeSocket()    let getActiveLink = ws.getActiveLink();    expect(getActiveLink).toBe(true)  &#125;)&#125;)</code></pre><h2 id="七-发布"><a href="#七-发布" class="headerlink" title="七 发布"></a>七 发布</h2><pre><code># 登录 npmnpm adduserUsername: youthcityPassword:Email: (this IS public) 填写邮箱Logged in as youthcity on https://registry.npmjs.org/.# 发布包npm publish</code></pre><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201510%2F26%2F20151026210924_sZ4P2.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-如何在centos7中切换java版本</title>
      <link href="/2021/09/21/%E5%90%8E%E7%AB%AF/java/java-%E5%A6%82%E4%BD%95%E5%9C%A8centos7%E4%B8%AD%E5%88%87%E6%8D%A2java%E7%89%88%E6%9C%AC/"/>
      <url>/2021/09/21/%E5%90%8E%E7%AB%AF/java/java-%E5%A6%82%E4%BD%95%E5%9C%A8centos7%E4%B8%AD%E5%88%87%E6%8D%A2java%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在centos7上便捷安装和切换java版本</p><span id="more"></span><h2 id="一-查看JAVA版本"><a href="#一-查看JAVA版本" class="headerlink" title="一 查看JAVA版本"></a>一 查看JAVA版本</h2><pre><code class="powershell">java -version</code></pre><p><img src="http://cdn.tangyuxian.com/PicGoImages/1632209282380.png" alt="1632209282380"></p><h2 id="二-查看卸载库中已有的版本"><a href="#二-查看卸载库中已有的版本" class="headerlink" title="二 查看卸载库中已有的版本"></a>二 查看卸载库中已有的版本</h2><pre><code>rpm -qa | grep jdkrpm -e --nodeps java-1.8.0-openjdk-1.8.0.262.b10-0.el7_8.x86_64</code></pre><p><img src="http://cdn.tangyuxian.com/PicGoImages/image-20210921153625084.png" alt="image-20210921153625084"></p><h2 id="三-安装指定版本"><a href="#三-安装指定版本" class="headerlink" title="三 安装指定版本"></a>三 安装指定版本</h2><pre><code>yum install java-11-openjdk* -y</code></pre><h2 id="四-切换版本"><a href="#四-切换版本" class="headerlink" title="四 切换版本"></a>四 切换版本</h2><pre><code> alternatives --config java</code></pre><p><img src="http://cdn.tangyuxian.com/PicGoImages/image-20210921153916115.png" alt="image-20210921153916115"></p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>执行<code>rpm</code>命令过程中如果出现<code>cannot open Packages database in /var/lib/rpm</code>,可执行如下操作</p><pre><code>cd /var/lib/rpmlsrm -rf __db*rpm --rebuilddb</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 服务器 </tag>
            
            <tag> centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器-http常用请求头</title>
      <link href="/2021/08/18/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-http%E5%B8%B8%E7%94%A8%E8%AF%B7%E6%B1%82%E5%A4%B4/"/>
      <url>/2021/08/18/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-http%E5%B8%B8%E7%94%A8%E8%AF%B7%E6%B1%82%E5%A4%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>HTTP消息头是指，在超文本传输协议（ Hypertext Transfer Protocol ，HTTP）的请求和响应消息中，协议头部分的那些组件。HTTP消息头用来准确描述正在获取的资源、服务器或者客户端的行为，定义了HTTP事务中的具体操作参数。</p><span id="more"></span><h3 id="1-关于HTTP消息头"><a href="#1-关于HTTP消息头" class="headerlink" title="1. 关于HTTP消息头"></a>1. 关于HTTP消息头</h3><p><code>HTTP消息头</code>是在，客户端请求（Request）或服务器响应（Response）时传递的，位请求或响应的第一行，<code>HTTP消息体</code>（请求或响应的内容）是其后传输。<code>HTTP消息头</code>，以明文的字符串格式传送，是以冒号分隔的键/值对，如：<code>Accept-Charset: utf-8</code>，每一个消息头最后以回车符(<code>CR</code>)和换行符(<code>LF</code>)结尾。<code>HTTP消息头</code>结束后，会用一个空白的字段来标识，这样就会出现两个连续的<code>CR-LF</code>。</p><p><code>HTTP消息头</code>由IANA（The Internet Assigned Numbers Authority，互联网数字分配机构）来整理和维护。其标准最早来源于<a href="http://tools.ietf.org/html/rfc4229">RFC 4229</a>。IANA将其整理到了<a href="http://www.iana.org/assignments/message-headers/perm-headers.html">消息头</a>文档，文档中还包括了<a href="http://www.iana.org/assignments/message-headers/message-headers.xhtml#prov-headersl">一些新提出的信息头</a>。</p><p><code>HTTP消息头</code>支持自定义， 自定义的专用消息头一般会添加<code>&#39;X-&#39;</code>前缀。</p><h3 id="2-常用的HTTP请求头"><a href="#2-常用的HTTP请求头" class="headerlink" title="2. 常用的HTTP请求头"></a>2. 常用的<code>HTTP请求头</code></h3><table><thead><tr><th align="left">协议头</th><th align="left">说明</th><th align="left">示例</th><th align="left">状态</th></tr></thead><tbody><tr><td align="left">Accept</td><td align="left">可接受的响应内容类型（<code>Content-Types</code>）。</td><td align="left"><code>Accept: text/plain</code></td><td align="left">固定</td></tr><tr><td align="left">Accept-Charset</td><td align="left">可接受的字符集</td><td align="left"><code>Accept-Charset: utf-8</code></td><td align="left">固定</td></tr><tr><td align="left">Accept-Encoding</td><td align="left">可接受的响应内容的编码方式。</td><td align="left"><code>Accept-Encoding: gzip, deflate</code></td><td align="left">固定</td></tr><tr><td align="left">Accept-Language</td><td align="left">可接受的响应内容语言列表。</td><td align="left"><code>Accept-Language: en-US</code></td><td align="left">固定</td></tr><tr><td align="left">Accept-Datetime</td><td align="left">可接受的按照时间来表示的响应内容版本</td><td align="left">Accept-Datetime: Sat, 26 Dec 2015 17:30:00 GMT</td><td align="left">临时</td></tr><tr><td align="left">Authorization</td><td align="left">用于表示HTTP协议中需要认证资源的认证信息</td><td align="left">Authorization: Basic OSdjJGRpbjpvcGVuIANlc2SdDE==</td><td align="left">固定</td></tr><tr><td align="left">Cache-Control</td><td align="left">用来指定当前的请求/回复中的，是否使用缓存机制。</td><td align="left"><code>Cache-Control: no-cache</code></td><td align="left">固定</td></tr><tr><td align="left">Connection</td><td align="left">客户端（浏览器）想要优先使用的连接类型</td><td align="left"><code>Connection: keep-alive``Connection: Upgrade</code></td><td align="left">固定</td></tr><tr><td align="left">Cookie</td><td align="left">由之前服务器通过<code>Set-Cookie</code>（见下文）设置的一个HTTP协议Cookie</td><td align="left"><code>Cookie: $Version=1; Skin=new;</code></td><td align="left">固定：标准</td></tr><tr><td align="left">Content-Length</td><td align="left">以8进制表示的请求体的长度</td><td align="left"><code>Content-Length: 348</code></td><td align="left">固定</td></tr><tr><td align="left">Content-MD5</td><td align="left">请求体的内容的二进制 MD5 散列值（数字签名），以 Base64 编码的结果</td><td align="left">Content-MD5: oD8dH2sgSW50ZWdyaIEd9D==</td><td align="left">废弃</td></tr><tr><td align="left">Content-Type</td><td align="left">请求体的MIME类型 （用于POST和PUT请求中）</td><td align="left">Content-Type: application/x-www-form-urlencoded</td><td align="left">固定</td></tr><tr><td align="left">Date</td><td align="left">发送该消息的日期和时间（以<a href="http://tools.ietf.org/html/rfc7231#section-7.1.1.1">RFC 7231</a>中定义的”HTTP日期”格式来发送）</td><td align="left">Date: Dec, 26 Dec 2015 17:30:00 GMT</td><td align="left">固定</td></tr><tr><td align="left">Expect</td><td align="left">表示客户端要求服务器做出特定的行为</td><td align="left"><code>Expect: 100-continue</code></td><td align="left">固定</td></tr><tr><td align="left">From</td><td align="left">发起此请求的用户的邮件地址</td><td align="left"><code>From: user@itbilu.com</code></td><td align="left">固定</td></tr><tr><td align="left">Host</td><td align="left">表示服务器的域名以及服务器所监听的端口号。如果所请求的端口是对应的服务的标准端口（80），则端口号可以省略。</td><td align="left"><code>Host: www.itbilu.com:80``Host: www.itbilu.com</code></td><td align="left">固定</td></tr><tr><td align="left">If-Match</td><td align="left">仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要用于像 PUT 这样的方法中，仅当从用户上次更新某个资源后，该资源未被修改的情况下，才更新该资源。</td><td align="left">If-Match: “9jd00cdj34pss9ejqiw39d82f20d0ikd”</td><td align="left">固定</td></tr><tr><td align="left">If-Modified-Since</td><td align="left">允许在对应的资源未被修改的情况下返回304未修改</td><td align="left">If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT</td><td align="left">固定</td></tr><tr><td align="left">If-None-Match</td><td align="left">允许在对应的内容未被修改的情况下返回304未修改（ 304 Not Modified ），参考 超文本传输协议 的实体标记</td><td align="left">If-None-Match: “9jd00cdj34pss9ejqiw39d82f20d0ikd”</td><td align="left">固定</td></tr><tr><td align="left">If-Range</td><td align="left">如果该实体未被修改过，则向返回所缺少的那一个或多个部分。否则，返回整个新的实体</td><td align="left">If-Range: “9jd00cdj34pss9ejqiw39d82f20d0ikd”</td><td align="left">固定</td></tr><tr><td align="left">If-Unmodified-Since</td><td align="left">仅当该实体自某个特定时间以来未被修改的情况下，才发送回应。</td><td align="left">If-Unmodified-Since: Dec, 26 Dec 2015 17:30:00 GMT</td><td align="left">固定</td></tr><tr><td align="left">Max-Forwards</td><td align="left">限制该消息可被代理及网关转发的次数。</td><td align="left"><code>Max-Forwards: 10</code></td><td align="left">固定</td></tr><tr><td align="left">Origin</td><td align="left">发起一个针对<a href="http://itbilu.com/javascript/js/VkiXuUcC.html">跨域资源共享</a>的请求（该请求要求服务器在响应中加入一个<code>Access-Control-Allow-Origin</code>的消息头，表示访问控制所允许的来源）。</td><td align="left"><code>Origin: http://www.itbilu.com</code></td><td align="left">固定: 标准</td></tr><tr><td align="left">Pragma</td><td align="left">与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生。</td><td align="left"><code>Pragma: no-cache</code></td><td align="left">固定</td></tr><tr><td align="left">Proxy-Authorization</td><td align="left">用于向代理进行认证的认证信息。</td><td align="left">Proxy-Authorization: Basic IOoDZRgDOi0vcGVuIHNlNidJi2==</td><td align="left">固定</td></tr><tr><td align="left">Range</td><td align="left">表示请求某个实体的一部分，字节偏移以0开始。</td><td align="left"><code>Range: bytes=500-999</code></td><td align="left">固定</td></tr><tr><td align="left">Referer</td><td align="left">表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面。<code>Referer</code>其实是<code>Referrer</code>这个单词，但RFC制作标准时给拼错了，后来也就将错就错使用<code>Referer</code>了。</td><td align="left">Referer: <a href="http://itbilu.com/nodejs">http://itbilu.com/nodejs</a></td><td align="left">固定</td></tr><tr><td align="left">TE</td><td align="left">浏览器预期接受的传输时的编码方式：可使用回应协议头<code>Transfer-Encoding</code>中的值（还可以使用”trailers”表示数据传输时的分块方式）用来表示浏览器希望在最后一个大小为0的块之后还接收到一些额外的字段。</td><td align="left"><code>TE: trailers,deflate</code></td><td align="left">固定</td></tr><tr><td align="left">User-Agent</td><td align="left">浏览器的身份标识字符串</td><td align="left"><code>User-Agent: Mozilla/……</code></td><td align="left">固定</td></tr><tr><td align="left">Upgrade</td><td align="left">要求服务器升级到一个高版本协议。</td><td align="left">Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td><td align="left">固定</td></tr><tr><td align="left">Via</td><td align="left">告诉服务器，这个请求是由哪些代理发出的。</td><td align="left">Via: 1.0 fred, 1.1 itbilu.com.com (Apache/1.1)</td><td align="left">固定</td></tr><tr><td align="left">Warning</td><td align="left">一个一般性的警告，表示在实体内容体中可能存在错误。</td><td align="left">Warning: 199 Miscellaneous warning</td><td align="left">固定</td></tr></tbody></table><h3 id="3-常用的HTTP响应头"><a href="#3-常用的HTTP响应头" class="headerlink" title="3. 常用的HTTP响应头"></a>3. 常用的<code>HTTP响应头</code></h3><table><thead><tr><th align="left">响应头</th><th align="left">说明</th><th align="left">示例</th><th align="left">状态</th></tr></thead><tbody><tr><td align="left">Access-Control-Allow-Origin</td><td align="left">指定哪些网站可以<code>跨域源资源共享</code></td><td align="left"><code>Access-Control-Allow-Origin: *</code></td><td align="left">临时</td></tr><tr><td align="left">Accept-Patch</td><td align="left">指定服务器所支持的文档补丁格式</td><td align="left">Accept-Patch: text/example;charset=utf-8</td><td align="left">固定</td></tr><tr><td align="left">Accept-Ranges</td><td align="left">服务器所支持的内容范围</td><td align="left"><code>Accept-Ranges: bytes</code></td><td align="left">固定</td></tr><tr><td align="left">Age</td><td align="left">响应对象在代理缓存中存在的时间，以秒为单位</td><td align="left"><code>Age: 12</code></td><td align="left">固定</td></tr><tr><td align="left">Allow</td><td align="left">对于特定资源的有效动作;</td><td align="left"><code>Allow: GET, HEAD</code></td><td align="left">固定</td></tr><tr><td align="left">Cache-Control</td><td align="left">通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒</td><td align="left"><code>Cache-Control: max-age=3600</code></td><td align="left">固定</td></tr><tr><td align="left">Connection</td><td align="left">针对该连接所预期的选项</td><td align="left"><code>Connection: close</code></td><td align="left">固定</td></tr><tr><td align="left">Content-Disposition</td><td align="left">对已知MIME类型资源的描述，浏览器可以根据这个响应头决定是对返回资源的动作，如：将其下载或是打开。</td><td align="left">Content-Disposition: attachment; filename=”fname.ext”</td><td align="left">固定</td></tr><tr><td align="left">Content-Encoding</td><td align="left">响应资源所使用的编码类型。</td><td align="left"><code>Content-Encoding: gzip</code></td><td align="left">固定</td></tr><tr><td align="left">Content-Language</td><td align="left">响就内容所使用的语言</td><td align="left"><code>Content-Language: zh-cn</code></td><td align="left">固定</td></tr><tr><td align="left">Content-Length</td><td align="left">响应消息体的长度，用8进制字节表示</td><td align="left"><code>Content-Length: 348</code></td><td align="left">固定</td></tr><tr><td align="left">Content-Location</td><td align="left">所返回的数据的一个候选位置</td><td align="left"><code>Content-Location: /index.htm</code></td><td align="left">固定</td></tr><tr><td align="left">Content-MD5</td><td align="left">响应内容的二进制 MD5 散列值，以 Base64 方式编码</td><td align="left">Content-MD5: IDK0iSsgSW50ZWd0DiJUi==</td><td align="left">已淘汰</td></tr><tr><td align="left">Content-Range</td><td align="left">如果是响应部分消息，表示属于完整消息的哪个部分</td><td align="left">Content-Range: bytes 21010-47021/47022</td><td align="left">固定</td></tr><tr><td align="left">Content-Type</td><td align="left">当前内容的<code>MIME</code>类型</td><td align="left">Content-Type: text/html; charset=utf-8</td><td align="left">固定</td></tr><tr><td align="left">Date</td><td align="left">此条消息被发送时的日期和时间(以<a href="http://tools.ietf.org/html/rfc7231#section-7.1.1.1">RFC 7231</a>中定义的”HTTP日期”格式来表示)</td><td align="left">Date: Tue, 15 Nov 1994 08:12:31 GMT</td><td align="left">固定</td></tr><tr><td align="left">ETag</td><td align="left">对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列</td><td align="left">ETag: “737060cd8c284d8af7ad3082f209582d”</td><td align="left">固定</td></tr><tr><td align="left">Expires</td><td align="left">指定一个日期/时间，超过该时间则认为此回应已经过期</td><td align="left">Expires: Thu, 01 Dec 1994 16:00:00 GMT</td><td align="left">固定: 标准</td></tr><tr><td align="left">Last-Modified</td><td align="left">所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)</td><td align="left">Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT</td><td align="left">固定</td></tr><tr><td align="left">Link</td><td align="left">用来表示与另一个资源之间的类型关系，此类型关系是在<a href="https://tools.ietf.org/html/rfc5988">RFC 5988</a>中定义</td><td align="left"><code>Link: </code>; rel=”alternate”</td><td align="left">固定</td></tr><tr><td align="left">Location</td><td align="left">用于在进行重定向，或在创建了某个新资源时使用。</td><td align="left">Location: <a href="http://www.itbilu.com/nodejs">http://www.itbilu.com/nodejs</a></td><td align="left">固定</td></tr><tr><td align="left">P3P</td><td align="left">P3P策略相关设置</td><td align="left">P3P: CP=”This is not a P3P policy!</td><td align="left">固定</td></tr><tr><td align="left">Pragma</td><td align="left">与具体的实现相关，这些响应头可能在请求/回应链中的不同时候产生不同的效果</td><td align="left"><code>Pragma: no-cache</code></td><td align="left">固定</td></tr><tr><td align="left">Proxy-Authenticate</td><td align="left">要求在访问代理时提供身份认证信息。</td><td align="left"><code>Proxy-Authenticate: Basic</code></td><td align="left">固定</td></tr><tr><td align="left">Public-Key-Pins</td><td align="left">用于防止中间攻击，声明网站认证中传输层安全协议的证书散列值</td><td align="left">Public-Key-Pins: max-age=2592000; pin-sha256=”……”;</td><td align="left">固定</td></tr><tr><td align="left">Refresh</td><td align="left">用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。</td><td align="left">Refresh: 5; url=<a href="http://itbilu.com/">http://itbilu.com</a></td><td align="left"></td></tr><tr><td align="left">Retry-After</td><td align="left">如果某个实体临时不可用，那么此协议头用于告知客户端稍后重试。其值可以是一个特定的时间段(以秒为单位)或一个超文本传输协议日期。</td><td align="left">示例1:Retry-After: 120示例2: Retry-After: Dec, 26 Dec 2015 17:30:00 GMT</td><td align="left">固定</td></tr><tr><td align="left">Server</td><td align="left">服务器的名称</td><td align="left"><code>Server: nginx/1.6.3</code></td><td align="left">固定</td></tr><tr><td align="left">Set-Cookie</td><td align="left">设置<code>HTTP cookie</code></td><td align="left">Set-Cookie: UserID=itbilu; Max-Age=3600; Version=1</td><td align="left">固定: 标准</td></tr><tr><td align="left">Status</td><td align="left">通用网关接口的响应头字段，用来说明当前HTTP连接的响应状态。</td><td align="left"><code>Status: 200 OK</code></td><td align="left"></td></tr><tr><td align="left">Trailer</td><td align="left"><code>Trailer</code>用户说明传输中分块编码的编码信息</td><td align="left"><code>Trailer: Max-Forwards</code></td><td align="left">固定</td></tr><tr><td align="left">Transfer-Encoding</td><td align="left">用表示实体传输给用户的编码形式。包括：<code>chunked</code>、<code>compress</code>、 <code>deflate</code>、<code>gzip</code>、<code>identity</code>。</td><td align="left">Transfer-Encoding: chunked</td><td align="left">固定</td></tr><tr><td align="left">Upgrade</td><td align="left">要求客户端升级到另一个高版本协议。</td><td align="left">Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td><td align="left">固定</td></tr><tr><td align="left">Vary</td><td align="left">告知下游的代理服务器，应当如何对以后的请求协议头进行匹配，以决定是否可使用已缓存的响应内容而不是重新从原服务器请求新的内容。</td><td align="left"><code>Vary: *</code></td><td align="left">固定</td></tr><tr><td align="left">Via</td><td align="left">告知代理服务器的客户端，当前响应是通过什么途径发送的。</td><td align="left">Via: 1.0 fred, 1.1 itbilu.com (nginx/1.6.3)</td><td align="left">固定</td></tr><tr><td align="left">Warning</td><td align="left">一般性警告，告知在实体内容体中可能存在错误。</td><td align="left">Warning: 199 Miscellaneous warning</td><td align="left">固定</td></tr><tr><td align="left">WWW-Authenticate</td><td align="left">表示在请求获取这个实体时应当使用的认证模式。</td><td align="left"><code>WWW-Authenticate: Basic</code></td><td align="left">固定</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器-http返回的所有状态码汇总</title>
      <link href="/2021/08/18/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-http%E8%BF%94%E5%9B%9E%E7%9A%84%E6%89%80%E6%9C%89%E7%8A%B6%E6%80%81%E7%A0%81%E6%B1%87%E6%80%BB/"/>
      <url>/2021/08/18/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-http%E8%BF%94%E5%9B%9E%E7%9A%84%E6%89%80%E6%9C%89%E7%8A%B6%E6%80%81%E7%A0%81%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>http状态码汇总</p><span id="more"></span><p>100    Continue    继续。客户端应继续其请求</p><p>101    Switching Protocols    切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</p><p>200    OK    请求成功。一般用于GET与POST请求</p><p>201    Created    已创建。成功请求并创建了新的资源</p><p>202    Accepted    已接受。已经接受请求，但未处理完成</p><p>203    Non-Authoritative Information    非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</p><p>204    No Content    无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</p><p>205    Reset Content    重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</p><p>206    Partial Content    部分内容。服务器成功处理了部分GET请求</p><p>300    Multiple Choices    多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</p><p>301    Moved Permanently    永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</p><p>302    Found    临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</p><p>303    See Other    查看其它地址。与301类似。使用GET和POST请求查看</p><p>304    Not Modified    未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</p><p>305    Use Proxy    使用代理。所请求的资源必须通过代理访问</p><p>306    Unused    已经被废弃的HTTP状态码</p><p>307    Temporary Redirect    临时重定向。与302类似。使用GET请求重定向</p><p>400    Bad Request    客户端请求的语法错误，服务器无法理解</p><p>401    Unauthorized    请求要求用户的身份认证</p><p>402    Payment Required    保留，将来使用</p><p>403    Forbidden    服务器理解请求客户端的请求，但是拒绝执行此请求</p><p>404    Not Found    服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</p><p>405    Method Not Allowed    客户端请求中的方法被禁止</p><p>406    Not Acceptable    服务器无法根据客户端请求的内容特性完成请求</p><p>407    Proxy Authentication Required    请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</p><p>408    Request Time-out    服务器等待客户端发送的请求时间过长，超时</p><p>409    Conflict    服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</p><p>410    Gone    客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</p><p>411    Length Required    服务器无法处理客户端发送的不带Content-Length的请求信息</p><p>412    Precondition Failed    客户端请求信息的先决条件错误</p><p>413    Request Entity Too Large    由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</p><p>414    Request-URI Too Large    请求的URI过长（URI通常为网址），服务器无法处理</p><p>415    Unsupported Media Type    服务器无法处理请求附带的媒体格式</p><p>416    Requested range not satisfiable    客户端请求的范围无效</p><p>417    Expectation Failed    服务器无法满足Expect的请求头信息</p><p>500    Internal Server Error    服务器内部错误，无法完成请求</p><p>501    Not Implemented    服务器不支持请求的功能，无法完成请求</p><p>502    Bad Gateway    作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</p><p>503    Service Unavailable    由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</p><p>504    Gateway Time-out    充当网关或代理的服务器，未及时从远端服务器获取请求</p><p>505    HTTP Version not supported    服务器不支持请求的HTTP协议的版本，无法完成处理</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git-Git常用操作整理</title>
      <link href="/2021/08/13/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/git-Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%95%B4%E7%90%86/"/>
      <url>/2021/08/13/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/git-Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Git常用操作整理…</p><span id="more"></span><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><ul><li><h5 id="git-clone-克隆仓库代码："><a href="#git-clone-克隆仓库代码：" class="headerlink" title="git clone 克隆仓库代码："></a>git clone 克隆仓库代码：</h5><p>git clone <a href="https://gitee.com/houpai/git-demo.git%EF%BC%88%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80%EF%BC%89">https://gitee.com/houpai/git-demo.git（仓库地址）</a></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813100147449.png" alt="image-20210813100147449"></p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813100121447.png" alt="image-20210813100121447"></p><ul><li><h5 id="git-status查看本地工作区状态"><a href="#git-status查看本地工作区状态" class="headerlink" title="git status查看本地工作区状态"></a>git status查看本地工作区状态</h5><p>git status</p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813102546895.png" alt="image-20210813102546895"></p><p>如图上所示Untacked files提示该文件为添加到版本追踪里</p></li><li><h5 id="git-add-把修改-新增等提交暂存区"><a href="#git-add-把修改-新增等提交暂存区" class="headerlink" title="git add 把修改/新增等提交暂存区"></a>git add 把修改/新增等提交暂存区</h5><p> git add . ： 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件;–仅针对git版本为1.X的，目前2.X的含义是提交所有变化；</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813104533648.png" alt="image-20210813104533648"></p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813104738794.png" alt="image-20210813104738794"></p><ul><li><h5 id="git-add-–u-提交被修改-modified-和被删除-deleted-文件，不包括新文件-new"><a href="#git-add-–u-提交被修改-modified-和被删除-deleted-文件，不包括新文件-new" class="headerlink" title="git add –u :  提交被修改(modified)和被删除(deleted)文件，不包括新文件(new);"></a>git add –u :  提交被修改(modified)和被删除(deleted)文件，不包括新文件(new);</h5><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813105228259.png" alt="image-20210813105228259"></p></li></ul><ul><li><h5 id="git-add-–A-提交所有变化"><a href="#git-add-–A-提交所有变化" class="headerlink" title="git add –A : 提交所有变化"></a>git add –A : 提交所有变化</h5></li></ul><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813105329430.png" alt="image-20210813105329430"></p><blockquote><p><code>PS：在未commit命令之前，如果想撤销add , 可以用命令：git reset；</code></p></blockquote><ul><li><h5 id="git-commit-将暂存区的改动提交到本地仓库"><a href="#git-commit-将暂存区的改动提交到本地仓库" class="headerlink" title="git commit 将暂存区的改动提交到本地仓库"></a>git commit 将暂存区的改动提交到本地仓库</h5></li></ul><ol><li><p>每次使用git commit 命令我们都会在本地版本库生成一个40位的哈希值，这个哈希值也叫commit-id，commit-id在版本回退的时候是非常有用的，它相当于一个快照,可以在未来的任何时候通过与git reset的组合命令回到这里；</p></li><li><p>git commit –amend (原来提交基础上提交，不是新的提交) </p></li></ol><ul><li><h5 id="git-log-查看提交历史"><a href="#git-log-查看提交历史" class="headerlink" title="git log 查看提交历史"></a>git log 查看提交历史</h5><p> git log : 默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。每次更新都有一个 SHA-1 校验和、作者的名字和电子邮件地址、提交时间，最后缩进一个段落显示提交说明—commit –m 里的message。</p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813115345755.png" alt="image-20210813115345755"></p></li></ul><p>​    </p><p>​        git log –p: 选项展开显示每次提交的内容差异        </p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813115526464.png" alt="image-20210813115526464"></p><blockquote><p><code>PS:退出 :q</code></p></blockquote><p>​    git log -1 : 后面加数字，显示最近的几次提交</p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813132434260.png" alt="image-20210813132434260"></p><p>​    git log –p –word-diff : 单词层面上的对比</p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813132632230.png" alt="image-20210813132632230"></p><ul><li><h5 id="git-pull-将本地仓更新至远程仓的最新状态，获取代码并自动合并"><a href="#git-pull-将本地仓更新至远程仓的最新状态，获取代码并自动合并" class="headerlink" title="git pull : 将本地仓更新至远程仓的最新状态，获取代码并自动合并"></a>git pull : 将本地仓更新至远程仓的最新状态，获取代码并自动合并</h5><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813132746452.png" alt="image-20210813132746452"></p></li></ul><ul><li><h5 id="git-push-将本地分支的更新，推送到远程仓库"><a href="#git-push-将本地分支的更新，推送到远程仓库" class="headerlink" title="git push : 将本地分支的更新，推送到远程仓库"></a>git push : 将本地分支的更新，推送到远程仓库</h5><p> 如果当前分支和远程分支之前存在追踪关系，则git push origin 的含义是：将当前分支推送到origin主机的对应分支上；</p></li></ul><ul><li><h5 id="git-branch-–vv-查看本地当前分支与远程分支的追踪关系"><a href="#git-branch-–vv-查看本地当前分支与远程分支的追踪关系" class="headerlink" title="git branch –vv : 查看本地当前分支与远程分支的追踪关系"></a>git branch –vv : 查看本地当前分支与远程分支的追踪关系</h5><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813133729555.png" alt="image-20210813133729555"></p><blockquote><p><code>更改分支名称：git branch –m 改之前的分支名称  改之后的分支名称</code></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813134333892.png" alt="image-20210813134333892"></p></li></ul><ul><li><h5 id="git-checkout-切换分支"><a href="#git-checkout-切换分支" class="headerlink" title="git checkout : 切换分支"></a>git checkout : 切换分支</h5><p>  git checkout dev : 切换到dev 分支；</p><p>  git checkout –b dev :以当前分支为源创建分支dev；</p><blockquote><p><code>PS: git checkout –b dev是 git branch dev  ; git checkout dev 两条命令的简写</code></p></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813134601212.png" alt="image-20210813134601212"></p><p>​        如果本地已经存在dev分支，则会提示；</p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813134706819.png" alt="image-20210813134706819">    </p><blockquote><p><code>PS：新创建的分支，是没有与远程关联的，需要先建立关联，把本地分支与远程建立追踪关系；git push --set-upstream origin dev</code></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813135718369.png" alt="image-20210813135718369"></p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813140211171.png" alt="image-20210813140211171"></p><blockquote><p>​    <code>PS: git checkout --filename :该命令适用于：已经add后，后来又修改了文件，想要恢复之前add 的内容，则就可以把暂存区的内容替换到工作区了；或者没add 之前，我想把修改的内容恢复，也可以用git checkout filename;</code></p></blockquote><ul><li><h5 id="git-revert-撤销某次操作，并把此次撤销作为新的提交-请谨慎操作！）"><a href="#git-revert-撤销某次操作，并把此次撤销作为新的提交-请谨慎操作！）" class="headerlink" title="git revert :撤销某次操作，并把此次撤销作为新的提交( 请谨慎操作！）"></a>git revert :撤销某次操作，并把此次撤销作为新的提交( 请谨慎操作！）</h5><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813140902822.png" alt="image-20210813140902822"></p></li></ul><p>​    git revert HEAD ：撤销前一次的commit ；</p><p>​    git  revert HEAD^ :撤销前前一次的commit;</p><p>​    git  revert commit-id :撤销指定版本的提交；</p><p>​    可以在命令中加上–no-edit参数。另一个重要的参数是-n或者–no-commit，应用这个参数会让revert 改动只限于程序员的本地仓库，而不自动进行commit</p><ul><li><h5 id="git-reset-用来将当前branch重置到另外一个commit的-请谨慎操作！）"><a href="#git-reset-用来将当前branch重置到另外一个commit的-请谨慎操作！）" class="headerlink" title="git reset : 用来将当前branch重置到另外一个commit的( 请谨慎操作！）"></a>git reset : 用来将当前branch重置到另外一个commit的( 请谨慎操作！）</h5><p>git reset HEAD : 重置当前分支到最近的一次提交；（HEAD这是当前分支版本顶端的别名，也就是在当前分支你最近的一个提交）</p><p>git reset HEAD~1 : 将HEAD从顶端的commit往下移动一个commit；从暂存区取出，替换到工作区；</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813141313715.png" alt="image-20210813141313715"></p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813141558893.png" alt="image-20210813141558893"></p><blockquote><p><code>参数：--soft : 重置HEAD到另外一个commit，但也到此为止 , 所有变更都集中到暂存区，工作区；</code></p><p><code>--hard ：危险操作，所有变更全部丢失，不管本地仓，暂存区，工作区；</code></p><p><code>--mixed : 所有变更保存到工作区，本地仓，暂存区都丢失；默认参数；</code></p></blockquote><ul><li><h5 id="git-stash-储藏变更"><a href="#git-stash-储藏变更" class="headerlink" title="git stash : 储藏变更"></a>git stash : 储藏变更</h5><p>使用场景：当前工作区有变更，且作业没完成，但是需要切换到其他分支进行其他作业，需要干净的工作区间；</p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813145829941.png" alt="image-20210813145829941"></p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813150225555.png" alt="image-20210813150225555"></p></li></ul><p>​    查看现有的所有储存：git stash list </p><p>​    <img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813150419586.png" alt="image-20210813150419586"></p><p>其他分支作业完成后，返回之前分支，继续之前作业：git stash pop</p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813150550178.png" alt="image-20210813150550178"></p><blockquote><p><code>删除没用的储存：git stash drop stash@&#123;0&#125; / git stash clear</code></p></blockquote><ul><li><h5 id="git-merge-合并分支到当前分支"><a href="#git-merge-合并分支到当前分支" class="headerlink" title="git merge : 合并分支到当前分支"></a>git merge : 合并分支到当前分支</h5><p>首先切换到要合并的目标分支，比如把dev分支合并到master分支上，先切到master分支；</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813151449597.png" alt="image-20210813151449597"></p><p>​    git merge dev :把dev 分支合并到当前分支</p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813151548854.png" alt="image-20210813151548854"></p><p>​     如果没有冲突的话，merge完成。有冲突的话，git会提示那个文件中有冲突，比如有如下冲突：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813151658048.png" alt="image-20210813151658048"></p><p>​    可以看到 ======= 隔开的上半部分，是 master 分支冲突的内容，下半部分是在 dev分支冲突的内容。</p><p>​    这个时候可以解决完冲突之后再进行相关操作：git add ; git commit 等等.</p><ul><li><h5 id="git-rebase-对于分支做‘变基’操作，可以理解为‘重新设置基线’"><a href="#git-rebase-对于分支做‘变基’操作，可以理解为‘重新设置基线’" class="headerlink" title="git rebase : 对于分支做‘变基’操作，可以理解为‘重新设置基线’"></a>git rebase : 对于分支做‘变基’操作，可以理解为‘重新设置基线’</h5><p>该命令适应于自己本地私有分支，远程分支慎用；</p><p>使用场景1：当你本地试图commit ,push 到一个remote时而因tracking branch过于陈旧而被拒绝的时候（原因是自从之前与orgin同步后，有其他人员提交了很多commit），如果强行push，会覆盖远程仓，把其他人员的commit给丢掉–谨慎，谨慎，谨慎；</p><p>回到rebase之前的状态：git rebase –abort </p><p>使用场景2：本地开发多次提交合并，便于管理跟踪，比如：dev 分支从master分支上创建，然后dev分支上自己提交了多个commit , </p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813155225050.png" alt="image-20210813155225050"></p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813155241666.png" alt="image-20210813155241666"></p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813155250923.png" alt="image-20210813155250923"></p><p>​    我们设置第二个”pick 657a291 add 2.txt” 为” s 657a291 add 2.txt”这里的s就是squash命令的简写。</p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813155306599.png" alt="image-20210813155306599"></p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813155316585.png" alt="image-20210813155316585"></p><p>​    删除之前的两条message(ESC dd)，设置一总的message 然后保存退出。(ESC wq)</p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813155333578.png" alt="image-20210813155333578"></p><ul><li><h5 id="git-fsck-–lost-found-找回git-add-过，但是已经删除的文件内容"><a href="#git-fsck-–lost-found-找回git-add-过，但是已经删除的文件内容" class="headerlink" title="git fsck –lost-found : 找回git add 过，但是已经删除的文件内容"></a>git fsck –lost-found : 找回git add 过，但是已经删除的文件内容</h5></li><li><h5 id="git-branch-查看分支情况"><a href="#git-branch-查看分支情况" class="headerlink" title="git branch : 查看分支情况"></a>git branch : 查看分支情况</h5><p>查看项目的目前存在的分支情况，包括本地和远程 : git branch -a</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813155514556.png" alt="image-20210813155514556"></p><p>删除本地分支 ：git branch –d dev (-d , 删除分支； -D ,强制删除分支)</p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813155822581.png" alt="image-20210813155822581"></p><p>删除远程分支: git push origin :dev</p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813155923526.png" alt="image-20210813155923526"></p><h4 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h4><ul><li><h5 id="修改当前的追踪关系"><a href="#修改当前的追踪关系" class="headerlink" title="修改当前的追踪关系"></a>修改当前的追踪关系</h5><p>文件修改：本地打开.git à config 文件，别用记事本，修改[branch “master”]这一项是修改本地分支‘master’的远程追踪关系分支，直接修改merge = refs/heads/master为merge = refs/heads/dev；</p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813160042246.png" alt="image-20210813160042246"></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813160058861.png" alt="image-20210813160058861"></p><p>​    命令修改：git branch –set-upstream-to=origin/master</p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813160112683.png" alt="image-20210813160112683"></p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813160130746.png" alt="image-20210813160130746"></p><ul><li><h5 id="查看远程版本库信息"><a href="#查看远程版本库信息" class="headerlink" title="查看远程版本库信息"></a>查看远程版本库信息</h5><p>git remote –v:</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813160215210.png" alt="image-20210813160215210"></p><ul><li><h5 id="更改远程仓库连接地址"><a href="#更改远程仓库连接地址" class="headerlink" title="更改远程仓库连接地址"></a>更改远程仓库连接地址</h5><p>ssh执行：git remote set-url origin <a href="mailto:&#x67;&#105;&#x74;&#x40;&#x67;&#105;&#x74;&#x65;&#101;&#x2e;&#99;&#x6f;&#109;">&#x67;&#105;&#x74;&#x40;&#x67;&#105;&#x74;&#x65;&#101;&#x2e;&#99;&#x6f;&#109;</a>:houpai/git-demo.git</p><p>http执行：git remote set-url origin  <a href="https://github.com/NECKLI/git-test.git">https://github.com/NECKLI/git-test.git</a></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813161758028.png" alt="image-20210813161758028"></p><ul><li><h5 id="放弃本地修改，强制更新到本地"><a href="#放弃本地修改，强制更新到本地" class="headerlink" title="放弃本地修改，强制更新到本地"></a>放弃本地修改，强制更新到本地</h5><p>git fetch –all  //只下载远程的库的内容，不做任何的合并</p><p>git reset –hard origin/master  //把HEAD指向刚下载的最新版本</p></li></ul><ul><li><h5 id="查看当前分支是基于哪个分支建立的"><a href="#查看当前分支是基于哪个分支建立的" class="headerlink" title="查看当前分支是基于哪个分支建立的"></a>查看当前分支是基于哪个分支建立的</h5><p>git reflog –-date=local</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813162919105.png" alt="image-20210813162919105"></p><ul><li><h5 id="将某次提交合并到指定分支上"><a href="#将某次提交合并到指定分支上" class="headerlink" title="将某次提交合并到指定分支上"></a>将某次提交合并到指定分支上</h5><p>在修改分支上查看日志，找到对应的提交id</p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813163337230.png" alt="image-20210813163337230"></p><p>切换到指定分支: git checkout master1</p><p>再把指定的提交合并到当前分支：git cherry-pick commit-id</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813163622576.png" alt="image-20210813163622576"></p><ul><li><h5 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h5><p>先查看提交日志，找到要回退的版本，git log</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813163821444.png" alt="image-20210813163821444"></p><p>​    复制对应的commit id，<code>假如：e80d1d2e91b39a88908a3a0a31d15966d743c2df ；的提交； 本地版本回退：git reset --hard commit-id (如果确定不要该提交之后的提交，则可以用hard参数，如果要修改保留，则把hard参数去掉，重新提交)</code></p><p>本地之前的提交会全部丢失，使用的时候要谨慎；</p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813165148007.png" alt="image-20210813165148007"></p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813165633739.png" alt="image-20210813165633739"></p><p> <code>    本地强制覆盖远程，使用的时候要谨慎，谨慎，谨慎 ,会影响其他人员使用，如果某人错误覆盖，则远程的其他提交没有了记录，要找回的话，可以找其他人员没有更新之前的代码，再同步到远程，如果其他人手里也没有了，则可以使用git fsck找回，操作会麻烦，--没具体实现过（http://blog.sina.com.cn/s/blog_66cd08930102x0ln.html）</code></p><ul><li><h5 id="本地创建远程分支"><a href="#本地创建远程分支" class="headerlink" title="本地创建远程分支"></a>本地创建远程分支</h5><p>例子：如现在有master , dev 分支，现在本地想以dev 分支为基分支创建新分支，并推送远程仓库, git checkout –b newDev</p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813170306723.png" alt="image-20210813170306723"></p><p>将本地newDev 分支作为远程newDev分支: git push origin newDev</p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813170314683.png" alt="image-20210813170314683"></p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813170329076.png" alt="image-20210813170329076"></p><p>跟远程对应仓建立追踪关系： git branch –set-upstream-to=origin/newDev</p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813170336371.png" alt="image-20210813170336371"></p><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813170345098.png" alt="image-20210813170345098"></p><p>这个时候创建远程仓完成；在仓库里创建新分支比较简单，方便</p></li></ul><ul><li><h5 id="本地多次提交，push之前优化commits"><a href="#本地多次提交，push之前优化commits" class="headerlink" title="本地多次提交，push之前优化commits"></a>本地多次提交，push之前优化commits</h5></li></ul><p>​    git log 查看日志，找到要合并的commits</p><p>​    git rebase - i HEAD~2  ; //优化最近的两次提交</p><p>​    对于 commit 合并可以使用 squash、fixup 指令，区别是 squash 会将该 commit 的注释添加到上一个 commit 注释中，fixup 是放弃当前 commit 的注释。</p><p>​    编辑后保存退出，git 会自动压缩提交历史，如果有冲突，记得解决冲突后，使用 git rebase –continue 重新回到当前的 git 压缩过程；</p><p>​    git push 推送到远程，再看git log ，提交日志就简洁多了。</p><ul><li><h5 id="本地全新项目，建本地仓，然后推送到远程"><a href="#本地全新项目，建本地仓，然后推送到远程" class="headerlink" title="本地全新项目，建本地仓，然后推送到远程"></a>本地全新项目，建本地仓，然后推送到远程</h5><p>远程仓库先建立一个仓库；</p><p>切换到项目目录下，然后初始化本地git仓，git init ；</p><p>将本地仓与远程仓进行关联，git remote add origin https://…..  .git</p><p>把项目添加到本地仓，git add *  git commit –m ‘注释’;</p><p>推送到远程仓，git push –u origin master ，（远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令）。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git-gitee码云使用webhook</title>
      <link href="/2021/08/13/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/git-gitee%E7%A0%81%E4%BA%91%E4%BD%BF%E7%94%A8webhook/"/>
      <url>/2021/08/13/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/git-gitee%E7%A0%81%E4%BA%91%E4%BD%BF%E7%94%A8webhook/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>gitee配置webhook</p><span id="more"></span><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>我们经常使用GitHub、GitLab、Gitee 之类的仓库，有时候需要频繁的发布代码打包，人工发布，工作量有时候会很大，有时候还容易出错，所以会使用Jenkins一类的工具进行辅助，但是如果是一个简单的项目或者是个人项目使用Jenkins就显得太重了，可以直接使用webhook，比较方便。</p><h3 id="什么是webhook"><a href="#什么是webhook" class="headerlink" title="什么是webhook"></a>什么是webhook</h3><blockquote><p>准确的说webhoo是一种web回调或者http的push API，是向APP或者其他应用提供实时信息的一种方式。Webhook在数据产生时立即发送数据，也就是你能实时收到数据。这一种不同于典型的API，需要用了实时性需要足够快的轮询。这无论是对生产还是对消费者都是高效的，唯一的缺点是初始建立困难。</p></blockquote><blockquote><p>Webhook有时也被称为反向API，因为他提供了API规则，你需要设计要使用的API。Webhook将向你的应用发起http请求，典型的是post请求，应用程序由请求驱动。</p></blockquote><h3 id="配置webhook"><a href="#配置webhook" class="headerlink" title="配置webhook"></a>配置webhook</h3><p>知道什么是webhook 后我们就要开始配置我们自己的项目了。<br> 环境：<br> CentOS7<br> Gitee（网上GitHub的教程比较多，这个基于码云）</p><ul><li>配置项目公私钥</li></ul><ol><li>生产公钥</li></ol><pre><code class="bash">ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot;  # Generating public/private rsa key pair...# 三次回车即可生成 ssh key</code></pre><ol><li>查看公钥</li></ol><pre><code class="bash">cat ~/.ssh/id_rsa.pub# ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc....</code></pre><ol><li><p>添加公钥</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210813095618.png" alt="img"></p></li><li><p>测试</p></li></ol><pre><code class="bash">ssh -T git@gitee.comWelcome to Gitee.com, yourname! # 返回，说明正常</code></pre><ul><li>配置服务器node环境</li></ul><ol><li>安装nvm，服务器上使用nvm 方便多版本node切换</li></ol><pre><code class="bash">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bashvim /etc/profile#加入下面的内容export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;source /etc/profilenvm install stable # 安装稳定版nvm current # 查看当前的版本</code></pre><ol><li>配置相关的脚本<br> 安装gitee-webhook-handler(GitHub,GitLab,gitee 的包是不同的，不能混用)</li></ol><pre><code class="bash">mkdir /opt/webhook #创建目录cd /opt/webhooknpm init # 初始化项目，方便以后迁移npm install  gitee-webhook-handler --save # 当前的版本为v0.1.2</code></pre><ol><li>创建对应的webhook服务</li></ol><pre><code class="bash">vim webhook.jsvar http = require(&#39;http&#39;)var createHandler = require(&#39;gitee-webhook-handler&#39;)var handler = createHandler(&#123; path: &#39;/webhooks_push&#39;, secret: &#39;123456&#39; &#125;)# post 所需要用到的秘钥function run_cmd(cmd, args, callback) &#123;  var spawn = require(&#39;child_process&#39;).spawn;  var child = spawn(cmd, args);  var resp = &quot;&quot;;  child.stdout.on(&#39;data&#39;, function(buffer) &#123; resp += buffer.toString(); &#125;);  child.stdout.on(&#39;end&#39;, function() &#123; callback (resp) &#125;);&#125;handler.on(&#39;error&#39;, function (err) &#123;  console.error(&#39;Error:&#39;, err.message)&#125;)handler.on(&#39;Push Hook&#39;, function (event) &#123;  # 这个地方就是GitHub 和 Gitee 不一样的地方，需要注意  console.log(&#39;Received a push event for %s to %s&#39;,    event.payload.repository.name,    event.payload.ref);    run_cmd(&#39;sh&#39;, [&#39;./deploy.sh&#39;], function(text)&#123; console.log(text) &#125;);# 需要执行的脚本位置&#125;)try &#123;  http.createServer(function (req, res) &#123;    handler(req, res, function (err) &#123;      res.statusCode = 404      res.end(&#39;no such location&#39;)    &#125;)  &#125;).listen(6666) # 服务监听的端口，可以自行修改&#125;catch(err)&#123;  console.error(&#39;Error:&#39;, err.message)&#125;</code></pre><ol><li>创建需要执行的脚本</li></ol><pre><code class="bash">vim deploy.shgit pull xxxxx  # 根据自己的需要自行编写</code></pre><ol><li><p>测试服务</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210813095636.webp" alt="img"></p></li></ol><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210813095651.webp" alt="img"></p><p>显示ok，说明成功</p><h3 id="使用pm2应用进程管理器"><a href="#使用pm2应用进程管理器" class="headerlink" title="使用pm2应用进程管理器"></a>使用pm2应用进程管理器</h3><p>使用node 启动服务不是很方便，推荐使用pm2</p><pre><code class="bash">npm install -g pm2pm2 start webhook.jspm2 monit # 可以通过此命令查看服务的状态</code></pre><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210813095657.webp" alt="img"></p><p>上图显示了一些应用的基本信息，可以更好的观察到服务的状态</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>配置完成后，只要pull代码到仓库，就会触发webhook执行脚本，十分的方便，同时减少了工作量，相对采用轮询的方式消耗的资源更小。</p><p>参考：<a href="https://www.npmjs.com/package/gitee-webhook-handler">https://www.npmjs.com/package/gitee-webhook-handler</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器-前端性能优化CRP</title>
      <link href="/2021/07/21/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96CRP/"/>
      <url>/2021/07/21/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96CRP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>CRP(Critical [ˈkrɪtɪkl] Rendering [ˈrendərɪŋ] Path，关键渲染路径)</p><span id="more"></span><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>从用户输入 url 到显卡绘制，一共分为下面这几个步骤。</p><p>1、URl解析</p><p>2、DNS 解析</p><p>3、TCP/IP 三次握手</p><p>4、发送 HTTP 请求</p><p>5、服务器返回结果</p><p>6、TCP/IP 四次挥手</p><p>7、HTML解析，生成 DOM 树，CSS 生成 CSSOM 树，生成渲染树</p><p>8、将绘制任务交给显卡</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812144101.jpeg" alt="img"></p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h4 id="1-URI解析"><a href="#1-URI解析" class="headerlink" title="1 URI解析"></a>1 URI解析</h4><ul><li><p>地址解析和编码</p></li><li><p>HSTS （HTTP严格传输安全协议）</p></li><li><p>缓存检查</p></li><li><p>。。。</p><p>浏览器首先会看是否有缓存，若没有缓存，则浏览器会直接向服务器发送请求，然后服务器返回请求结果以及缓存标识，存入缓存,然后页面加载成功</p><p>如果有缓存，则看缓存是否过期(Expires 和 Cache-Control)，若缓存没过期，则直接读取缓存，然后返回缓存，最后页面加载成功</p><p>如果有缓存，但是缓存过期了，则需要携带标识(if-Modified-Since和if-None-Match),向服务器发送请求，此时服务器会查看资源是否有更新，（1）若没有更新，则返回304 状态码，继续使用缓存-&gt;读取缓存-&gt;返回缓存-&gt;页面加载成功；（2）若资源已经更新，则重新返回资源和缓存标识，返回状态码为200,并存入缓存中，最后页面加载成功</p></li></ul><h4 id="2-DNS解析"><a href="#2-DNS解析" class="headerlink" title="2 DNS解析"></a>2 DNS解析</h4><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812144400.webp" alt="img"></p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812144403.webp" alt="img"></p><h4 id="3-TCP-IP-三次握手"><a href="#3-TCP-IP-三次握手" class="headerlink" title="3 TCP/IP 三次握手"></a>3 TCP/IP 三次握手</h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/14/17212770500c8538~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h4 id="4-发送-HTTP-请求"><a href="#4-发送-HTTP-请求" class="headerlink" title="4 发送 HTTP 请求"></a>4 发送 HTTP 请求</h4><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812145003.png" alt="image-20210812144959118"></p><p>​    参考:<a href="https://www.sohu.com/a/161201715_714863">HTTP1.0、HTTP1.1和HTTP2.0的区别</a></p><h4 id="5-服务器返回结果"><a href="#5-服务器返回结果" class="headerlink" title="5 服务器返回结果"></a>5 服务器返回结果</h4><h4 id="6-TCP-IP-四次挥手"><a href="#6-TCP-IP-四次挥手" class="headerlink" title="6 TCP/IP 四次挥手"></a>6 TCP/IP 四次挥手</h4><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812145753.webp" alt="img"></p><h4 id="7-HTML解析，生成-DOM-树，CSS-生成-CSSOM-树，生成渲染树"><a href="#7-HTML解析，生成-DOM-树，CSS-生成-CSSOM-树，生成渲染树" class="headerlink" title="7 HTML解析，生成 DOM 树，CSS 生成 CSSOM 树，生成渲染树"></a>7 HTML解析，生成 DOM 树，CSS 生成 CSSOM 树，生成渲染树</h4><p>参考:<a href="/2021/03/22/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/">浏览器-页面渲染过程</a></p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="关键流程一：浏览器渲染流程"><a href="#关键流程一：浏览器渲染流程" class="headerlink" title="关键流程一：浏览器渲染流程"></a>关键流程一：浏览器渲染流程</h3><h4 id="1-构建DOM树、CSSOM树、渲染树、"><a href="#1-构建DOM树、CSSOM树、渲染树、" class="headerlink" title="1. 构建DOM树、CSSOM树、渲染树、"></a>1. 构建DOM树、CSSOM树、渲染树、</h4><ul><li>DOM树<ul><li>转换</li><li>令牌</li><li>词法分析</li><li>DOM构建</li></ul></li></ul><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812150300.webp" alt="img"></p><p>CSSOM 树</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812150257.webp" alt="img"></p><p>Render-Tree 渲染树</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812150253.webp" alt="img"></p><ul><li>总结步骤：<ul><li>处理 HTML 标记，构建 DOM 树</li><li>处理 CSS 标记，构建 CSSOM 树</li><li>将 DOM 树和 CSSOM 树融合成渲染树</li><li>根据生成的渲染树，计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流 =&gt; 布局（Layout）或 重排（reflow）</li><li>根据渲染树以及回流得到的几何信息，得到节点的绝对像素 =&gt; 绘制（painting）或栅格化（rasterizing）</li></ul></li></ul><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812150251.webp" alt="img"></p><ul><li><p>优化方案：</p><ul><li><p>标签语义化和避免深层次嵌套</p></li><li><p>CSS选择器渲染是从右到左</p></li><li><p>尽早尽快地把CSS下载到客户端（充分利用HTTP多请求并发机制）</p><ul><li>style</li><li>link</li><li>@import</li><li>放到顶部</li></ul></li><li><p>避免阻塞的JS加载</p><ul><li><p>放到底部</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812150245.webp" alt="img"></p></li></ul></li><li><p>减少DOM的回流和重绘</p></li></ul></li></ul><h4 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h4><h5 id="1-DOM的重绘和回流-Repaint-amp-Reflow"><a href="#1-DOM的重绘和回流-Repaint-amp-Reflow" class="headerlink" title="1. DOM的重绘和回流 Repaint &amp; Reflow"></a>1. DOM的重绘和回流 Repaint &amp; Reflow</h5><ul><li>重绘：元素样式的改变（但宽高、大小、位置等不变）<ul><li>如：outline, visibility, color, background-color等</li></ul></li><li>回流：元素的大小或者位置发生了变化（当页面布局和几何信息发生变化的时候），触发了重新布局，导致渲染树重新计算布局和渲染<ul><li>如添加或删除可见的DOM元素；元素的位置发生变化；元素的尺寸发生变化；内容发生变化（比如文本变化或者图片被另一个不同尺寸的图片所替代）；页面一开始渲染的时候（这个无法避免）；因为回流事根据视口的大小来计算元素的位置和大小的，所以浏览器的窗口尺寸变化也会引发回流。。。 <strong>注意：回流一定会触发重绘，而重绘不一定会回流</strong></li></ul></li></ul><h5 id="2-前端性能优化之：避免DOM的回流"><a href="#2-前端性能优化之：避免DOM的回流" class="headerlink" title="2. 前端性能优化之：避免DOM的回流"></a>2. 前端性能优化之：避免DOM的回流</h5><ul><li>放弃传统操作DOM的时代，基于vue/react开始数据影响视图模式<ul><li>mwm / mvc / virtual dom / dom diff …</li></ul></li><li>分离读写操作（现代的浏览器都有渲染队列的机制）<ul><li>offsetTop, offsetLeft, offsetWidth, offsetHeight, clientTop, clientLeft, clientWidth, clientHeight, scrollTop, scrollLeft, scrollWidth, scrollHeight, getComputedStyle, currentStyle… 会刷新渲染队列</li></ul></li><li>样式集中改变<ul><li>div.style.cssText = ‘width:20px;height:20px;’</li><li>div.className = ‘box’;</li></ul></li></ul><h5 id="前端性能优化之：避免DOM的回流"><a href="#前端性能优化之：避免DOM的回流" class="headerlink" title="前端性能优化之：避免DOM的回流"></a>前端性能优化之：避免DOM的回流</h5><ul><li>缓存布局信息<ul><li>div.style.left= div.offsetLeft + 1 + ‘px’; div.style.top = div.offsetTop + 1 + ‘px’; =&gt; 改写为: var curLeft = div.offsetLeft; var curTop = div.offsetTop; div.style.left = curLeft + 1 + ‘px’; div.style.top = curTop + 1 + ‘px’;</li></ul></li><li>元素批量修改<ul><li>文档碎片：createDocumentFragment</li><li>模版字符串拼接</li></ul></li><li>动画效果应用到position 属性为 absolute 或 fixed 的元素上（脱离文档流）</li><li>CSS3 硬件加速（GPU加速）<ul><li>比起考虑如何减少回流重绘，我们更期望的事，根本不要回流重绘；transform, opacity, filters… 这些属性会触发硬件加速，不会引发回流和重绘…</li><li>可能会引发的坑：过多使用会占用大量内存，性能消耗严重，有时候会导致字体模糊等</li></ul></li><li>牺牲平滑度换取速度<ul><li>每次1像素移动一个动画，但是如果此动画使用了100%的CPU，动画就会看上去事跳动的，因为浏览器正在与更新回流做斗争。每次移动3像素可能看起来平滑度低了，但它不会导致CPU 在较慢的机器中抖动</li></ul></li><li>避免 table 布局和使用 css 的 javascript 表达式</li></ul><h3 id="关键流程二：网络交互层面上的优化"><a href="#关键流程二：网络交互层面上的优化" class="headerlink" title="关键流程二：网络交互层面上的优化"></a>关键流程二：网络交互层面上的优化</h3><h5 id="1-DNS方面的优化"><a href="#1-DNS方面的优化" class="headerlink" title="1. DNS方面的优化"></a>1. DNS方面的优化</h5><blockquote><p>每一次DNS解析时间预计在20~120毫秒</p></blockquote><ul><li>减少DNS请求次数</li><li>DNS预获取（DNS Prefetch）</li></ul><pre><code>&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//static.360buyimg.com&quot;/&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//misc.360buyimg.com&quot;/&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//img10.360buyimg.com&quot;/&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//d.3.cn&quot;/&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//d.jd.com&quot;/&gt;复制代码</code></pre><h5 id="2-减少HTTP请求次数和请求资源大小"><a href="#2-减少HTTP请求次数和请求资源大小" class="headerlink" title="2. 减少HTTP请求次数和请求资源大小"></a>2. 减少HTTP请求次数和请求资源大小</h5><ul><li>资源合并压缩</li><li>字体图标</li><li>Base64</li><li>GZIP（一般的文件能压缩60%多）</li><li>图片懒加载</li><li>数据延迟分批加载</li><li>CDN资源</li><li>…</li></ul><h5 id="3-应用缓存"><a href="#3-应用缓存" class="headerlink" title="3. 应用缓存"></a>3. 应用缓存</h5><p><strong>缓存位置</strong></p><ul><li>Service Worker：浏览器独立线程进行缓存</li><li>Memory Cache : 内存缓存</li><li>Disk Cache：硬盘缓存</li><li>Push Cache：推送缓存（HTTP/2中的）</li></ul><p>打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配，如有则使用，如没有则发送网络请求。 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)，其次才是 disk cache。 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache)，服务器直接返回 200 和最新内容。</p><p><strong>强缓存 Expires / Cache-Control</strong></p><blockquote><p>浏览器对于强缓存的处理：根据第一次请求资源时返回的响应头来确定的</p></blockquote><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812150237.webp" alt="img"></p><ul><li>Expires：缓存过期时间，用来指定资源到期的时间（HTTP/1）</li><li>Cache-Control：cache-control: max-age=2592000第一次拿到资源后的2592000秒内（30天），再次发送请求，读取缓存中的信息（HTTP/1.1）</li></ul><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812150234.webp" alt="img"></p><p>两者同时存在的话，Cache-Control优先级高于Expires</p><p><strong>协商缓存 Last-Modified / ETag</strong></p><blockquote><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</p></blockquote><ul><li>协商缓存生效，返回304和Not Modified</li></ul><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812150231.webp" alt="img"></p><ul><li>协商缓存失效，返回200和请求结果</li></ul><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812150227.webp" alt="img"></p><ol><li>Last-Modified和If-Modified-Since 第一次访问资源，服务器返回资源的同时，响应头中设置 Last-Modified（服务器上的最后修改时间），浏览器接收后，缓存文件和响应头； 下一次请求这个资源，浏览器检测到有 Last-Modified，于是添加If-Modified-Since请求头，值就是Last-Modified中的值； 服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200； 但是Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源；</li><li>ETag和If-None-Match Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成；下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到请求头If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。</li></ol><p><strong>数据缓存：LocalStorage本地存储</strong></p><hr><p>参考文章:<a href="https://juejin.cn/post/6844904159083233293">掘金文章:深度剖析前端性能优化CRP</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6-Generator</title>
      <link href="/2021/07/15/%E5%89%8D%E7%AB%AF/es6/es6-Generator/"/>
      <url>/2021/07/15/%E5%89%8D%E7%AB%AF/es6/es6-Generator/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同</p><span id="more"></span><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210715155400.webp" alt="图片"></p><p>回顾下上文提到的解决异步的手段：</p><ul><li>回调函数</li><li>promise</li></ul><p>那么，上文我们提到<code>promsie</code>已经是一种比较流行的解决异步方案，那么为什么还出现<code>Generator</code>？甚至<code>async/await</code>呢？</p><p>该问题我们留在后面再进行分析，下面先认识下<code>Generator</code></p><h3 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h3><p>执行 <code>Generator</code> 函数会返回一个遍历器对象，可以依次遍历 <code>Generator</code> 函数内部的每一个状态</p><p>形式上，<code>Generator</code>函数是一个普通函数，但是有两个特征：</p><ul><li><code>function</code>关键字与函数名之间有一个星号</li><li>函数体内部使用<code>yield</code>表达式，定义不同的内部状态</li></ul><pre><code>function* helloWorldGenerator() &#123;  yield &#39;hello&#39;;  yield &#39;world&#39;;  return &#39;ending&#39;;&#125;</code></pre><h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><p><code>Generator</code> 函数会返回一个遍历器对象，即具有<code>Symbol.iterator</code>属性，并且返回给自己</p><pre><code>function* gen()&#123;  // some code&#125;var g = gen();g[Symbol.iterator]() === g// true</code></pre><p>通过<code>yield</code>关键字可以暂停<code>generator</code>函数返回的遍历器对象的状态</p><pre><code>function* helloWorldGenerator() &#123;  yield &#39;hello&#39;;  yield &#39;world&#39;;  return &#39;ending&#39;;&#125;var hw = helloWorldGenerator();</code></pre><p>上述存在三个状态：<code>hello</code>、<code>world</code>、<code>return</code></p><p>通过<code>next</code>方法才会遍历到下一个内部状态，其运行逻辑如下：</p><ul><li>遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。</li><li>下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式</li><li>如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</li><li>如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code></li></ul><pre><code>hw.next()// &#123; value: &#39;hello&#39;, done: false &#125;hw.next()// &#123; value: &#39;world&#39;, done: false &#125;hw.next()// &#123; value: &#39;ending&#39;, done: true &#125;hw.next()// &#123; value: undefined, done: true &#125;</code></pre><p><code>done</code>用来判断是否存在下个状态，<code>value</code>对应状态值</p><pre><code>yield`表达式本身没有返回值，或者说总是返回`undefined</code></pre><p>通过调用<code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值</p><pre><code>function* foo(x) &#123;  var y = 2 * (yield (x + 1));  var z = yield (y / 3);  return (x + y + z);&#125;var a = foo(5);a.next() // Object&#123;value:6, done:false&#125;a.next() // Object&#123;value:NaN, done:false&#125;a.next() // Object&#123;value:NaN, done:true&#125;var b = foo(5);b.next() // &#123; value:6, done:false &#125;b.next(12) // &#123; value:8, done:false &#125;b.next(13) // &#123; value:42, done:true &#125;</code></pre><p>正因为<code>Generator</code>函数返回<code>Iterator</code>对象，因此我们还可以通过<code>for...of</code>进行遍历</p><pre><code>function* foo() &#123;  yield 1;  yield 2;  yield 3;  yield 4;  yield 5;  return 6;&#125;for (let v of foo()) &#123;  console.log(v);&#125;// 1 2 3 4 5</code></pre><p>原生对象没有遍历接口，通过<code>Generator</code>函数为它加上这个接口，就能使用<code>for...of</code>进行遍历了</p><pre><code>function* objectEntries(obj) &#123;  let propKeys = Reflect.ownKeys(obj);  for (let propKey of propKeys) &#123;    yield [propKey, obj[propKey]];  &#125;&#125;let jane = &#123; first: &#39;Jane&#39;, last: &#39;Doe&#39; &#125;;for (let [key, value] of objectEntries(jane)) &#123;  console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe</code></pre><h2 id="三、异步解决方案"><a href="#三、异步解决方案" class="headerlink" title="三、异步解决方案"></a>三、异步解决方案</h2><p>回顾之前展开异步解决的方案：</p><ul><li>回调函数</li><li>Promise 对象</li><li>generator 函数</li><li>async/await</li></ul><p>这里通过文件读取案例，将几种解决异步的方案进行一个比较：</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，再调用这个函数</p><pre><code>fs.readFile(&#39;/etc/fstab&#39;, function (err, data) &#123;  if (err) throw err;  console.log(data);  fs.readFile(&#39;/etc/shells&#39;, function (err, data) &#123;    if (err) throw err;    console.log(data);  &#125;);&#125;);</code></pre><p><code>readFile</code>函数的第三个参数，就是回调函数，等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p><code>Promise</code>就是为了解决回调地狱而产生的，将回调函数的嵌套，改成链式调用</p><pre><code>const fs = require(&#39;fs&#39;);const readFile = function (fileName) &#123;  return new Promise(function (resolve, reject) &#123;    fs.readFile(fileName, function(error, data) &#123;      if (error) return reject(error);      resolve(data);    &#125;);  &#125;);&#125;;readFile(&#39;/etc/fstab&#39;).then(data =&gt;&#123;    console.log(data)    return readFile(&#39;/etc/shells&#39;)&#125;).then(data =&gt; &#123;    console.log(data)&#125;)</code></pre><p>这种链式操作形式，使异步任务的两段执行更清楚了，但是也存在了很明显的问题，代码变得冗杂了，语义化并不强</p><h3 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h3><p><code>yield</code>表达式可以暂停函数执行，<code>next</code>方法用于恢复函数执行，这使得<code>Generator</code>函数非常适合将异步任务同步化</p><pre><code>const gen = function* () &#123;  const f1 = yield readFile(&#39;/etc/fstab&#39;);  const f2 = yield readFile(&#39;/etc/shells&#39;);  console.log(f1.toString());  console.log(f2.toString());&#125;;</code></pre><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>将上面<code>Generator</code>函数改成<code>async/await</code>形式，更为简洁，语义化更强了</p><pre><code>const asyncReadFile = async function () &#123;  const f1 = await readFile(&#39;/etc/fstab&#39;);  const f2 = await readFile(&#39;/etc/shells&#39;);  console.log(f1.toString());  console.log(f2.toString());&#125;;</code></pre><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><p>通过上述代码进行分析，将<code>promise</code>、<code>Generator</code>、<code>async/await</code>进行比较：</p><ul><li><code>promise</code>和<code>async/await</code>是专门用于处理异步操作的</li><li><code>Generator</code>并不是为异步而设计出来的，它还有其他功能（对象迭代、控制输出、部署<code>Interator</code>接口…）</li><li><code>promise</code>编写代码相比<code>Generator</code>、<code>async</code>更为复杂化，且可读性也稍差</li><li><code>Generator</code>、<code>async</code>需要与<code>promise</code>对象搭配处理异步情况</li><li><code>async</code>实质是<code>Generator</code>的语法糖，相当于会自动执行<code>Generator</code>函数</li><li><code>async</code>使用上更为简洁，将异步代码以同步的形式进行编写，是处理异步编程的最终方案</li></ul><h2 id="四、使用场景"><a href="#四、使用场景" class="headerlink" title="四、使用场景"></a>四、使用场景</h2><p><code>Generator</code>是异步解决的一种方案，最大特点则是将异步操作同步化表达出来</p><pre><code>function* loadUI() &#123;  showLoadingScreen();  yield loadUIDataAsynchronously();  hideLoadingScreen();&#125;var loader = loadUI();// 加载UIloader.next()// 卸载UIloader.next()</code></pre><p>包括<code>redux-saga</code>中间件也充分利用了<code>Generator</code>特性</p><pre><code>import &#123; call, put, takeEvery, takeLatest &#125; from &#39;redux-saga/effects&#39;import Api from &#39;...&#39;function* fetchUser(action) &#123;   try &#123;      const user = yield call(Api.fetchUser, action.payload.userId);      yield put(&#123;type: &quot;USER_FETCH_SUCCEEDED&quot;, user: user&#125;);   &#125; catch (e) &#123;      yield put(&#123;type: &quot;USER_FETCH_FAILED&quot;, message: e.message&#125;);   &#125;&#125;function* mySaga() &#123;  yield takeEvery(&quot;USER_FETCH_REQUESTED&quot;, fetchUser);&#125;function* mySaga() &#123;  yield takeLatest(&quot;USER_FETCH_REQUESTED&quot;, fetchUser);&#125;export default mySaga;</code></pre><p>还能利用<code>Generator</code>函数，在对象上实现<code>Iterator</code>接口</p><pre><code>function* iterEntries(obj) &#123;  let keys = Object.keys(obj);  for (let i=0; i &lt; keys.length; i++) &#123;    let key = keys[i];    yield [key, obj[key]];  &#125;&#125;let myObj = &#123; foo: 3, bar: 7 &#125;;for (let [key, value] of iterEntries(myObj)) &#123;  console.log(key, value);&#125;// foo 3// bar 7</code></pre><hr><p>文章来源:<a href="https://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw==&mid=2247485195&idx=1&sn=f0c7f093abb606c01232c80e1ad0c89e&chksm=fc10c55dcb674c4bb6dbb864233c0dad43b4fb09dfc54775978319888ae3f6ff5454aeba7e1a&scene=21#wechat_redirect">微信公众号文章:怎么理解ES6中 Generator的？使用场景？</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-diff算法</title>
      <link href="/2021/07/14/%E5%89%8D%E7%AB%AF/vue/vue-diff%E7%AE%97%E6%B3%95/"/>
      <url>/2021/07/14/%E5%89%8D%E7%AB%AF/vue/vue-diff%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>diff算法的本质是找出两个对象之间的差异，目的是尽可能复用节点。</p><span id="more"></span><h2 id="引一-virtual-dom"><a href="#引一-virtual-dom" class="headerlink" title="引一 virtual dom"></a>引一 virtual dom</h2><ol><li>template</li><li>渲染函数</li><li>vnode(virtual dom)</li><li>patch(diff算法)</li><li>view</li></ol><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812140209.png" alt="3a0a37c86e541c31d2c3ed3884ae6308.png"></p><ul><li>Vue.js通过编译将template 模板转换成渲染函数(render ) ，执行渲染函数就可以得到一个虚拟节点树</li><li>VNode 虚拟节点：它可以代表一个真实的 dom 节点。通过 createElement 方法能将 VNode 渲染成 dom 节点。简单地说，vnode可以理解成节点描述对象，它描述了应该怎样去创建真实的DOM节点。</li><li>patch(也叫做patching算法)：虚拟DOM最核心的部分，它可以将vnode渲染成真实的DOM，这个过程是对比新旧虚拟节点之间有哪些不同，然后根据对比结果找出需要更新的的节点进行更新。这点我们从单词含义就可以看出， patch本身就有补丁、修补的意思，其实际作用是在现有DOM上进行修改来实现更新视图的目的。Vue的Virtual DOM Patching算法是基于Snabbdom的实现，并在些基础上作了很多的调整和改进。</li></ul><h3 id="什么是virtual-dom"><a href="#什么是virtual-dom" class="headerlink" title="什么是virtual dom"></a><strong>什么是virtual dom</strong></h3><p>通俗易懂的来说就是用一个简单的对象去代替复杂的dom对象。</p><p>如果你去打印一下一个真实的DOM节点，就会发现DOM节点上有很多属性，如果Vue每次都生成一个新的真实DOM节点，对性能是巨大的浪费。</p><p>Virtual DOM 实际上就是以JavaScript对象(VNode )为基础形成一棵树，对真实DOM的一层抽象。Vue最终的工作就是通过这棵树批量生成真实的DOM节，可以说两者存在一层映射关系。</p><p>简单来说，可以把Virtual DOM 理解为一个简单的JS对象，并且最少包含标签名( tag)、属性(attrs)和子元素对象( children)三个属性。不同的框架对这三个属性的命名会有点差别。</p><p>对于虚拟DOM，咱们来看一个简单的实例，就是下图所示的这个，详细的阐述了模板 → 渲染函数 → 虚拟DOM树 → 真实DOM的一个过程</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812140224.png" alt="dbc527b02888fdd4be3860945e85fa02.png"></p><p>其实虚拟DOM在Vue.js主要做了两件事：</p><ul><li>提供与真实DOM节点所对应的虚拟节点vnode</li><li>将虚拟节点vnode和旧虚拟节点oldVnode进行对比(diff算法)，然后更新视图</li></ul><p>总结：<strong>「vdom是为了减轻性能压力。dom是昂贵的，昂贵的一方面在dom本身的重量，dom节点在js里的描述是个非常复杂属性很多原型很长的超级对象，另一方面是浏览器渲染进程和js进程是独立分离的，操作dom时的通信和浏览器本身需要重绘的时耗都是很高的。所以大家机智的搞了个轻量的vdom去模拟dom，vdom每个节点都只挂载js操作的必要属性，每次组件update时都先操作vdom，通过vdom的比对，得到一个真实dom的需要操作的集合。整个机制是在JavaScript层面计算，在完成之前并不会操作DOM，等数据稳定之后再实现精准的修改。」</strong></p><h2 id="引二-分析diff算法"><a href="#引二-分析diff算法" class="headerlink" title="引二 分析diff算法"></a>引二 分析diff算法</h2><p>由上我们知道了，新的虚拟DOM和旧的虚拟DOm是通过diff算法进行比较之后更新的。</p><h3 id="Vue2-x-diff算法"><a href="#Vue2-x-diff算法" class="headerlink" title="Vue2.x diff算法"></a><strong>Vue2.x diff算法</strong></h3><h3 id="Vue2-x-diff算法原理"><a href="#Vue2-x-diff算法原理" class="headerlink" title="Vue2.x diff算法原理"></a><strong>Vue2.x diff算法原理</strong></h3><p>传统diff算法通过循环递归对节点进行依次对比效率低下，算法复杂度达到O(N^3)，主要原因在于其追求完全比对和最小修改，而React、Vue则是放弃了完全比对及最小修改，才实现从O(N^3) =&gt; O(N)。</p><p>优化措施有：</p><ul><li><strong>「分层diff」</strong>：不考虑跨层级移动节点，让新旧两个VDOM树的比对无需循环递归(复杂度大幅优化，直接下降一个数量级的首要条件)。这个前提也是Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。</li></ul><p>在同层节点中，采用了<strong>「双端比较的算法」</strong>过程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较；</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812140235.png" alt="13ce1945ff1e74d43467f5c3ef82b16f.png"></p><p>当发生以下情况则跳过比对，变为插入或删除操作：</p><ul><li><strong>「组件的Type(Tagname)不一致」</strong>，原因是绝大多数情况拥有相同type的两个组件将会生成相似的树形结构，拥有不同type的两个组件将会生成不同的树形结构，所以type不一致可以放弃继续比对。</li><li><strong>「列表组件的Key不一致」</strong>，旧树中无新Key或反之。毕竟key是元素的身份id，能直接对应上是否是同一个节点。</li><li>对触发了getter/setter 的组件进行diff，精准减少diff范围</li></ul><h3 id="Vue3-0-diff"><a href="#Vue3-0-diff" class="headerlink" title="Vue3.0 diff"></a><strong>Vue3.0 diff</strong></h3><h4 id="diff痛点"><a href="#diff痛点" class="headerlink" title="diff痛点"></a><strong>diff痛点</strong></h4><p>vue2.x中的虚拟dom是进行<strong>「全量的对比」</strong>，在运行时会对所有节点生成一个虚拟节点树，当页面数据发生变更好，会遍历判断virtual dom所有节点(包括一些不会变化的节点)有没有发生变化；虽然说diff算法确实减少了多DOM节点的直接操作，但是这个<strong>「减少是有成本的」</strong>，如果是复杂的大型项目，必然存在很复杂的父子关系的VNode,<strong>「而Vue2.x的diff算法，会不断地递归调用 patchVNode，不断堆叠而成的几毫秒，最终就会造成 VNode 更新缓慢」</strong>。</p><p>那么Vue3.0是如何解决这些问题的呢</p><h5 id="动静结合-PatchFlag"><a href="#动静结合-PatchFlag" class="headerlink" title="动静结合 PatchFlag"></a><strong>动静结合 PatchFlag</strong></h5><p>在Vue3.0中，在这个模版编译时，编译器会在动态标签末尾加上 /* Text*/ PatchFlag。<strong>「也就是在生成VNode的时候，同时打上标记，在这个基础上再进行核心的diff算法」</strong>并且 PatchFlag 会标识动态的属性类型有哪些，比如这里 的TEXT 表示只有节点中的文字是动态的。而patchFlag的类型也很多。这里直接引用一张图片。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812140246.png" alt="21d07297b28cf0c636daa79431065f2a.png"></p><p>其中大致可以分为两类：</p><ul><li>当 patchFlag 的值「大于」 0 时，代表所对应的元素在 patchVNode 时或 render 时是可以被优化生成或更新的。</li><li>当 patchFlag 的值「小于」 0 时，代表所对应的元素在 patchVNode 时，是需要被 full diff，即进行递归遍历 VNode tree 的比较更新过程。</li></ul><p>看源码：</p><pre><code>export function render(_ctx, _cache, $props, $setup, $data, $options) &#123; return (_openBlock(), _createBlock(&quot;div&quot;, null, [  _createVNode(&quot;p&quot;, null, &quot;&#39;HelloWorld&#39;&quot;),  _createVNode(&quot;p&quot;, null, _toDisplayString(_ctx.msg), 1 /* TEXT */)  ]))&#125;****</code></pre><p>这里的<code>_createVNode(&quot;p&quot;, null, _toDisplayString(_ctx.msg), 1 /* TEXT */)</code>就是对变量节点进行标记。</p><p>总结：<strong>「Vue3.0对于不参与更新的元素，做静态标记并提示，只会被创建一次，在渲染时直接复用。」</strong></p><p>可参考<a href="https://blog.csdn.net/qq_45613931/article/details/109470718">CSDN文章:Vue3的diff算法优化部分</a></p><hr><h2 id="一-什么时候用到了diff算法-diff算法作用域？"><a href="#一-什么时候用到了diff算法-diff算法作用域？" class="headerlink" title="一 什么时候用到了diff算法,diff算法作用域？"></a>一 什么时候用到了diff算法,diff算法作用域？</h2><h3 id="1-1diff算法的作用域"><a href="#1-1diff算法的作用域" class="headerlink" title="1.1diff算法的作用域"></a>1.1diff算法的作用域</h3><p><strong>patch概念引入</strong></p><p>在vue update过程中在遍历子代vnode的过程中，会用不同的patch方法来patch新老vnode，如果找到对应的 newVnode 和 oldVnode,就可以复用利用里面的真实dom节点。避免了重复创建元素带来的性能开销。毕竟浏览器创造真实的dom，操纵真实的dom，性能代价是昂贵的。</p><p>patch过程中，如果面对当前vnode存在有很多chidren的情况,那么需要分别遍历patch新的children Vnode和老的 children vnode。</p><p><strong>存在chidren的vnode类型</strong></p><p>首先思考一下什么类型的vnode会存在children。</p><p><strong>①element元素类型vnode</strong></p><p>第一中情况就是element类型vnode 会存在 children vode，此时的三个span标签就是chidren vnode情况</p><pre><code>&lt;div&gt;   &lt;span&gt; 苹果🍎 &lt;/span&gt;    &lt;span&gt; 香蕉🍌 &lt;/span&gt;   &lt;span&gt; 鸭梨🍐 &lt;/span&gt;&lt;/div&gt;</code></pre><p><strong>在vue3.0源码中 ，patchElement用于处理element类型的vnode</strong></p><p><strong>②flagment碎片类型vnode</strong></p><p>在Vue3.0中，引入了一个fragment碎片概念。<br>你可能会问，什么是碎片？如果你创建一个Vue组件，那么它只能有一个根节点。</p><pre><code>&lt;template&gt;   &lt;span&gt; 苹果🍎 &lt;/span&gt;    &lt;span&gt; 香蕉🍌 &lt;/span&gt;   &lt;span&gt; 鸭梨🍐 &lt;/span&gt;&lt;/template&gt;</code></pre><p>这样可能会报出警告，原因是代表任何Vue组件的Vue实例需要绑定到一个单一的DOM元素中。唯一可以创建一个具有多个DOM节点的组件的方法就是创建一个没有底层Vue实例的功能组件。</p><p>flagment出现就是用看起来像一个普通的DOM元素，但它是虚拟的，根本不会在DOM树中呈现。这样我们可以将组件功能绑定到一个单一的元素中，而不需要创建一个多余的DOM节点。</p><pre><code> &lt;Fragment&gt;   &lt;span&gt; 苹果🍎 &lt;/span&gt;    &lt;span&gt; 香蕉🍌 &lt;/span&gt;   &lt;span&gt; 鸭梨🍐 &lt;/span&gt;&lt;/Fragment&gt;</code></pre><p><strong>在vue3.0源码中 ，processFragment用于处理Fragment类型的vnode</strong></p><h3 id="1-2-patchChildren"><a href="#1-2-patchChildren" class="headerlink" title="1.2 patchChildren"></a>1.2 patchChildren</h3><p>从上文中我们得知了存在children的vnode类型，那么存在children就需要patch每一个<br>children vnode依次向下遍历。那么就需要一个patchChildren方法，依次patch子类vnode。</p><p><strong>patchChildren</strong></p><p>vue3.0中 在patchChildren方法中有这么一段源码</p><pre><code>if (patchFlag &gt; 0) &#123;      if (patchFlag &amp; PatchFlags.KEYED_FRAGMENT) &#123;          /* 对于存在key的情况用于diff算法 */        patchKeyedChildren(          c1 as VNode[],          c2 as VNodeArrayChildren,          container,          anchor,          parentComponent,          parentSuspense,          isSVG,          optimized        )        return      &#125; else if (patchFlag &amp; PatchFlags.UNKEYED_FRAGMENT) &#123;         /* 对于不存在key的情况,直接patch  */        patchUnkeyedChildren(           c1 as VNode[],          c2 as VNodeArrayChildren,          container,          anchor,          parentComponent,          parentSuspense,          isSVG,          optimized        )        return      &#125;    &#125;</code></pre><p><strong>patchChildren根据是否存在key进行真正的diff或者直接patch。</strong></p><p><strong>既然diff算法存在patchChildren方法中，而patchChildren方法用在Fragment类型和element类型的vnode中，这样也就解释了diff算法的作用域是什么。</strong></p><h3 id="1-3-diff算法作用？"><a href="#1-3-diff算法作用？" class="headerlink" title="1.3 diff算法作用？"></a>1.3 diff算法作用？</h3><p>通过前言我们知道，存在这children的情况的vnode，需要通过patchChildren遍历children依次进行patch操作，如果在patch期间，再发现存在vnode情况，那么会递归的方式依次向下patch，那么找到与新的vnode对应的vnode显的如此重要。</p><p>我们用两幅图来向大家展示vnode变化。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812140257.jpeg" alt="WechatIMG13940.jpeg"><br><img src="http://cdn.tangyuxian.com/PicGoImages/20210812140303.jpeg" alt="WechatIMG13941.jpeg"></p><p>如上两幅图表示在一次更新中新老dom树变化情况。</p><p><strong>假设不存在diff算法，依次按照先后顺序patch会发生什么</strong></p><p>如果<strong>不存在diff算法</strong>，而是直接patchchildren 就会出现如下图的逻辑。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812140311.jpeg" alt="WechatIMG13942.jpeg"></p><p><strong>第一次patchChidren</strong></p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812140320.jpeg" alt="WechatIMG13943.jpeg"></p><p><strong>第二次patchChidren</strong></p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812140325.jpeg" alt="WechatIMG13944.jpeg"></p><p><strong>第三次patchChidren</strong>‘</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812140331.jpeg" alt="WechatIMG13945.jpeg"></p><p><strong>第四次patchChidren</strong></p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812140336.jpeg" alt="WechatIMG13947.jpeg"><br>如果没有用到diff算法，而是依次patch虚拟dom树，那么如上稍微<strong>修改dom顺序</strong>，就会在patch过程中没有一对正确的新老vnode，所以老vnode的节点没有一个可以复用，这样就需要重新创造新的节点，浪费了性能开销，这显然不是我们需要的。</p><p>那么diff算法的作用就来了。</p><p><strong>diff作用就是在patch子vnode过程中，找到与新vnode对应的老vnode，复用真实的dom节点，避免不必要的性能开销</strong></p><h2 id="二-diff算法具体做了什么-重点-？"><a href="#二-diff算法具体做了什么-重点-？" class="headerlink" title="二 diff算法具体做了什么(重点)？"></a>二 diff算法具体做了什么(重点)？</h2><p>在正式讲diff算法之前，在patchChildren的过程中，存在 <strong>patchKeyedChildren</strong><br><strong>patchUnkeyedChildren</strong></p><p>patchKeyedChildren 是正式的开启diff的流程，那么patchUnkeyedChildren的作用是什么呢？ 我们来看看针对没有key的情况patchUnkeyedChildren会做什么。</p><pre><code> c1 = c1 || EMPTY_ARR    c2 = c2 || EMPTY_ARR    const oldLength = c1.length    const newLength = c2.length    const commonLength = Math.min(oldLength, newLength)    let i    for (i = 0; i &lt; commonLength; i++) &#123; /* 依次遍历新老vnode进行patch */      const nextChild = (c2[i] = optimized        ? cloneIfMounted(c2[i] as VNode)        : normalizeVNode(c2[i]))      patch(        c1[i],        nextChild,        container,        null,        parentComponent,        parentSuspense,        isSVG,        optimized      )    &#125;    if (oldLength &gt; newLength) &#123; /* 老vnode 数量大于新的vnode，删除多余的节点 */      unmountChildren(c1, parentComponent, parentSuspense, true, commonLength)    &#125; else &#123; /* /* 老vnode 数量小于于新的vnode，创造新的即诶安 */      mountChildren(        c2,        container,        anchor,        parentComponent,        parentSuspense,        isSVG,        optimized,        commonLength      )    &#125;</code></pre><p>我们可以得到结论，对于不存在key情况<br><strong>① 比较新老children的length获取最小值 然后对于公共部分，进行从新patch工作。</strong><br><strong>② 如果老节点数量大于新的节点数量 ，移除多出来的节点。</strong><br><strong>③ 如果新的节点数量大于老节点的数量，从新 mountChildren新增的节点。</strong></p><p>那么对于存在key情况呢？ 会用到diff算法 ， diff算法做了什么呢？</p><p><strong>patchKeyedChildren方法究竟做了什么？</strong><br>我们先来看看一些声明的变量。</p><pre><code>    /*  c1 老的vnode c2 新的vnode  */    let i = 0              /* 记录索引 */    const l2 = c2.length   /* 新vnode的数量 */    let e1 = c1.length - 1 /* 老vnode 最后一个节点的索引 */    let e2 = l2 - 1        /* 新节点最后一个节点的索引 */</code></pre><h3 id="①第一步从头开始向尾寻找"><a href="#①第一步从头开始向尾寻找" class="headerlink" title="①第一步从头开始向尾寻找"></a>①第一步从头开始向尾寻找</h3><p>(a b) c<br>(a b) d e</p><pre><code> /* 从头对比找到有相同的节点 patch ，发现不同，立即跳出*/    while (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;      const n1 = c1[i]      const n2 = (c2[i] = optimized        ? cloneIfMounted(c2[i] as VNode)        : normalizeVNode(c2[i]))        /* 判断key ，type是否相等 */      if (isSameVNodeType(n1, n2)) &#123;        patch(          n1,          n2,          container,           parentAnchor,          parentComponent,          parentSuspense,          isSVG,          optimized        )      &#125; else &#123;        break      &#125;      i++    &#125;</code></pre><p>第一步的事情就是从头开始寻找相同的vnode，然后进行patch,如果发现不是相同的节点，那么立即跳出循环。</p><p>具体流程如图所示</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812140345.jpeg" alt="在这里插入图片描述"></p><p><strong>isSameVNodeType</strong></p><pre><code>export function isSameVNodeType(n1: VNode, n2: VNode): boolean &#123;  return n1.type === n2.type &amp;&amp; n1.key === n2.key&#125;</code></pre><p>isSameVNodeType 作用就是判断当前vnode类型 和 vnode的 key是否相等</p><h3 id="②第二步从尾开始同前diff"><a href="#②第二步从尾开始同前diff" class="headerlink" title="②第二步从尾开始同前diff"></a>②第二步从尾开始同前diff</h3><p>a (b c)<br>d e (b c)</p><pre><code class="javascript"> /* 如果第一步没有patch完，立即，从后往前开始patch ,如果发现不同立即跳出循环 */    while (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;      const n1 = c1[e1]      const n2 = (c2[e2] = optimized        ? cloneIfMounted(c2[e2] as VNode)        : normalizeVNode(c2[e2]))      if (isSameVNodeType(n1, n2)) &#123;        patch(          n1,          n2,          container,          parentAnchor,          parentComponent,          parentSuspense,          isSVG,          optimized        )      &#125; else &#123;        break      &#125;      e1--      e2--    &#125;</code></pre><p>经历第一步操作之后，如果发现没有patch完，那么立即进行第二部，从尾部开始遍历依次向前diff。</p><p>如果发现不是相同的节点，那么立即跳出循环。</p><p>具体流程如图所示<br><img src="http://cdn.tangyuxian.com/PicGoImages/20210812140351.jpeg" alt="WechatIMG13952.jpeg"></p><p><strong>③④主要针对新增和删除元素的情况，前提是元素没有发生移动， 如果有元素发生移动就要走⑤逻辑。</strong></p><h3 id="③-如果老节点是否全部patch，新节点没有被patch完-创建新的vnode"><a href="#③-如果老节点是否全部patch，新节点没有被patch完-创建新的vnode" class="headerlink" title="③ 如果老节点是否全部patch，新节点没有被patch完,创建新的vnode"></a>③ 如果老节点是否全部patch，新节点没有被patch完,创建新的vnode</h3><p>(a b)<br>(a b) c<br>i = 2, e1 = 1, e2 = 2<br>(a b)<br>c (a b)<br>i = 0, e1 = -1, e2 = 0</p><pre><code>/* 如果新的节点大于老的节点数 ，对于剩下的节点全部以新的vnode处理（ 这种情况说明已经patch完相同的vnode  ） */    if (i &gt; e1) &#123;      if (i &lt;= e2) &#123;        const nextPos = e2 + 1        const anchor = nextPos &lt; l2 ? (c2[nextPos] as VNode).el : parentAnchor        while (i &lt;= e2) &#123;          patch( /* 创建新的节点*/            null,            (c2[i] = optimized              ? cloneIfMounted(c2[i] as VNode)              : normalizeVNode(c2[i])),            container,            anchor,            parentComponent,            parentSuspense,            isSVG          )          i++        &#125;      &#125;    &#125;</code></pre><p><strong>i &gt; e1</strong></p><p>如果新的节点大于老的节点数 ，对于剩下的节点全部以新的vnode处理（ 这种情况说明已经patch完相同的vnode ），也就是要全部create新的vnode.</p><p>具体逻辑如图所示<br><img src="http://cdn.tangyuxian.com/PicGoImages/20210812140358.jpeg" alt="WechatIMG13955.jpeg"></p><h3 id="④-如果新节点全部被patch，老节点有剩余，那么卸载所有老节点"><a href="#④-如果新节点全部被patch，老节点有剩余，那么卸载所有老节点" class="headerlink" title="④ 如果新节点全部被patch，老节点有剩余，那么卸载所有老节点"></a>④ 如果新节点全部被patch，老节点有剩余，那么卸载所有老节点</h3><p><strong>i &gt; e2</strong><br>(a b) c<br>(a b)<br>i = 2, e1 = 2, e2 = 1<br>a (b c)<br>(b c)<br>i = 0, e1 = 0, e2 = -1</p><pre><code>else if (i &gt; e2) &#123;   while (i &lt;= e1) &#123;      unmount(c1[i], parentComponent, parentSuspense, true)      i++   &#125;&#125;</code></pre><p>对于老的节点大于新的节点的情况 ，对于超出的节点全部卸载 （ 这种情况说明已经patch完相同的vnode ）</p><p>具体逻辑如图所示<br><img src="http://cdn.tangyuxian.com/PicGoImages/20210812140404.jpeg" alt="WechatIMG13956.jpeg"></p><h3 id="⑤-不确定的元素-（-这种情况说明没有patch完相同的vnode-），我们可以接着①②的逻辑继续往下看"><a href="#⑤-不确定的元素-（-这种情况说明没有patch完相同的vnode-），我们可以接着①②的逻辑继续往下看" class="headerlink" title="⑤ 不确定的元素 （ 这种情况说明没有patch完相同的vnode ），我们可以接着①②的逻辑继续往下看"></a>⑤ 不确定的元素 （ 这种情况说明没有patch完相同的vnode ），我们可以接着①②的逻辑继续往下看</h3><p><strong>diff核心</strong></p><p>在①②情况下没有遍历完的节点如下图所示。<br><img src="http://cdn.tangyuxian.com/PicGoImages/20210812140410.jpeg" alt="WechatIMG13957.jpeg"></p><p>剩下的节点。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812140418.jpeg" alt="WechatIMG13953.jpeg"></p><pre><code class="javascript">      const s1 = i  //第一步遍历到的index      const s2 = i       const keyToNewIndexMap: Map&lt;string | number, number&gt; = new Map()      /* 把没有比较过的新的vnode节点,通过map保存 */      for (i = s2; i &lt;= e2; i++) &#123;        if (nextChild.key != null) &#123;          keyToNewIndexMap.set(nextChild.key, i)        &#125;      &#125;      let j      let patched = 0       const toBePatched = e2 - s2 + 1 /* 没有经过 path 新的节点的数量 */      let moved = false /* 证明是否 */      let maxNewIndexSoFar = 0       const newIndexToOldIndexMap = new Array(toBePatched)       for (i = 0; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = 0      /* 建立一个数组，每个子元素都是0 [ 0, 0, 0, 0, 0, 0, ] */ </code></pre><p>遍历所有新节点把索引和对应的key,存入map keyToNewIndexMap中</p><p><strong>keyToNewIndexMap</strong> 存放 key -&gt; index 的map</p><p><strong>D : 2</strong><br><strong>E : 3</strong><br><strong>C : 4</strong><br><strong>I : 5</strong></p><p>接下来声明一个新的指针 <strong>j</strong>,记录剩下新的节点的索引。<br><strong>patched</strong> ,记录在第⑤步patched新节点过的数量<br><strong>toBePatched</strong> 记录⑤步之前，没有经过patched 新的节点的数量。<br><strong>moved</strong>代表是否发生过移动，咱们的demo是已经发生过移动的。</p><p><strong>newIndexToOldIndexMap</strong> 用来存放新节点索引和老节点索引的数组。<br>newIndexToOldIndexMap 数组的index是新vnode的索引 ， value是老vnode的索引。</p><p>接下来</p><pre><code class="javascript"> for (i = s1; i &lt;= e1; i++) &#123; /* 开始遍历老节点 */        const prevChild = c1[i]        if (patched &gt;= toBePatched) &#123; /* 已经patch数量大于等于， */          /* ① 如果 toBePatched新的节点数量为0 ，那么统一卸载老的节点 */          unmount(prevChild, parentComponent, parentSuspense, true)          continue        &#125;        let newIndex         /* ② 如果,老节点的key存在 ，通过key找到对应的index */        if (prevChild.key != null) &#123;          newIndex = keyToNewIndexMap.get(prevChild.key)        &#125; else &#123; /*  ③ 如果,老节点的key不存在 */          for (j = s2; j &lt;= e2; j++) &#123; /* 遍历剩下的所有新节点 */            if (              newIndexToOldIndexMap[j - s2] === 0 &amp;&amp; /* newIndexToOldIndexMap[j - s2] === 0 新节点没有被patch */              isSameVNodeType(prevChild, c2[j] as VNode)            ) &#123; /* 如果找到与当前老节点对应的新节点那么 ，将新节点的索引，赋值给newIndex  */              newIndex = j              break            &#125;          &#125;        &#125;        if (newIndex === undefined) &#123; /* ①没有找到与老节点对应的新节点，删除当前节点，卸载所有的节点 */          unmount(prevChild, parentComponent, parentSuspense, true)        &#125; else &#123;          /* ②把老节点的索引，记录在存放新节点的数组中， */          newIndexToOldIndexMap[newIndex - s2] = i + 1          if (newIndex &gt;= maxNewIndexSoFar) &#123;            maxNewIndexSoFar = newIndex          &#125; else &#123;            /* 证明有节点已经移动了   */            moved = true          &#125;          /* 找到新的节点进行patch节点 */          patch(            prevChild,            c2[newIndex] as VNode,            container,            null,            parentComponent,            parentSuspense,            isSVG,            optimized          )          patched++        &#125; &#125;</code></pre><p>这段代码算是diff算法的核心。</p><p><strong>第一步： 通过老节点的key找到对应新节点的index:开始遍历老的节点，判断有没有key， 如果存在key通过新节点的keyToNewIndexMap找到与新节点index,如果不存在key那么会遍历剩下来的新节点试图找到对应index。</strong></p><p><strong>第二步：如果存在index证明有对应的老节点，那么直接复用老节点进行patch，没有找到与老节点对应的新节点，删除当前老节点。</strong></p><p><strong>第三步：newIndexToOldIndexMap找到对应新老节点关系。</strong></p><p>到这里，我们patch了一遍，把所有的老vnode都patch了一遍。</p><p>如图所示<br><img src="http://cdn.tangyuxian.com/PicGoImages/20210812140428.jpeg" alt="01B449A5-9B15-4547-8EBF-5A3BA66A1831.jpg"><br>但是接下来的问题。</p><p><strong>1 虽然已经patch过所有的老节点。可以对于已经发生移动的节点，要怎么真正移动dom元素。</strong><br><strong>2 对于新增的节点，（图中节点I）并没有处理，应该怎么处理。</strong></p><pre><code class="js">      /*移动老节点创建新节点*/     /* 根据最长稳定序列移动相对应的节点 */      const increasingNewIndexSequence = moved        ? getSequence(newIndexToOldIndexMap)        : EMPTY_ARR      j = increasingNewIndexSequence.length - 1      for (i = toBePatched - 1; i &gt;= 0; i--) &#123;        const nextIndex = s2 + i        const nextChild = c2[nextIndex] as VNode        const anchor =          nextIndex + 1 &lt; l2 ? (c2[nextIndex + 1] as VNode).el : parentAnchor        if (newIndexToOldIndexMap[i] === 0) &#123; /* 没有老的节点与新的节点对应，则创建一个新的vnode */          patch(            null,            nextChild,            container,            anchor,            parentComponent,            parentSuspense,            isSVG          )        &#125; else if (moved) &#123;          if (j &lt; 0 || i !== increasingNewIndexSequence[j]) &#123; /*如果没有在长*/            /* 需要移动的vnode */            move(nextChild, container, anchor, MoveType.REORDER)          &#125; else &#123;            j--          &#125;    </code></pre><h3 id="⑥最长稳定序列"><a href="#⑥最长稳定序列" class="headerlink" title="⑥最长稳定序列"></a>⑥最长稳定序列</h3><p>首选通过getSequence得到一个最长稳定序列，对于index === 0 的情况也就是<strong>新增节点（图中I）</strong> 需要从新mount一个新的vnode,然后对于发生移动的节点进行统一的移动操作</p><p><strong>什么叫做最长稳定序列</strong></p><p>对于以下的原始序列<br>0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15<br>最长递增子序列为<br>0, 2, 6, 9, 11, 15.</p><p><strong>为什么要得到最长稳定序列</strong></p><p>因为我们需要一个序列作为基础的参照序列，其他未在稳定序列的节点，进行移动。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过上述我们大致知道了diff算法的流程<br><strong>1 从头对比找到有相同的节点 patch ，发现不同，立即跳出。</strong></p><p><strong>2如果第一步没有patch完，立即，从后往前开始patch ,如果发现不同立即跳出循环。</strong></p><p><strong>3如果新的节点大于老的节点数 ，对于剩下的节点全部以新的vnode处理（ 这种情况说明已经patch完相同的vnode ）。</strong></p><p><strong>4 对于老的节点大于新的节点的情况 ， 对于超出的节点全部卸载 （ 这种情况说明已经patch完相同的vnode ）。</strong></p><p><strong>5不确定的元素（ 这种情况说明没有patch完相同的vnode ） 与 3 ，4对立关系。</strong></p><p>1 把没有比较过的新的vnode节点,通过map保存<br>记录已经patch的新节点的数量 patched<br>没有经过 path 新的节点的数量 toBePatched<br>建立一个数组newIndexToOldIndexMap，每个子元素都是[ 0, 0, 0, 0, 0, 0, ] 里面的数字记录老节点的索引 ，数组索引就是新节点的索引<br><strong>开始遍历老节点</strong><br>① 如果 toBePatched新的节点数量为0 ，那么统一卸载老的节点<br>② 如果,老节点的key存在 ，通过key找到对应的index<br>③ 如果,老节点的key不存在</p><pre><code>  1 遍历剩下的所有新节点  2 如果找到与当前老节点对应的新节点那么 ，将新节点的索引，赋值给newIndex</code></pre><p>④ 没有找到与老节点对应的新节点，卸载当前老节点。<br>⑤ 如果找到与老节点对应的新节点，把老节点的索引，记录在存放新节点的数组中，</p><pre><code>  1 如果节点发生移动 记录已经移动了  2 patch新老节点 找到新的节点进行patch节点    </code></pre><p><strong>遍历结束</strong></p><p><strong>如果发生移动</strong></p><pre><code>① 根据 newIndexToOldIndexMap 新老节点索引列表找到最长稳定序列② 对于 newIndexToOldIndexMap -item =0 证明不存在老节点 ，从新形成新的vnode ③ 对于发生移动的节点进行移动处理。 </code></pre><h2 id="三-key的作用，如何正确key。"><a href="#三-key的作用，如何正确key。" class="headerlink" title="三 key的作用，如何正确key。"></a>三 key的作用，如何正确key。</h2><h3 id="1key的作用"><a href="#1key的作用" class="headerlink" title="1key的作用"></a>1key的作用</h3><p>在我们上述diff算法中，通过isSameVNodeType方法判断，来判断key是否相等判断新老节点。<br>那么由此我们可以总结出？</p><p><strong>在v-for循环中，key的作用是：通过判断newVnode和OldVnode的key是否相等，从而复用与新节点对应的老节点，节约性能的开销。</strong></p><h3 id="2如何正确使用key"><a href="#2如何正确使用key" class="headerlink" title="2如何正确使用key"></a>2如何正确使用key</h3><h4 id="①错误用法-1：用index做key。"><a href="#①错误用法-1：用index做key。" class="headerlink" title="①错误用法 1：用index做key。"></a>①错误用法 1：用index做key。</h4><p><strong>用index做key的效果实际和没有用diff算法是一样的，为什么这么说呢，下面我就用一幅图来说明：</strong></p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812140436.jpeg" alt="WechatIMG10408 1.jpeg"></p><p>如果所示当我们用index作为key的时候，无论我们怎么样移动删除节点，到了diff算法中都会从头到尾依次patch(图中：<strong>所有节点均未有效的复用</strong>)</p><h4 id="②错误用法2-：用index拼接其他值作为key。"><a href="#②错误用法2-：用index拼接其他值作为key。" class="headerlink" title="②错误用法2 ：用index拼接其他值作为key。"></a>②错误用法2 ：用index拼接其他值作为key。</h4><p>当已用index拼接其他值作为索引的时候，因为每一个节点都找不到对应的key，导致所有的节点都不能复用,所有的新vnode都需要重新创建。都需要重新create</p><p>如图所示。<br><img src="http://cdn.tangyuxian.com/PicGoImages/20210812140441.jpeg" alt="WechatIMG10531.jpeg"></p><h4 id="③正确用法-：用唯一值id做key-我们可以用前后端交互的数据源的id为key-。"><a href="#③正确用法-：用唯一值id做key-我们可以用前后端交互的数据源的id为key-。" class="headerlink" title="③正确用法 ：用唯一值id做key(我们可以用前后端交互的数据源的id为key)。"></a>③正确用法 ：用唯一值id做key(我们可以用前后端交互的数据源的id为key)。</h4><p>如图所示。每一个节点都做到了复用。起到了diff算法的真正作用。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210812140449.jpeg" alt="WechatIMG10532.jpeg"></p><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h2><p>我们在上面，已经把刚开始的问题统统解决了，最后用一张思维脑图来从新整理一下整个流程。<br><img src="http://cdn.tangyuxian.com/PicGoImages/20210812140457.jpeg" alt="7FB635D9-EE62-45D5-8DE9-620CDF74B772.jpg"></p><hr><p>参考文章:</p><p><a href="https://blog.csdn.net/weixin_39621975/article/details/111213826">CSDN文章:diff算法_Vue3.0时代你必须了解的：diff算法原理和优化</a></p><p><a href="https://segmentfault.com/a/1190000023060173">vue3.0 diff算法详解(超详细)</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-vue常用指令</title>
      <link href="/2021/07/13/%E5%89%8D%E7%AB%AF/vue/vue-vue%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>/2021/07/13/%E5%89%8D%E7%AB%AF/vue/vue-vue%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>记录vue的常用指令</p><span id="more"></span><p>使用了 vue 的指令后，表达式是 JS 表达式，变量是 VUE 实例中的数据属性。</p><h2 id="1-常用指令"><a href="#1-常用指令" class="headerlink" title="1 常用指令"></a>1 常用指令</h2><ul><li>v-if指令</li><li>v-show指令</li><li>v-else指令</li><li>v-for指令</li><li>v-bind指令</li><li>v-model</li><li>v-on指令</li><li>v-text指令</li></ul><h4 id="1-1-v-if"><a href="#1-1-v-if" class="headerlink" title="1.1 v-if"></a>1.1 <code>v-if</code></h4><h4 id="条件渲染指令，它根据表达式的真假来删除和插入元素，它的基本语法如下："><a href="#条件渲染指令，它根据表达式的真假来删除和插入元素，它的基本语法如下：" class="headerlink" title="条件渲染指令，它根据表达式的真假来删除和插入元素，它的基本语法如下："></a>条件渲染指令，它根据表达式的真假来删除和插入元素，它的基本语法如下：</h4><pre><code>v-if=&quot;expression&quot;</code></pre><p>expression是一个返回bool值的表达式，表达式可以是一个bool属性，也可以是一个返回bool的运算式。例如：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.2.2/vue.min.js&quot;&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;app&quot;&gt;            &lt;h1&gt;Hello, Vue.js!&lt;/h1&gt;            &lt;h1 v-if=&quot;yes&quot;&gt;Yes!&lt;/h1&gt;            &lt;h1 v-if=&quot;no&quot;&gt;No!&lt;/h1&gt;            &lt;h1 v-if=&quot;age &gt;= 25&quot;&gt;Age: &#123;&#123; age &#125;&#125;&lt;/h1&gt;            &lt;h1 v-if=&quot;name.indexOf(&#39;jack&#39;) &gt;= 0&quot;&gt;Name: &#123;&#123; name &#125;&#125;&lt;/h1&gt;        &lt;/div&gt;    &lt;/body&gt;    &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;                var vm = new Vue(&#123;            el: &#39;#app&#39;,            data: &#123;                yes: true,                no: false,                age: 28,                name: &#39;keepfool&#39;            &#125;        &#125;)    &lt;/script&gt;&lt;/html&gt;</code></pre><p>显示结果如下、</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210714113817.png" alt="img"></p><p><strong>注意：</strong>v-if指令是根据条件表达式的值来执行<strong>元素的插入或者删除行为。</strong></p><h4 id="1-2-v-for指令"><a href="#1-2-v-for指令" class="headerlink" title="1.2 v-for指令"></a><strong>1.2</strong> v-for指令</h4><p><code>v-for</code>指令基于一个数组渲染一个列表，它和JavaScript的遍历语法相似：</p><pre><code>v-for=&quot;item in items&quot;</code></pre><p>items是一个数组，item是当前被遍历的数组元素。</p><p>示例代码：</p><pre><code>&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;table style=&quot;width: 400px; height: 600px;&quot; border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;            &lt;thead&gt;                &lt;tr&gt;                    &lt;th&gt;name&lt;/th&gt;                    &lt;th&gt;age&lt;/th&gt;                &lt;/tr&gt;            &lt;/thead&gt;            &lt;tbody&gt;                &lt;tr v-for=&quot;item in items&quot;&gt;                    &lt;td align=&quot;center&quot;&gt; &#123;&#123;item.name&#125;&#125;&lt;/td&gt;                    &lt;td&gt; &#123;&#123;item.age&#125;&#125;&lt;/td&gt;                &lt;/tr&gt;            &lt;/tbody&gt;        &lt;/table&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var app = new Vue(&#123;        el:&#39;#app&#39;,        data:&#123;            items:[&#123;name:&#39;well&#39;,age:&#39;20&#39;&#125;,&#123;name:&#39;good&#39;,age:&#39;19&#39;&#125;,&#123;name:&#39;nice&#39;,age:&#39;18&#39;&#125;,&#123;name:&#39;ok&#39;,age:&#39;17&#39;&#125;,]        &#125;    &#125;)&lt;/script&gt;</code></pre><h4 id="1-3-v-bind-指令"><a href="#1-3-v-bind-指令" class="headerlink" title="1.3 v-bind 指令"></a>1.3 v-bind 指令</h4><p>可以在其名称后面带一个参数，中间放一个冒号隔开，这个参数通常是HTML元素的特性（attribute），例如：<code>v-bind:class</code></p><pre><code>v-bind:argument=&quot;expression&quot;</code></pre><h4 id="1-4-v-model"><a href="#1-4-v-model" class="headerlink" title="1.4 v-model"></a>1.4 v-model</h4><p>v-model（表单元素设置了之后会忽略掉value，checked，selected），常用在表单 <code>input</code> 及 <code>textarea</code></p><blockquote><p>让表单元素和数据实现双向绑定（映射关系）</p></blockquote><p>示例代码</p><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;p v-text=&quot;message&quot;&gt; &lt;/p&gt;    &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var app = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            message:&quot;nice to meet you&quot;        &#125;    &#125;)&lt;/script&gt;</code></pre><h4 id="1-5-v-on-指令"><a href="#1-5-v-on-指令" class="headerlink" title="1.5 v-on 指令"></a>1.5 v-on 指令</h4><p>用于给监听DOM事件，它的用语法和v-bind是类似的，例如监听<code>a</code>元素的点击事件：</p><pre><code>&lt;a v-on:click=&quot;doSomething&quot;&gt;</code></pre><p>有两种形式调用方法：**绑定一个方法（让事件指向方法的引用），或者使用内联语句。<br>**Greet按钮将它的单击事件直接绑定到greet()方法，而Hi按钮则是调用say()方法。</p><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。Vue.js 为 <code>v-on</code> 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。</p><ul><li><code>.stop</code></li><li><code>.prevent</code></li><li><code>.capture</code></li><li><code>.self</code></li><li><code>.once</code></li><li><code>.passive</code></li></ul><pre><code>&lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 --&gt;&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</code></pre><p>Vue.js为最常用的两个指令<code>v-bind</code>和<code>v-on</code>提供了缩写方式。<strong>v-bind指令可以缩写为一个冒号，v-on指令可以缩写为@符号。</strong></p><pre><code>&lt;!--完整语法--&gt;&lt;a href=&quot;javascripit:void(0)&quot; v-bind:class=&quot;activeNumber === n + 1 ? &#39;active&#39; : &#39;&#39;&quot;&gt;&#123;&#123; n + 1 &#125;&#125;&lt;/a&gt;&lt;!--缩写语法--&gt;&lt;a href=&quot;javascripit:void(0)&quot; :class=&quot;activeNumber=== n + 1 ? &#39;active&#39; : &#39;&#39;&quot;&gt;&#123;&#123; n + 1 &#125;&#125;&lt;/a&gt;&lt;!--完整语法--&gt;&lt;button v-on:click=&quot;greet&quot;&gt;Greet&lt;/button&gt;&lt;!--缩写语法--&gt;&lt;button @click=&quot;greet&quot;&gt;Greet&lt;/button&gt;</code></pre><h4 id="1-6-v-text指令"><a href="#1-6-v-text指令" class="headerlink" title="1.6 v-text指令"></a>1.6 v-text指令</h4><p>主要是防止页面首次加载时 <code>&#123;&#123;&#125;&#125;</code> 出现在页面上。将对象中数据变量值显示在绑定的标签内容上。</p><pre><code>v-text=&quot;expresstion&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6-Reflect相关</title>
      <link href="/2021/06/10/%E5%89%8D%E7%AB%AF/es6/es6-Reflect%E7%9B%B8%E5%85%B3/"/>
      <url>/2021/06/10/%E5%89%8D%E7%AB%AF/es6/es6-Reflect%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>ES6 为了操作对象而提供的新API,未来的新方法将只部署在Reflect对象上！</p><span id="more"></span><p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>（1） 将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</p><p>（2） 修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code>。</p><pre><code class="javascript">// 老写法try &#123;  Object.defineProperty(target, property, attributes);  // success&#125; catch (e) &#123;  // failure&#125;// 新写法if (Reflect.defineProperty(target, property, attributes)) &#123;  // success&#125; else &#123;  // failure&#125;</code></pre><p>（3） 让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</p><pre><code class="javascript">// 老写法&#39;assign&#39; in Object // true// 新写法Reflect.has(Object, &#39;assign&#39;) // true</code></pre><p>（4）<code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法。这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为，作为修改行为的基础。也就是说，不管<code>Proxy</code>怎么修改默认行为，你总可以在<code>Reflect</code>上获取默认行为。</p><pre><code class="javascript">Proxy(target, &#123;  set: function(target, name, value, receiver) &#123;    var success = Reflect.set(target, name, value, receiver);    if (success) &#123;      console.log(&#39;property &#39; + name + &#39; on &#39; + target + &#39; set to &#39; + value);    &#125;    return success;  &#125;&#125;);</code></pre><p>上面代码中，<code>Proxy</code>方法拦截<code>target</code>对象的属性赋值行为。它采用<code>Reflect.set</code>方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。</p><p>下面是另一个例子。</p><pre><code class="javascript">var loggedObj = new Proxy(obj, &#123;  get(target, name) &#123;    console.log(&#39;get&#39;, target, name);    return Reflect.get(target, name);  &#125;,  deleteProperty(target, name) &#123;    console.log(&#39;delete&#39; + name);    return Reflect.deleteProperty(target, name);  &#125;,  has(target, name) &#123;    console.log(&#39;has&#39; + name);    return Reflect.has(target, name);  &#125;&#125;);</code></pre><p>上面代码中，每一个<code>Proxy</code>对象的拦截操作（<code>get</code>、<code>delete</code>、<code>has</code>），内部都调用对应的<code>Reflect</code>方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。</p><p>有了<code>Reflect</code>对象以后，很多操作会更易读。</p><pre><code class="javascript">// 老写法Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1// 新写法Reflect.apply(Math.floor, undefined, [1.75]) // 1</code></pre><h2 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2.静态方法"></a>2.静态方法</h2><p><code>Reflect</code>对象一共有 13 个静态方法。</p><ul><li>Reflect.apply(target, thisArg, args)</li><li>Reflect.construct(target, args)</li><li>Reflect.get(target, name, receiver)</li><li>Reflect.set(target, name, value, receiver)</li><li>Reflect.defineProperty(target, name, desc)</li><li>Reflect.deleteProperty(target, name)</li><li>Reflect.has(target, name)</li><li>Reflect.ownKeys(target)</li><li>Reflect.isExtensible(target)</li><li>Reflect.preventExtensions(target)</li><li>Reflect.getOwnPropertyDescriptor(target, name)</li><li>Reflect.getPrototypeOf(target)</li><li>Reflect.setPrototypeOf(target, prototype)</li></ul><p>上面这些方法的作用，大部分与<code>Object</code>对象的同名方法的作用都是相同的，而且它与<code>Proxy</code>对象的方法是一一对应的。下面是对它们的解释。</p><h3 id="Reflect-get-target-name-receiver"><a href="#Reflect-get-target-name-receiver" class="headerlink" title="Reflect.get(target, name, receiver)"></a>Reflect.get(target, name, receiver)</h3><p><code>Reflect.get</code>方法查找并返回<code>target</code>对象的<code>name</code>属性，如果没有该属性，则返回<code>undefined</code>。</p><pre><code class="javascript">var myObject = &#123;  foo: 1,  bar: 2,  get baz() &#123;    return this.foo + this.bar;  &#125;,&#125;Reflect.get(myObject, &#39;foo&#39;) // 1Reflect.get(myObject, &#39;bar&#39;) // 2Reflect.get(myObject, &#39;baz&#39;) // 3</code></pre><p>如果<code>name</code>属性部署了读取函数（getter），则读取函数的<code>this</code>绑定<code>receiver</code>。</p><pre><code class="javascript">var myObject = &#123;  foo: 1,  bar: 2,  get baz() &#123;    return this.foo + this.bar;  &#125;,&#125;;var myReceiverObject = &#123;  foo: 4,  bar: 4,&#125;;Reflect.get(myObject, &#39;baz&#39;, myReceiverObject) // 8</code></pre><p>如果第一个参数不是对象，<code>Reflect.get</code>方法会报错。</p><pre><code class="javascript">Reflect.get(1, &#39;foo&#39;) // 报错Reflect.get(false, &#39;foo&#39;) // 报错</code></pre><h3 id="Reflect-set-target-name-value-receiver"><a href="#Reflect-set-target-name-value-receiver" class="headerlink" title="Reflect.set(target, name, value, receiver)"></a>Reflect.set(target, name, value, receiver)</h3><p><code>Reflect.set</code>方法设置<code>target</code>对象的<code>name</code>属性等于<code>value</code>。</p><pre><code class="javascript">var myObject = &#123;  foo: 1,  set bar(value) &#123;    return this.foo = value;  &#125;,&#125;myObject.foo // 1Reflect.set(myObject, &#39;foo&#39;, 2);myObject.foo // 2Reflect.set(myObject, &#39;bar&#39;, 3)myObject.foo // 3</code></pre><p>如果<code>name</code>属性设置了赋值函数，则赋值函数的<code>this</code>绑定<code>receiver</code>。</p><pre><code class="javascript">var myObject = &#123;  foo: 4,  set bar(value) &#123;    return this.foo = value;  &#125;,&#125;;var myReceiverObject = &#123;  foo: 0,&#125;;Reflect.set(myObject, &#39;bar&#39;, 1, myReceiverObject);myObject.foo // 4myReceiverObject.foo // 1</code></pre><p>注意，如果 <code>Proxy</code>对象和 <code>Reflect</code>对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了<code>receiver</code>，那么<code>Reflect.set</code>会触发<code>Proxy.defineProperty</code>拦截。</p><pre><code class="javascript">let p = &#123;  a: &#39;a&#39;&#125;;let handler = &#123;  set(target, key, value, receiver) &#123;    console.log(&#39;set&#39;);    Reflect.set(target, key, value, receiver)  &#125;,  defineProperty(target, key, attribute) &#123;    console.log(&#39;defineProperty&#39;);    Reflect.defineProperty(target, key, attribute);  &#125;&#125;;let obj = new Proxy(p, handler);obj.a = &#39;A&#39;;// set// defineProperty</code></pre><p>上面代码中，<code>Proxy.set</code>拦截里面使用了<code>Reflect.set</code>，而且传入了<code>receiver</code>，导致触发<code>Proxy.defineProperty</code>拦截。这是因为<code>Proxy.set</code>的<code>receiver</code>参数总是指向当前的 <code>Proxy</code>实例（即上例的<code>obj</code>），而<code>Reflect.set</code>一旦传入<code>receiver</code>，就会将属性赋值到<code>receiver</code>上面（即<code>obj</code>），导致触发<code>defineProperty</code>拦截。如果<code>Reflect.set</code>没有传入<code>receiver</code>，那么就不会触发<code>defineProperty</code>拦截。</p><pre><code class="javascript">let p = &#123;  a: &#39;a&#39;&#125;;let handler = &#123;  set(target, key, value, receiver) &#123;    console.log(&#39;set&#39;);    Reflect.set(target, key, value)  &#125;,  defineProperty(target, key, attribute) &#123;    console.log(&#39;defineProperty&#39;);    Reflect.defineProperty(target, key, attribute);  &#125;&#125;;let obj = new Proxy(p, handler);obj.a = &#39;A&#39;;// set</code></pre><p>如果第一个参数不是对象，<code>Reflect.set</code>会报错。</p><pre><code class="javascript">Reflect.set(1, &#39;foo&#39;, &#123;&#125;) // 报错Reflect.set(false, &#39;foo&#39;, &#123;&#125;) // 报错</code></pre><h3 id="Reflect-has-obj-name"><a href="#Reflect-has-obj-name" class="headerlink" title="Reflect.has(obj, name)"></a>Reflect.has(obj, name)</h3><p><code>Reflect.has</code>方法对应<code>name in obj</code>里面的<code>in</code>运算符。</p><pre><code class="javascript">var myObject = &#123;  foo: 1,&#125;;// 旧写法&#39;foo&#39; in myObject // true// 新写法Reflect.has(myObject, &#39;foo&#39;) // true</code></pre><p>如果<code>Reflect.has()</code>方法的第一个参数不是对象，会报错。</p><h3 id="Reflect-deleteProperty-obj-name"><a href="#Reflect-deleteProperty-obj-name" class="headerlink" title="Reflect.deleteProperty(obj, name)"></a>Reflect.deleteProperty(obj, name)</h3><p><code>Reflect.deleteProperty</code>方法等同于<code>delete obj[name]</code>，用于删除对象的属性。</p><pre><code class="javascript">const myObj = &#123; foo: &#39;bar&#39; &#125;;// 旧写法delete myObj.foo;// 新写法Reflect.deleteProperty(myObj, &#39;foo&#39;);</code></pre><p>该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回<code>true</code>；删除失败，被删除的属性依然存在，返回<code>false</code>。</p><p>如果<code>Reflect.deleteProperty()</code>方法的第一个参数不是对象，会报错。</p><h3 id="Reflect-construct-target-args"><a href="#Reflect-construct-target-args" class="headerlink" title="Reflect.construct(target, args)"></a>Reflect.construct(target, args)</h3><p><code>Reflect.construct</code>方法等同于<code>new target(...args)</code>，这提供了一种不使用<code>new</code>，来调用构造函数的方法。</p><pre><code class="javascript">function Greeting(name) &#123;  this.name = name;&#125;// new 的写法const instance = new Greeting(&#39;张三&#39;);// Reflect.construct 的写法const instance = Reflect.construct(Greeting, [&#39;张三&#39;]);</code></pre><p>如果<code>Reflect.construct()</code>方法的第一个参数不是函数，会报错。</p><h3 id="Reflect-getPrototypeOf-obj"><a href="#Reflect-getPrototypeOf-obj" class="headerlink" title="Reflect.getPrototypeOf(obj)"></a>Reflect.getPrototypeOf(obj)</h3><p><code>Reflect.getPrototypeOf</code>方法用于读取对象的<code>__proto__</code>属性，对应<code>Object.getPrototypeOf(obj)</code>。</p><pre><code class="javascript">const myObj = new FancyThing();// 旧写法Object.getPrototypeOf(myObj) === FancyThing.prototype;// 新写法Reflect.getPrototypeOf(myObj) === FancyThing.prototype;</code></pre><p><code>Reflect.getPrototypeOf</code>和<code>Object.getPrototypeOf</code>的一个区别是，如果参数不是对象，<code>Object.getPrototypeOf</code>会将这个参数转为对象，然后再运行，而<code>Reflect.getPrototypeOf</code>会报错。</p><pre><code class="javascript">Object.getPrototypeOf(1) // Number &#123;[[PrimitiveValue]]: 0&#125;Reflect.getPrototypeOf(1) // 报错</code></pre><h3 id="Reflect-setPrototypeOf-obj-newProto"><a href="#Reflect-setPrototypeOf-obj-newProto" class="headerlink" title="Reflect.setPrototypeOf(obj, newProto)"></a>Reflect.setPrototypeOf(obj, newProto)</h3><p><code>Reflect.setPrototypeOf</code>方法用于设置目标对象的原型（prototype），对应<code>Object.setPrototypeOf(obj, newProto)</code>方法。它返回一个布尔值，表示是否设置成功。</p><pre><code class="javascript">const myObj = &#123;&#125;;// 旧写法Object.setPrototypeOf(myObj, Array.prototype);// 新写法Reflect.setPrototypeOf(myObj, Array.prototype);myObj.length // 0</code></pre><p>如果无法设置目标对象的原型（比如，目标对象禁止扩展），<code>Reflect.setPrototypeOf</code>方法返回<code>false</code>。</p><pre><code class="javascript">Reflect.setPrototypeOf(&#123;&#125;, null)// trueReflect.setPrototypeOf(Object.freeze(&#123;&#125;), null)// false</code></pre><p>如果第一个参数不是对象，<code>Object.setPrototypeOf</code>会返回第一个参数本身，而<code>Reflect.setPrototypeOf</code>会报错。</p><pre><code class="javascript">Object.setPrototypeOf(1, &#123;&#125;)// 1Reflect.setPrototypeOf(1, &#123;&#125;)// TypeError: Reflect.setPrototypeOf called on non-object</code></pre><p>如果第一个参数是<code>undefined</code>或<code>null</code>，<code>Object.setPrototypeOf</code>和<code>Reflect.setPrototypeOf</code>都会报错。</p><pre><code class="javascript">Object.setPrototypeOf(null, &#123;&#125;)// TypeError: Object.setPrototypeOf called on null or undefinedReflect.setPrototypeOf(null, &#123;&#125;)// TypeError: Reflect.setPrototypeOf called on non-object</code></pre><h3 id="Reflect-apply-func-thisArg-args"><a href="#Reflect-apply-func-thisArg-args" class="headerlink" title="Reflect.apply(func, thisArg, args)"></a>Reflect.apply(func, thisArg, args)</h3><p><code>Reflect.apply</code>方法等同于<code>Function.prototype.apply.call(func, thisArg, args)</code>，用于绑定<code>this</code>对象后执行给定函数。</p><p>一般来说，如果要绑定一个函数的<code>this</code>对象，可以这样写<code>fn.apply(obj, args)</code>，但是如果函数定义了自己的<code>apply</code>方法，就只能写成<code>Function.prototype.apply.call(fn, obj, args)</code>，采用<code>Reflect</code>对象可以简化这种操作。</p><pre><code class="javascript">const ages = [11, 33, 12, 54, 18, 96];// 旧写法const youngest = Math.min.apply(Math, ages);const oldest = Math.max.apply(Math, ages);const type = Object.prototype.toString.call(youngest);// 新写法const youngest = Reflect.apply(Math.min, Math, ages);const oldest = Reflect.apply(Math.max, Math, ages);const type = Reflect.apply(Object.prototype.toString, youngest, []);</code></pre><h3 id="Reflect-defineProperty-target-propertyKey-attributes"><a href="#Reflect-defineProperty-target-propertyKey-attributes" class="headerlink" title="Reflect.defineProperty(target, propertyKey, attributes)"></a>Reflect.defineProperty(target, propertyKey, attributes)</h3><p><code>Reflect.defineProperty</code>方法基本等同于<code>Object.defineProperty</code>，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用<code>Reflect.defineProperty</code>代替它。</p><pre><code class="javascript">function MyDate() &#123;  /*…*/&#125;// 旧写法Object.defineProperty(MyDate, &#39;now&#39;, &#123;  value: () =&gt; Date.now()&#125;);// 新写法Reflect.defineProperty(MyDate, &#39;now&#39;, &#123;  value: () =&gt; Date.now()&#125;);</code></pre><p>如果<code>Reflect.defineProperty</code>的第一个参数不是对象，就会抛出错误，比如<code>Reflect.defineProperty(1, &#39;foo&#39;)</code>。</p><p>这个方法可以与<code>Proxy.defineProperty</code>配合使用。</p><pre><code class="javascript">const p = new Proxy(&#123;&#125;, &#123;  defineProperty(target, prop, descriptor) &#123;    console.log(descriptor);    return Reflect.defineProperty(target, prop, descriptor);  &#125;&#125;);p.foo = &#39;bar&#39;;// &#123;value: &quot;bar&quot;, writable: true, enumerable: true, configurable: true&#125;p.foo // &quot;bar&quot;</code></pre><p>上面代码中，<code>Proxy.defineProperty</code>对属性赋值设置了拦截，然后使用<code>Reflect.defineProperty</code>完成了赋值。</p><h3 id="Reflect-getOwnPropertyDescriptor-target-propertyKey"><a href="#Reflect-getOwnPropertyDescriptor-target-propertyKey" class="headerlink" title="Reflect.getOwnPropertyDescriptor(target, propertyKey)"></a>Reflect.getOwnPropertyDescriptor(target, propertyKey)</h3><p><code>Reflect.getOwnPropertyDescriptor</code>基本等同于<code>Object.getOwnPropertyDescriptor</code>，用于得到指定属性的描述对象，将来会替代掉后者。</p><pre><code class="javascript">var myObject = &#123;&#125;;Object.defineProperty(myObject, &#39;hidden&#39;, &#123;  value: true,  enumerable: false,&#125;);// 旧写法var theDescriptor = Object.getOwnPropertyDescriptor(myObject, &#39;hidden&#39;);// 新写法var theDescriptor = Reflect.getOwnPropertyDescriptor(myObject, &#39;hidden&#39;);</code></pre><p><code>Reflect.getOwnPropertyDescriptor</code>和<code>Object.getOwnPropertyDescriptor</code>的一个区别是，如果第一个参数不是对象，<code>Object.getOwnPropertyDescriptor(1, &#39;foo&#39;)</code>不报错，返回<code>undefined</code>，而<code>Reflect.getOwnPropertyDescriptor(1, &#39;foo&#39;)</code>会抛出错误，表示参数非法。</p><h3 id="Reflect-isExtensible-target"><a href="#Reflect-isExtensible-target" class="headerlink" title="Reflect.isExtensible (target)"></a>Reflect.isExtensible (target)</h3><p><code>Reflect.isExtensible</code>方法对应<code>Object.isExtensible</code>，返回一个布尔值，表示当前对象是否可扩展。</p><pre><code class="javascript">const myObject = &#123;&#125;;// 旧写法Object.isExtensible(myObject) // true// 新写法Reflect.isExtensible(myObject) // true</code></pre><p>如果参数不是对象，<code>Object.isExtensible</code>会返回<code>false</code>，因为非对象本来就是不可扩展的，而<code>Reflect.isExtensible</code>会报错。</p><pre><code class="javascript">Object.isExtensible(1) // falseReflect.isExtensible(1) // 报错</code></pre><h3 id="Reflect-preventExtensions-target"><a href="#Reflect-preventExtensions-target" class="headerlink" title="Reflect.preventExtensions(target)"></a>Reflect.preventExtensions(target)</h3><p><code>Reflect.preventExtensions</code>对应<code>Object.preventExtensions</code>方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。</p><pre><code class="javascript">var myObject = &#123;&#125;;// 旧写法Object.preventExtensions(myObject) // Object &#123;&#125;// 新写法Reflect.preventExtensions(myObject) // true</code></pre><p>如果参数不是对象，<code>Object.preventExtensions</code>在 ES5 环境报错，在 ES6 环境返回传入的参数，而<code>Reflect.preventExtensions</code>会报错。</p><pre><code class="javascript">// ES5 环境Object.preventExtensions(1) // 报错// ES6 环境Object.preventExtensions(1) // 1// 新写法Reflect.preventExtensions(1) // 报错</code></pre><h3 id="Reflect-ownKeys-target"><a href="#Reflect-ownKeys-target" class="headerlink" title="Reflect.ownKeys (target)"></a>Reflect.ownKeys (target)</h3><p><code>Reflect.ownKeys</code>方法用于返回对象的所有属性，基本等同于<code>Object.getOwnPropertyNames</code>与<code>Object.getOwnPropertySymbols</code>之和。</p><pre><code class="javascript">var myObject = &#123;  foo: 1,  bar: 2,  [Symbol.for(&#39;baz&#39;)]: 3,  [Symbol.for(&#39;bing&#39;)]: 4,&#125;;// 旧写法Object.getOwnPropertyNames(myObject)// [&#39;foo&#39;, &#39;bar&#39;]Object.getOwnPropertySymbols(myObject)//[Symbol(baz), Symbol(bing)]// 新写法Reflect.ownKeys(myObject)// [&#39;foo&#39;, &#39;bar&#39;, Symbol(baz), Symbol(bing)]</code></pre><p>如果<code>Reflect.ownKeys()</code>方法的第一个参数不是对象，会报错。</p><h2 id="实例：使用-Proxy-实现观察者模式"><a href="#实例：使用-Proxy-实现观察者模式" class="headerlink" title="实例：使用 Proxy 实现观察者模式"></a>实例：使用 Proxy 实现观察者模式</h2><p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。</p><pre><code class="javascript">const person = observable(&#123;  name: &#39;张三&#39;,  age: 20&#125;);function print() &#123;  console.log(`$&#123;person.name&#125;, $&#123;person.age&#125;`)&#125;observe(print);person.name = &#39;李四&#39;;// 输出// 李四, 20</code></pre><p>上面代码中，数据对象<code>person</code>是观察目标，函数<code>print</code>是观察者。一旦数据对象发生变化，<code>print</code>就会自动执行。</p><p>下面，使用 Proxy 写一个观察者模式的最简单实现，即实现<code>observable</code>和<code>observe</code>这两个函数。思路是<code>observable</code>函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。</p><pre><code class="javascript">const queuedObservers = new Set();const observe = fn =&gt; queuedObservers.add(fn);const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);function set(target, key, value, receiver) &#123;  const result = Reflect.set(target, key, value, receiver);  queuedObservers.forEach(observer =&gt; observer());  return result;&#125;</code></pre><p>上面代码中，先定义了一个<code>Set</code>集合，所有观察者函数都放进这个集合。然后，<code>observable</code>函数返回原始对象的代理，拦截赋值操作。拦截函数<code>set</code>之中，会自动执行所有观察者。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node-tsconfig.json配置相关</title>
      <link href="/2021/06/09/%E5%89%8D%E7%AB%AF/node/node-tsconfig-json%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3/"/>
      <url>/2021/06/09/%E5%89%8D%E7%AB%AF/node/node-tsconfig-json%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>tsconfig.json配置详细说明…</p><span id="more"></span><h3 id="1-初始化-learnTsconfig-项目"><a href="#1-初始化-learnTsconfig-项目" class="headerlink" title="1. 初始化 learnTsconfig 项目"></a>1. 初始化 learnTsconfig 项目</h3><p>执行下面命令：</p><pre><code class="text">$ mkdir learnTsconfig$ cd .\learnTsconfig\$ mkdir src$ new-item index.ts</code></pre><p>并且我们为 index.ts 文件写一些简单代码：</p><pre><code class="javascript">// 返回当前版本号function getVersion(version:string = &quot;1.0.0&quot;): string&#123;    return version;&#125;console.log(getVersion(&quot;1.0.1&quot;))</code></pre><p>我们将获得这么一个目录结构：</p><pre><code class="text">  └─src/     └─index.ts</code></pre><h3 id="2-初始化-tsconfig-json-文件"><a href="#2-初始化-tsconfig-json-文件" class="headerlink" title="2. 初始化 tsconfig.json 文件"></a>2. 初始化 tsconfig.json 文件</h3><p>在 learnTsconfig 根目录执行：</p><pre><code class="text">$ tsc --init</code></pre><h3 id="3-修改-tsconfig-json-文件"><a href="#3-修改-tsconfig-json-文件" class="headerlink" title="3. 修改 tsconfig.json 文件"></a>3. 修改 tsconfig.json 文件</h3><p>我们设置几个常见配置项：</p><pre><code class="json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;target&quot;: &quot;ES5&quot;,             // 目标语言的版本    &quot;module&quot;: &quot;commonjs&quot;,        // 指定生成代码的模板标准    &quot;noImplicitAny&quot;: true,       // 不允许隐式的 any 类型    &quot;removeComments&quot;: true,      // 删除注释     &quot;preserveConstEnums&quot;: true,  // 保留 const 和 enum 声明    &quot;sourceMap&quot;: true            // 生成目标文件的sourceMap文件  &#125;,  &quot;files&quot;: [   // 指定待编译文件    &quot;./src/index.ts&quot;    ]&#125;</code></pre><p>其中需要注意一点：<br> <code>files</code> 配置项值是一个<strong>数组</strong>，用来指定了待编译文件，即<strong>入口文件</strong>。<br>当入口文件依赖其他文件时，不需要将被依赖文件也指定到 <code>files</code> 中，因为<strong>编译器会自动将所有的依赖文件归纳为编译对象</strong>，即 <code>index.ts</code> 依赖 <code>user.ts</code> 时，不需要在 <code>files</code> 中指定 <code>user.ts</code> ， <code>user.ts</code> 会自动纳入待编译文件。</p><h3 id="4-执行编译"><a href="#4-执行编译" class="headerlink" title="4. 执行编译"></a>4. 执行编译</h3><p>配置完成后，我们可以在命令行执行 <code>tsc</code> 命令，执行编译完成后，我们可以得到一个 <code>index.js</code> 文件和一个 <code>index.js.map</code> 文件，证明我们编译成功，其中 <code>index.js</code> 文件内容如下：</p><pre><code class="javascript">function getVersion(version) &#123;    if (version === void 0) &#123; version = &quot;1.0.0&quot;; &#125;    return version;&#125;console.log(getVersion(&quot;1.0.1&quot;));//# sourceMappingURL=index.js.map</code></pre><p>可以看出，tsconfig.json 中的 <code>removeComments</code> 配置生效了，将我们添加的注释代码移除了。</p><p>到这一步，就完成了这个简单的示例，接下来会基于这个示例代码，讲解《七、常见配置示例》。</p><h2 id="四、tsconfig-json-文件结构介绍"><a href="#四、tsconfig-json-文件结构介绍" class="headerlink" title="四、tsconfig.json 文件结构介绍"></a>四、tsconfig.json 文件结构介绍</h2><h3 id="1-按顶层属性分类"><a href="#1-按顶层属性分类" class="headerlink" title="1. 按顶层属性分类"></a>1. 按顶层属性分类</h3><p>在 tsconfig.json 文件中按照<strong>顶层属性</strong>，分为以下几类：<br><img src="https://segmentfault.com/img/remote/1460000022809334" alt="tsconfig.json 文件结构（顶层属性）.png"></p><p><img src="https://segmentfault.com/img/remote/1460000022809332" alt="了不起的 tsconfig.json 指南.png"></p><h3 id="2-按功能分类"><a href="#2-按功能分类" class="headerlink" title="2. 按功能分类"></a>2. 按功能分类</h3><p><img src="https://segmentfault.com/img/remote/1460000022809333" alt="tsconfig.json 文件结构（功能）.png"></p><h2 id="五、tsconfig-json-配置介绍"><a href="#五、tsconfig-json-配置介绍" class="headerlink" title="五、tsconfig.json 配置介绍"></a>五、tsconfig.json 配置介绍</h2><h3 id="1-compileOnSave"><a href="#1-compileOnSave" class="headerlink" title="1. compileOnSave"></a>1. compileOnSave</h3><p><code>compileOnSave</code> 属性作用是<strong>设置保存文件的时候自动编译，但需要编译器支持</strong>。</p><pre><code class="json">&#123;    // ...  &quot;compileOnSave&quot;: false,&#125;</code></pre><h3 id="2-compilerOptions"><a href="#2-compilerOptions" class="headerlink" title="2. compilerOptions"></a>2. compilerOptions</h3><p><code>compilerOptions</code> 属性作用是<strong>配置编译选项</strong>。<br>若 <code>compilerOptions</code> 属性被忽略，则编译器会使用默认值，可以查看<a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html">《官方完整的编译选项列表》</a>。<br>编译选项配置非常繁杂，有很多配置，这里只列出常用的配置。</p><pre><code class="json">&#123;  // ...  &quot;compilerOptions&quot;: &#123;    &quot;incremental&quot;: true, // TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度    &quot;tsBuildInfoFile&quot;: &quot;./buildFile&quot;, // 增量编译文件的存储位置    &quot;diagnostics&quot;: true, // 打印诊断信息     &quot;target&quot;: &quot;ES5&quot;, // 目标语言的版本    &quot;module&quot;: &quot;CommonJS&quot;, // 生成代码的模板标准    &quot;outFile&quot;: &quot;./app.js&quot;, // 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置&quot;module&quot;: &quot;AMD&quot;,    &quot;lib&quot;: [&quot;DOM&quot;, &quot;ES2015&quot;, &quot;ScriptHost&quot;, &quot;ES2019.Array&quot;], // TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入&quot;ES2019.Array&quot;,    &quot;allowJS&quot;: true, // 允许编译器编译JS，JSX文件    &quot;checkJs&quot;: true, // 允许在JS文件中报错，通常与allowJS一起使用    &quot;outDir&quot;: &quot;./dist&quot;, // 指定输出目录    &quot;rootDir&quot;: &quot;./&quot;, // 指定输出文件目录(用于输出)，用于控制输出目录结构    &quot;declaration&quot;: true, // 生成声明文件，开启后会自动生成声明文件    &quot;declarationDir&quot;: &quot;./file&quot;, // 指定生成声明文件存放目录    &quot;emitDeclarationOnly&quot;: true, // 只生成声明文件，而不会生成js文件    &quot;sourceMap&quot;: true, // 生成目标文件的sourceMap文件    &quot;inlineSourceMap&quot;: true, // 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中    &quot;declarationMap&quot;: true, // 为声明文件生成sourceMap    &quot;typeRoots&quot;: [], // 声明文件目录，默认时node_modules/@types    &quot;types&quot;: [], // 加载的声明文件包    &quot;removeComments&quot;:true, // 删除注释     &quot;noEmit&quot;: true, // 不输出文件,即编译后不会生成任何js文件    &quot;noEmitOnError&quot;: true, // 发送错误时不输出任何文件    &quot;noEmitHelpers&quot;: true, // 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用    &quot;importHelpers&quot;: true, // 通过tslib引入helper函数，文件必须是模块    &quot;downlevelIteration&quot;: true, // 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现    &quot;strict&quot;: true, // 开启所有严格的类型检查    &quot;alwaysStrict&quot;: true, // 在代码中注入&#39;use strict&#39;    &quot;noImplicitAny&quot;: true, // 不允许隐式的any类型    &quot;strictNullChecks&quot;: true, // 不允许把null、undefined赋值给其他类型的变量    &quot;strictFunctionTypes&quot;: true, // 不允许函数参数双向协变    &quot;strictPropertyInitialization&quot;: true, // 类的实例属性必须初始化    &quot;strictBindCallApply&quot;: true, // 严格的bind/call/apply检查    &quot;noImplicitThis&quot;: true, // 不允许this有隐式的any类型    &quot;noUnusedLocals&quot;: true, // 检查只声明、未使用的局部变量(只提示不报错)    &quot;noUnusedParameters&quot;: true, // 检查未使用的函数参数(只提示不报错)    &quot;noFallthroughCasesInSwitch&quot;: true, // 防止switch语句贯穿(即如果没有break语句后面不会执行)    &quot;noImplicitReturns&quot;: true, //每个分支都会有返回值    &quot;esModuleInterop&quot;: true, // 允许export=导出，由import from 导入    &quot;allowUmdGlobalAccess&quot;: true, // 允许在模块中全局变量的方式访问umd模块    &quot;moduleResolution&quot;: &quot;node&quot;, // 模块解析策略，ts默认用node的解析策略，即相对的方式导入    &quot;baseUrl&quot;: &quot;./&quot;, // 解析非相对模块的基地址，默认是当前目录    &quot;paths&quot;: &#123; // 路径映射，相对于baseUrl      // 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置      &quot;jquery&quot;: [&quot;node_modules/jquery/dist/jquery.min.js&quot;]    &#125;,    &quot;rootDirs&quot;: [&quot;src&quot;,&quot;out&quot;], // 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错    &quot;listEmittedFiles&quot;: true, // 打印输出文件    &quot;listFiles&quot;: true// 打印编译的文件(包括引用的声明文件)  &#125;&#125;</code></pre><h3 id="3-exclude"><a href="#3-exclude" class="headerlink" title="3. exclude"></a>3. exclude</h3><p><code>exclude</code> 属性作用是<strong>指定编译器需要排除的文件或文件夹。</strong><br>默认排除 <code>node_modules</code> 文件夹下文件。</p><pre><code class="json">&#123;    // ...  &quot;exclude&quot;: [    &quot;src/lib&quot; // 排除src目录下的lib文件夹下的文件不会编译  ]&#125;</code></pre><p>和 <code>include</code> 属性一样，支持 glob 通配符：</p><ul><li><code>*</code> 匹配0或多个字符（不包括目录分隔符）</li><li><code>?</code> 匹配一个任意字符（不包括目录分隔符）</li><li><code>**/</code> 递归匹配任意子目录</li></ul><h3 id="4-extends"><a href="#4-extends" class="headerlink" title="4. extends"></a>4. extends</h3><p><code>extends</code> 属性作用是<strong>引入其他配置文件，继承配置</strong>。<br>默认包含当前目录和子目录下所有 TypeScript 文件。</p><pre><code class="json">&#123;    // ...  // 把基础配置抽离成tsconfig.base.json文件，然后引入    &quot;extends&quot;: &quot;./tsconfig.base.json&quot;&#125;</code></pre><h3 id="5-files"><a href="#5-files" class="headerlink" title="5. files"></a>5. files</h3><p><code>files</code> 属性作用是<strong>指定需要编译的单个文件列表</strong>。<br>默认包含当前目录和子目录下所有 TypeScript 文件。</p><pre><code class="json">&#123;    // ...  &quot;files&quot;: [    // 指定编译文件是src目录下的leo.ts文件    &quot;scr/leo.ts&quot;  ]&#125;</code></pre><h3 id="6-include"><a href="#6-include" class="headerlink" title="6. include"></a>6. include</h3><p><code>include</code> 属性作用是<strong>指定编译需要编译的文件或目录</strong>。</p><pre><code class="json">&#123;    // ...  &quot;include&quot;: [    // &quot;scr&quot; // 会编译src目录下的所有文件，包括子目录    // &quot;scr/*&quot; // 只会编译scr一级目录下的文件    &quot;scr/*/*&quot; // 只会编译scr二级目录下的文件  ]&#125;</code></pre><h3 id="7-references"><a href="#7-references" class="headerlink" title="7. references"></a>7. references</h3><p><code>references</code> 属性作用是<strong>指定工程引用依赖。</strong><br>在项目开发中，有时候我们为了方便将前端项目和后端<code>node</code>项目放在同一个目录下开发，两个项目依赖同一个配置文件和通用文件，但我们希望前后端项目进行灵活的分别打包，那么我们可以进行如下配置：</p><pre><code class="json">&#123;    // ...  &quot;references&quot;: [ // 指定依赖的工程     &#123;&quot;path&quot;: &quot;./common&quot;&#125;  ]&#125;</code></pre><h3 id="8-typeAcquisition"><a href="#8-typeAcquisition" class="headerlink" title="8. typeAcquisition"></a>8. typeAcquisition</h3><p><code>typeAcquisition</code> 属性作用是<strong>设置自动引入库类型定义文件(.d.ts)相关。</strong><br>包含 3 个子属性：</p><ul><li><code>enable</code> : 布尔类型，是否开启自动引入库类型定义文件(.d.ts)，默认为 false；</li><li><code>include</code> : 数组类型，允许自动引入的库名，如：[“jquery”, “lodash”]；</li><li><code>exculde</code> : 数组类型，排除的库名。</li></ul><pre><code class="json">&#123;    // ...  &quot;typeAcquisition&quot;: &#123;    &quot;enable&quot;: false,    &quot;exclude&quot;: [&quot;jquery&quot;],    &quot;include&quot;: [&quot;jest&quot;]  &#125;&#125;</code></pre><h2 id="六、常见配置示例"><a href="#六、常见配置示例" class="headerlink" title="六、常见配置示例"></a>六、常见配置示例</h2><p>本部分内容中，我们找了几个实际开发中比较常见的配置，当然，还有很多配置需要自己摸索哟~~</p><h3 id="1-移除代码中注释"><a href="#1-移除代码中注释" class="headerlink" title="1. 移除代码中注释"></a>1. 移除代码中注释</h3><p>tsconfig.json：</p><pre><code class="json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;removeComments&quot;: true,  &#125;&#125;</code></pre><p>编译前：</p><pre><code class="javascript">// 返回当前版本号function getVersion(version:string = &quot;1.0.0&quot;): string&#123;    return version;&#125;console.log(getVersion(&quot;1.0.1&quot;))</code></pre><p>编译结果：</p><pre><code class="javascript">function getVersion(version) &#123;    if (version === void 0) &#123; version = &quot;1.0.0&quot;; &#125;    return version;&#125;console.log(getVersion(&quot;1.0.1&quot;));</code></pre><h3 id="2-开启null、undefined检测"><a href="#2-开启null、undefined检测" class="headerlink" title="2. 开启null、undefined检测"></a>2. 开启null、undefined检测</h3><p>tsconfig.json：</p><pre><code>&#123;    &quot;compilerOptions&quot;: &#123;        &quot;strictNullChecks&quot;: true    &#125;,&#125;</code></pre><p>修改 <code>index.ts</code> 文件内容：</p><pre><code class="javascript">const leo;leo = new Pingan(&#39;leo&#39;,&#39;hello&#39;);</code></pre><p>这时候编辑器也会提示错误信息，执行 <code>tsc</code> 后，控制台报错：</p><pre><code class="text">src/index.ts:9:11 - error TS2304: Cannot find name &#39;Pingan&#39;.9 leo = new Pingan(&#39;leo&#39;,&#39;hello&#39;);Found 1 error.</code></pre><h3 id="3-配置复用"><a href="#3-配置复用" class="headerlink" title="3. 配置复用"></a>3. 配置复用</h3><p>通过 <code>extends</code> 属性实现配置复用，即一个配置文件可以继承另一个文件的配置属性。<br>比如，建立一个基础的配置文件 <code>configs/base.json</code> ：</p><pre><code class="json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;noImplicitAny&quot;: true,    &quot;strictNullChecks&quot;: true  &#125;&#125;</code></pre><p>在<code>tsconfig.json</code> 就可以引用这个文件的配置了：</p><pre><code class="json">&#123;  &quot;extends&quot;: &quot;./configs/base&quot;,  &quot;files&quot;: [    &quot;main.ts&quot;,    &quot;supplemental.ts&quot;  ]&#125;</code></pre><h3 id="4-生成枚举的映射代码"><a href="#4-生成枚举的映射代码" class="headerlink" title="4. 生成枚举的映射代码"></a>4. 生成枚举的映射代码</h3><p>在默认情况下，使用 <code>const</code> 修饰符后，枚举不会生成映射代码。<br>如下，我们可以看出：使用 <code>const</code> 修饰符后，编译器不会生成任何 <code>RequestMethod</code> 枚举的任何映射代码，在其他地方使用时，内联每个成员的值，节省很大开销。</p><pre><code>const enum RequestMethod &#123;  Get,  Post,  Put,  Delete&#125;let methods = [  RequestMethod.Get,  RequestMethod.Post]</code></pre><p>编译结果：</p><pre><code class="javascript">&quot;use strict&quot;;let methods = [    0 /* Get */,    1 /* Post */];</code></pre><p>当然，我们希望生成映射代码时，也可以设置 <code>tsconfig.json</code> 中的配置，设置 <code>preserveConstEnums</code> 编译器选项为 <code>true</code> ：</p><pre><code class="json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;target&quot;: &quot;es5&quot;,    &quot;preserveConstEnums&quot;: true  &#125;&#125;</code></pre><p>最后编译结果变成：</p><pre><code class="javascript">&quot;use strict&quot;;var RequestMethod;(function (RequestMethod) &#123;    RequestMethod[RequestMethod[&quot;Get&quot;] = 0] = &quot;Get&quot;;    RequestMethod[RequestMethod[&quot;Post&quot;] = 1] = &quot;Post&quot;;    RequestMethod[RequestMethod[&quot;Put&quot;] = 2] = &quot;Put&quot;;    RequestMethod[RequestMethod[&quot;Delete&quot;] = 3] = &quot;Delete&quot;;&#125;)(RequestMethod || (RequestMethod = &#123;&#125;));let methods = [    0 /* Get */,    1 /* Post */];</code></pre><h3 id="5-关闭-this-类型注解提示"><a href="#5-关闭-this-类型注解提示" class="headerlink" title="5. 关闭 this 类型注解提示"></a>5. 关闭 this 类型注解提示</h3><p>通过下面代码编译后会报错：</p><pre><code class="javascript">const button = document.querySelector(&quot;button&quot;);button?.addEventListener(&quot;click&quot;, handleClick);function handleClick(this) &#123; console.log(&quot;Clicked!&quot;); this.removeEventListener(&quot;click&quot;, handleClick);&#125;</code></pre><p>报错内容：</p><pre><code class="text">src/index.ts:10:22 - error TS7006: Parameter &#39;this&#39; implicitly has an &#39;any&#39; type.10 function handleClick(this) &#123;Found 1 error.</code></pre><p>这是因为 <code>this</code> 隐式具有 <code>any</code> 类型，如果没有指定类型注解，编译器会提示“”this” 隐式具有类型 “any”，因为它没有类型注释。”。</p><p>解决方法有2种：</p><ol><li>指定 this 类型，如本代码中为 <code>HTMLElement</code> 类型：</li></ol><p><code>HTMLElement</code> 接口表示所有的 HTML 元素。一些HTML元素直接实现了 <code>HTMLElement</code> 接口，其它的间接实现<code>HTMLElement</code>接口。<br>关于<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement"> HTMLElement </a>可查看详细。</p><ol><li>使用 <code>--noImplicitThis</code> 配置项： </li></ol><p>在 TS2.0 还增加一个新的编译选项： <code>--noImplicitThis</code>，表示当 <code>this</code> 表达式值为 <code>any</code> 类型时生成一个错误信息。我们设置为 <code>true</code> 后就能正常编译。</p><pre><code class="json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;noImplicitThis&quot;: true  &#125;&#125;</code></pre><h2 id="七、Webpack-React-中使用示例"><a href="#七、Webpack-React-中使用示例" class="headerlink" title="七、Webpack/React 中使用示例"></a>七、Webpack/React 中使用示例</h2><h3 id="1-配置编译-ES6-代码，JSX-文件"><a href="#1-配置编译-ES6-代码，JSX-文件" class="headerlink" title="1. 配置编译 ES6 代码，JSX 文件"></a>1. 配置编译 ES6 代码，JSX 文件</h3><p>创建测试项目 webpack-demo，结构如下：</p><pre><code class="text">webpack-demo/  |- package.json  |- tsconfig.json  |- webpack.config.js  |- /dist    |- bundle.js    |- index.html  |- /src    |- index.js    |- index.ts  |- /node_modules</code></pre><p>安装 TypeScript 和 ts-loader：</p><pre><code>$ npm install --save-dev typescript ts-loader</code></pre><p>配置 tsconfig.json，支持 JSX，并将 TypeScript 编译为 ES5：</p><pre><code class="json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;outDir&quot;: &quot;./dist/&quot;,    &quot;noImplicitAny&quot;: true,+   &quot;module&quot;: &quot;es6&quot;,+   &quot;target&quot;: &quot;es5&quot;,+   &quot;jsx&quot;: &quot;react&quot;,    &quot;allowJs&quot;: true  &#125;&#125;</code></pre><p>还需要配置 webpack.config.js，使其能够处理 TypeScript 代码，这里主要在 <code>rules</code> 中添加 <code>ts-loader</code> ：</p><pre><code class="javascript">const path = require(&#39;path&#39;);module.exports = &#123;  entry: &#39;./src/index.ts&#39;,  module: &#123;    rules: [      &#123;        test: /\.tsx?$/,        use: &#39;ts-loader&#39;,        exclude: /node_modules/      &#125;    ]  &#125;,  resolve: &#123;    extensions: [ &#39;.tsx&#39;, &#39;.ts&#39;, &#39;.js&#39; ]  &#125;,  output: &#123;    filename: &#39;bundle.js&#39;,    path: path.resolve(__dirname, &#39;dist&#39;)  &#125;&#125;;</code></pre><h3 id="2-配置-source-map"><a href="#2-配置-source-map" class="headerlink" title="2. 配置 source map"></a>2. 配置 source map</h3><p>想要启用 source map，我们必须配置 TypeScript，以将内联的 source map 输出到编译后的 JavaScript 文件中。<br>只需要在 tsconfig.json 中配置 sourceMap 属性：</p><pre><code class="json">  &#123;    &quot;compilerOptions&quot;: &#123;      &quot;outDir&quot;: &quot;./dist/&quot;,+     &quot;sourceMap&quot;: true,      &quot;noImplicitAny&quot;: true,      &quot;module&quot;: &quot;commonjs&quot;,      &quot;target&quot;: &quot;es5&quot;,      &quot;jsx&quot;: &quot;react&quot;,      &quot;allowJs&quot;: true    &#125;  &#125;</code></pre><p>然后配置 webpack.config.js 文件，让 webpack 提取 source map，并内联到最终的 bundle 中：</p><pre><code class="javascript">  const path = require(&#39;path&#39;);  module.exports = &#123;    entry: &#39;./src/index.ts&#39;,+   devtool: &#39;inline-source-map&#39;,    module: &#123;      rules: [        &#123;          test: /\.tsx?$/,          use: &#39;ts-loader&#39;,          exclude: /node_modules/        &#125;      ]    &#125;,    resolve: &#123;      extensions: [ &#39;.tsx&#39;, &#39;.ts&#39;, &#39;.js&#39; ]    &#125;,    output: &#123;      filename: &#39;bundle.js&#39;,      path: path.resolve(__dirname, &#39;dist&#39;)    &#125;  &#125;;</code></pre><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>本文较全面介绍了 tsconfig.json 文件的知识，从“什么是 tsconfig.js 文件”开始，一步步带领大家全面认识 tsconfig.json 文件。<br>文中通过一个简单 learnTsconfig 项目，让大家知道项目中如何使用 tsconfig.json 文件。在后续文章中，我们将这么多的配置项进行分类学习。最后通过几个常见配置示例，解决我们开发中遇到的几个常见问题。</p><p>当然，本文篇幅有限，无法针对每个属性进行深入介绍，这就需要大家在实际开发中，多去尝试和使用啦~</p><h2 id="九、学习和参考资料"><a href="#九、学习和参考资料" class="headerlink" title="九、学习和参考资料"></a>九、学习和参考资料</h2><p>1.<a href="https://www.typescriptlang.org/tsconfig">《Intro to the TSConfig Reference》</a><br>2.<a href="https://www.tslang.cn/docs/handbook/tsconfig-json.html">《tsconfig.json》</a><br>3.<a href="http://json.schemastore.org/tsconfig">《TypeScript编译器的配置文件的JSON模式》</a><br>4.<a href="https://www.jianshu.com/p/0383bbd61a6b">《详解TypeScript项目中的tsconfig.json配置》</a><br>5.<a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html">《官方完整的编译选项列表》</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编辑器-Jetbrains系列产品重置试用方法</title>
      <link href="/2021/06/09/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E7%BC%96%E8%BE%91%E5%99%A8/%E7%BC%96%E8%BE%91%E5%99%A8-Jetbrains%E7%B3%BB%E5%88%97%E4%BA%A7%E5%93%81%E9%87%8D%E7%BD%AE%E8%AF%95%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2021/06/09/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E7%BC%96%E8%BE%91%E5%99%A8/%E7%BC%96%E8%BE%91%E5%99%A8-Jetbrains%E7%B3%BB%E5%88%97%E4%BA%A7%E5%93%81%E9%87%8D%E7%BD%AE%E8%AF%95%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>记录一下如何重置Jetbrains的产品试用时间（30天试用期）</p><span id="more"></span><h2 id="0x0-项目背景"><a href="#0x0-项目背景" class="headerlink" title="0x0. 项目背景"></a>0x0. 项目背景</h2><p>Jetbrains家的产品有一个很良心的地方，他会允许你试用<code>30</code>天（这个数字写死在代码里了）以评估是否你真的需要为它而付费。<br>但很多时候会出现一种情况：<strong>IDE并不能按照我们实际的试用时间来计算。</strong><br>我举个例子：如果我们开始了试用，然后媳妇生孩子要你回去陪产！陪产时我们并无空闲对IDE试用评估，它依旧算试用时间。（只是举个例子，或许你并没有女朋友）<br>发现了吗？你未能真的有<code>30</code>天来对它进行全面的试用评估，你甚至无法作出是否付费的决定。此时你会想要延长试用时间，然而Jetbrains并未提供相关功能，该怎么办？</p><p>事实上有一款插件可以实现这个功能，你或许可以用它来重置一下试用时间。<strong>但切记不要无休止的一直试用，这并不是这个插件的本意！</strong></p><h2 id="0x1-如何安装"><a href="#0x1-如何安装" class="headerlink" title="0x1. 如何安装"></a>0x1. 如何安装</h2><h3 id="1-插件市场安装："><a href="#1-插件市场安装：" class="headerlink" title="1). 插件市场安装："></a>1). 插件市场安装：</h3><ul><li>在<code>Settings/Preferences...</code> -&gt; <code>Plugins</code> 内手动添加第三方插件仓库地址：<code>https://plugins.zhile.io</code></li><li>搜索：<code>IDE Eval Reset</code>插件进行安装。如果搜索不到请注意是否做好了上一步？网络是否通畅？</li><li>插件会提示安装成功。</li></ul><h3 id="2-下载安装："><a href="#2-下载安装：" class="headerlink" title="2). 下载安装："></a>2). 下载安装：</h3><ul><li>点击这个<a href="https://plugins.zhile.io/files/ide-eval-resetter-2.1.14-d2fedb86.zip">链接(v2.1.14)</a>下载插件的<code>zip</code>包（macOS可能会自动解压，然后把<code>zip</code>包丢进回收站）</li><li>通常可以直接把<code>zip</code>包拖进IDE的窗口来进行插件的安装。如果无法拖动安装，你可以在<code>Settings/Preferences...</code> -&gt; <code>Plugins</code> 里手动安装插件（<code>Install Plugin From Disk...</code>）</li><li>插件会提示安装成功。</li></ul><h2 id="0x2-如何使用"><a href="#0x2-如何使用" class="headerlink" title="0x2. 如何使用"></a>0x2. 如何使用</h2><ul><li>一般来说，在IDE窗口切出去或切回来时（窗口失去/得到焦点）会触发事件，检测是否长时间（<code>25</code>天）没有重置，给通知让你选择。（初次安装因为无法获取上次重置时间，会直接给予提示）</li><li>也可以手动唤出插件的主界面：<ul><li>如果IDE没有打开项目，在<code>Welcome</code>界面点击菜单：<code>Get Help</code> -&gt; <code>Eval Reset</code></li><li>如果IDE打开了项目，点击菜单：<code>Help</code> -&gt; <code>Eval Reset</code></li></ul></li><li>唤出的插件主界面中包含了一些显示信息，2个按钮，1个勾选项：<ul><li>按钮：<code>Reload</code> 用来刷新界面上的显示信息。</li><li>按钮：<code>Reset</code> 点击会询问是否重置试用信息并<strong>重启IDE</strong>。选择<code>Yes</code>则执行重置操作并<strong>重启IDE生效</strong>，选择<code>No</code>则什么也不做。（此为手动重置方式）</li><li>勾选项：<code>Auto reset before per restart</code> 如果勾选了，则自勾选后<strong>每次重启/退出IDE时会自动重置试用信息</strong>，你无需做额外的事情。（此为自动重置方式）</li></ul></li></ul><h2 id="0x3-如何更新"><a href="#0x3-如何更新" class="headerlink" title="0x3. 如何更新"></a>0x3. 如何更新</h2><h3 id="1-插件更新机制（推荐）："><a href="#1-插件更新机制（推荐）：" class="headerlink" title="1). 插件更新机制（推荐）："></a>1). 插件更新机制（推荐）：</h3><ul><li>IDE会自行检测其自身和所安装插件的更新并给予提示。如果本插件有更新，你会收到提示看到更新日志，自行选择是否更新。</li><li>点击IDE的<code>Check for Updates...</code> 菜单手动检测IDE和所安装插件的更新。如果本插件有更新，你会收到提示看到更新日志，自行选择是否更新。</li><li>插件更新可能会需要<strong>重启IDE</strong>。</li></ul><h3 id="2-手动更新："><a href="#2-手动更新：" class="headerlink" title="2). 手动更新："></a>2). 手动更新：</h3><ul><li>从本页面下载最新的插件<code>zip</code>包安装更新。参考本文：<code>下载安装</code>小节。</li><li>插件更新需要<strong>重启IDE</strong>。</li></ul><h2 id="0x4-一些说明"><a href="#0x4-一些说明" class="headerlink" title="0x4. 一些说明"></a>0x4. 一些说明</h2><ul><li><p>本插件默认不会显示其主界面，如果你需要，参考本文：<code>如何使用</code>小节。</p></li><li><p>市场付费插件的试用信息也会<strong>一并重置</strong>。</p></li><li><p>MyBatisCodeHelperPro</p><p>插件有两个版本如下，功能完全相同，安装时须看清楚！</p><ul><li><a href="https://plugins.jetbrains.com/plugin/14522-mybatiscodehelperpro-marketplace-edition-">MyBatisCodeHelperPro (Marketplace Edition)</a>，可重置！</li><li><del><a href="https://plugins.jetbrains.com/plugin/9837-mybatiscodehelperpro">MyBatisCodeHelperPro</a>，不可重置！</del></li></ul></li><li><p>对于某些付费插件（如:Iedis2,MinBatis）来说，你可能需要去取掉javaagent配置（如果有）后重启IDE：</p><ul><li>如果IDE没有打开项目，在<code>Welcome</code>界面点击菜单：<code>Configure</code> -&gt; <code>Edit Custom VM Options...</code> -&gt; 移除 <code>-javaagent:</code> 开头的行。</li><li>如果IDE打开了项目，点击菜单：<code>Help</code> -&gt; <code>Edit Custom VM Options...</code> -&gt; 移除 <code>-javaagent:</code> 开头的行。</li></ul></li><li><p>重置需要<strong>重启IDE生效</strong>！</p></li><li><p>重置后并不弹出<code>Licenses</code>对话框让你选择输入License或试用，这和之前的重置脚本/插件不同（省去这烦人的一步）。</p></li><li><p>如果长达<code>25</code>天不曾有任何重置动作，IDE会有<strong>通知询问</strong>你是否进行重置。</p></li><li><p>如果勾选：<code>Auto reset before per restart</code> ，重置是静默无感知的。</p></li><li><p>简单来说：勾选了<code>Auto reset before per restart</code>则无需再管，一劳永逸。</p></li></ul><h2 id="0x5-开源信息"><a href="#0x5-开源信息" class="headerlink" title="0x5. 开源信息"></a>0x5. 开源信息</h2><ul><li>插件是学习研究项目，源代码是开放的。源码仓库地址：<a href="https://gitee.com/pengzhile/ide-eval-resetter">Gitee</a>。</li><li>如果你有更好的想法，欢迎给我提<code>Pull Request</code>来共同研究完善。</li><li>插件源码使用：<code>GPL-2.0</code>开源协议发布。</li><li>插件使用<code>PHP</code>编写，毕竟<code>PHP</code>是世界上最好的编程语言！</li></ul><h2 id="0x6-支持的产品"><a href="#0x6-支持的产品" class="headerlink" title="0x6. 支持的产品"></a>0x6. 支持的产品</h2><ul><li><strong>IntelliJ IDEA</strong></li><li><strong>AppCode</strong></li><li><strong>CLion</strong></li><li><strong>DataGrip</strong></li><li><strong>GoLand</strong></li><li><strong>PhpStorm</strong></li><li><strong>PyCharm</strong></li><li><strong>Rider</strong></li><li><strong>RubyMine</strong></li><li><strong>WebStorm</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Jetbrains </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6-Proxy相关</title>
      <link href="/2021/05/27/%E5%89%8D%E7%AB%AF/es6/es6-Proxy%E7%9B%B8%E5%85%B3/"/>
      <url>/2021/05/27/%E5%89%8D%E7%AB%AF/es6/es6-Proxy%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p><span id="more"></span><h2 id="一、proxy概述"><a href="#一、proxy概述" class="headerlink" title="一、proxy概述"></a>一、proxy概述</h2><p><strong>Proxy的兼容性</strong></p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210607151759.webp" alt="img"></p><blockquote><p><code>proxy</code>在目标对象的外层搭建了一层拦截，外界对目标对象的某些操作，必须通过这层拦截</p></blockquote><pre><code class="js">var proxy = new Proxy(target, handler);</code></pre><blockquote><p><code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为</p></blockquote><pre><code class="js">var target = &#123;   name: &#39;poetries&#39; &#125;; var logHandler = &#123;   get: function(target, key) &#123;     console.log(`$&#123;key&#125; 被读取`);     return target[key];   &#125;,   set: function(target, key, value) &#123;     console.log(`$&#123;key&#125; 被设置为 $&#123;value&#125;`);     target[key] = value;   &#125; &#125; var targetWithLog = new Proxy(target, logHandler);  targetWithLog.name; // 控制台输出：name 被读取 targetWithLog.name = &#39;others&#39;; // 控制台输出：name 被设置为 others  console.log(target.name); // 控制台输出: others</code></pre><ul><li><code>targetWithLog</code> 读取属性的值时，实际上执行的是 <code>logHandler.get</code> ：在控制台输出信息，并且读取被代理对象 <code>target</code> 的属性。</li><li>在 <code>targetWithLog</code> 设置属性值时，实际上执行的是 <code>logHandler.set</code> ：在控制台输出信息，并且设置被代理对象 <code>target</code> 的属性的值</li></ul><pre><code class="js">// 由于拦截函数总是返回35，所以访问任何属性都得到35var proxy = new Proxy(&#123;&#125;, &#123;  get: function(target, property) &#123;    return 35;  &#125;&#125;);proxy.time // 35proxy.name // 35proxy.title // 35</code></pre><p><strong>Proxy 实例也可以作为其他对象的原型对象</strong></p><pre><code class="js">var proxy = new Proxy(&#123;&#125;, &#123;  get: function(target, property) &#123;    return 35;  &#125;&#125;);let obj = Object.create(proxy);obj.time // 35</code></pre><blockquote><p><code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截</p></blockquote><p><strong>Proxy的作用</strong></p><blockquote><p>对于代理模式 <code>Proxy</code> 的作用主要体现在三个方面</p></blockquote><ul><li>拦截和监视外部对对象的访问</li><li>降低函数或类的复杂度</li><li>在复杂操作前对操作进行校验或对所需资源进行管理</li></ul><h2 id="二、Proxy所能代理的范围–handler"><a href="#二、Proxy所能代理的范围–handler" class="headerlink" title="二、Proxy所能代理的范围–handler"></a>二、Proxy所能代理的范围–handler</h2><blockquote><p>实际上 <code>handler</code> 本身就是<code>ES6</code>所新设计的一个对象.它的作用就是用来 自定义代理对象的各种可代理操作 。它本身一共有<code>13</code>中方法,每种方法都可以代理一种操作.其<code>13</code>种方法如下</p></blockquote><pre><code class="js">// 在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。handler.getPrototypeOf()// 在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。handler.setPrototypeOf() // 在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。handler.isExtensible() // 在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。handler.preventExtensions()// 在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, &quot;foo&quot;) 时。handler.getOwnPropertyDescriptor() // 在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, &quot;foo&quot;, &#123;&#125;) 时。andler.defineProperty() // 在判断代理对象是否拥有某个属性时触发该操作，比如在执行 &quot;foo&quot; in proxy 时。handler.has()// 在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。handler.get() // 在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。handler.set()// 在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时。handler.deleteProperty()// 在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时。handler.ownKeys()// 在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy() 时。handler.apply() // 在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时。handler.construct()</code></pre><h2 id="三、Proxy场景"><a href="#三、Proxy场景" class="headerlink" title="三、Proxy场景"></a>三、Proxy场景</h2><h3 id="3-1-实现私有变量"><a href="#3-1-实现私有变量" class="headerlink" title="3.1 实现私有变量"></a>3.1 实现私有变量</h3><pre><code class="js">var target = &#123;   name: &#39;poetries&#39;,   _age: 22&#125;var logHandler = &#123;  get: function(target,key)&#123;    if(key.startsWith(&#39;_&#39;))&#123;      console.log(&#39;私有变量age不能被访问&#39;)      return false    &#125;    return target[key];  &#125;,  set: function(target, key, value) &#123;     if(key.startsWith(&#39;_&#39;))&#123;      console.log(&#39;私有变量age不能被修改&#39;)      return false    &#125;     target[key] = value;   &#125;&#125; var targetWithLog = new Proxy(target, logHandler); // 私有变量age不能被访问targetWithLog.name;  // 私有变量age不能被修改targetWithLog.name = &#39;others&#39;; </code></pre><blockquote><p>在下面的代码中，我们声明了一个私有的 <code>apiKey</code>，便于 <code>api</code> 这个对象内部的方法调用，但不希望从外部也能够访问 <code>api._apiKey</code></p></blockquote><pre><code class="js">var api = &#123;      _apiKey: &#39;123abc456def&#39;,    /* mock methods that use this._apiKey */    getUsers: function()&#123;&#125;,     getUser: function(userId)&#123;&#125;,     setUser: function(userId, config)&#123;&#125;&#125;;// logs &#39;123abc456def&#39;;console.log(&quot;An apiKey we want to keep private&quot;, api._apiKey);// get and mutate _apiKeys as desiredvar apiKey = api._apiKey;  api._apiKey = &#39;987654321&#39;;</code></pre><blockquote><p>很显然，约定俗成是没有束缚力的。使用 <code>ES6 Proxy</code> 我们就可以实现真实的私有变量了，下面针对不同的读取方式演示两个不同的私有化方法。第一种方法是使用 <code>set / get</code> 拦截读写请求并返回 <code>undefined</code>:</p></blockquote><pre><code class="js">let api = &#123;      _apiKey: &#39;123abc456def&#39;,    getUsers: function()&#123; &#125;,     getUser: function(userId)&#123; &#125;,     setUser: function(userId, config)&#123; &#125;&#125;;const RESTRICTED = [&#39;_apiKey&#39;];api = new Proxy(api, &#123;      get(target, key, proxy) &#123;        if(RESTRICTED.indexOf(key) &gt; -1) &#123;            throw Error(`$&#123;key&#125; is restricted. Please see api documentation for further info.`);        &#125;        return Reflect.get(target, key, proxy);    &#125;,    set(target, key, value, proxy) &#123;        if(RESTRICTED.indexOf(key) &gt; -1) &#123;            throw Error(`$&#123;key&#125; is restricted. Please see api documentation for further info.`);        &#125;        return Reflect.get(target, key, value, proxy);    &#125;&#125;);// 以下操作都会抛出错误console.log(api._apiKey);api._apiKey = &#39;987654321&#39;;  </code></pre><blockquote><p>第二种方法是使用 <code>has</code> 拦截 <code>in</code> 操作</p></blockquote><pre><code class="js">var api = &#123;      _apiKey: &#39;123abc456def&#39;,    getUsers: function()&#123; &#125;,     getUser: function(userId)&#123; &#125;,     setUser: function(userId, config)&#123; &#125;&#125;;const RESTRICTED = [&#39;_apiKey&#39;];api = new Proxy(api, &#123;      has(target, key) &#123;        return (RESTRICTED.indexOf(key) &gt; -1) ?            false :            Reflect.has(target, key);    &#125;&#125;);// these log false, and `for in` iterators will ignore _apiKeyconsole.log(&quot;_apiKey&quot; in api);for (var key in api) &#123;      if (api.hasOwnProperty(key) &amp;&amp; key === &quot;_apiKey&quot;) &#123;        console.log(&quot;This will never be logged because the proxy obscures _apiKey...&quot;)    &#125;&#125;</code></pre><h3 id="3-2-抽离校验模块"><a href="#3-2-抽离校验模块" class="headerlink" title="3.2 抽离校验模块"></a>3.2 抽离校验模块</h3><blockquote><p>让我们从一个简单的类型校验开始做起，这个示例演示了如何使用 <code>Proxy</code> 保障数据类型的准确性</p></blockquote><pre><code class="js">let numericDataStore = &#123;      count: 0,    amount: 1234,    total: 14&#125;;numericDataStore = new Proxy(numericDataStore, &#123;      set(target, key, value, proxy) &#123;        if (typeof value !== &#39;number&#39;) &#123;            throw Error(&quot;Properties in numericDataStore can only be numbers&quot;);        &#125;        return Reflect.set(target, key, value, proxy);    &#125;&#125;);// 抛出错误，因为 &quot;foo&quot; 不是数值numericDataStore.count = &quot;foo&quot;;// 赋值成功numericDataStore.count = 333;</code></pre><blockquote><p>如果要直接为对象的所有属性开发一个校验器可能很快就会让代码结构变得臃肿，使用 <code>Proxy</code> 则可以将校验器从核心逻辑分离出来自成一体</p></blockquote><pre><code class="js">function createValidator(target, validator) &#123;      return new Proxy(target, &#123;        _validator: validator,        set(target, key, value, proxy) &#123;            if (target.hasOwnProperty(key)) &#123;                let validator = this._validator[key];                if (!!validator(value)) &#123;                    return Reflect.set(target, key, value, proxy);                &#125; else &#123;                    throw Error(`Cannot set $&#123;key&#125; to $&#123;value&#125;. Invalid.`);                &#125;            &#125; else &#123;                throw Error(`$&#123;key&#125; is not a valid property`)            &#125;        &#125;    &#125;);&#125;const personValidators = &#123;      name(val) &#123;        return typeof val === &#39;string&#39;;    &#125;,    age(val) &#123;        return typeof age === &#39;number&#39; &amp;&amp; val &gt; 18;    &#125;&#125;class Person &#123;      constructor(name, age) &#123;        this.name = name;        this.age = age;        return createValidator(this, personValidators);    &#125;&#125;const bill = new Person(&#39;Bill&#39;, 25);// 以下操作都会报错bill.name = 0;  bill.age = &#39;Bill&#39;;  bill.age = 15;  </code></pre><blockquote><p>通过校验器和主逻辑的分离，你可以无限扩展 <code>personValidators</code> 校验器的内容，而不会对相关的类或函数造成直接破坏。更复杂一点，我们还可以使用 <code>Proxy</code> 模拟类型检查，检查函数是否接收了类型和数量都正确的参数</p></blockquote><pre><code class="js">let obj = &#123;      pickyMethodOne: function(obj, str, num) &#123; /* ... */ &#125;,    pickyMethodTwo: function(num, obj) &#123; /*... */ &#125;&#125;;const argTypes = &#123;      pickyMethodOne: [&quot;object&quot;, &quot;string&quot;, &quot;number&quot;],    pickyMethodTwo: [&quot;number&quot;, &quot;object&quot;]&#125;;obj = new Proxy(obj, &#123;      get: function(target, key, proxy) &#123;        var value = target[key];        return function(...args) &#123;            var checkArgs = argChecker(key, args, argTypes[key]);            return Reflect.apply(value, target, args);        &#125;;    &#125;&#125;);function argChecker(name, args, checkers) &#123;      for (var idx = 0; idx &lt; args.length; idx++) &#123;        var arg = args[idx];        var type = checkers[idx];        if (!arg || typeof arg !== type) &#123;            console.warn(`You are incorrectly implementing the signature of $&#123;name&#125;. Check param $&#123;idx + 1&#125;`);        &#125;    &#125;&#125;obj.pickyMethodOne();  // &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 1// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 2// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 3obj.pickyMethodTwo(&quot;wopdopadoo&quot;, &#123;&#125;);  // &gt; You are incorrectly implementing the signature of pickyMethodTwo. Check param 1// No warnings loggedobj.pickyMethodOne(&#123;&#125;, &quot;a little string&quot;, 123);  obj.pickyMethodOne(123, &#123;&#125;);</code></pre><h3 id="3-3-访问日志"><a href="#3-3-访问日志" class="headerlink" title="3.3 访问日志"></a>3.3 访问日志</h3><blockquote><p>对于那些调用频繁、运行缓慢或占用执行环境资源较多的属性或接口，开发者会希望记录它们的使用情况或性能表现，这个时候就可以使用 <code>Proxy</code> 充当中间件的角色，轻而易举实现日志功能</p></blockquote><pre><code class="js">let api = &#123;      _apiKey: &#39;123abc456def&#39;,    getUsers: function() &#123; /* ... */ &#125;,    getUser: function(userId) &#123; /* ... */ &#125;,    setUser: function(userId, config) &#123; /* ... */ &#125;&#125;;function logMethodAsync(timestamp, method) &#123;      setTimeout(function() &#123;        console.log(`$&#123;timestamp&#125; - Logging $&#123;method&#125; request asynchronously.`);    &#125;, 0)&#125;api = new Proxy(api, &#123;      get: function(target, key, proxy) &#123;        var value = target[key];        return function(...arguments) &#123;            logMethodAsync(new Date(), key);            return Reflect.apply(value, target, arguments);        &#125;;    &#125;&#125;);api.getUsers();</code></pre><h3 id="3-4-预警和拦截"><a href="#3-4-预警和拦截" class="headerlink" title="3.4 预警和拦截"></a>3.4 预警和拦截</h3><blockquote><p>假设你不想让其他开发者删除 <code>noDelete</code> 属性，还想让调用 <code>oldMethod</code> 的开发者了解到这个方法已经被废弃了，或者告诉开发者不要修改 <code>doNotChange</code> 属性，那么就可以使用 <code>Proxy</code> 来实现</p></blockquote><pre><code class="js">let dataStore = &#123;      noDelete: 1235,    oldMethod: function() &#123;/*...*/ &#125;,    doNotChange: &quot;tried and true&quot;&#125;;const NODELETE = [&#39;noDelete&#39;];  const NOCHANGE = [&#39;doNotChange&#39;];const DEPRECATED = [&#39;oldMethod&#39;];  dataStore = new Proxy(dataStore, &#123;      set(target, key, value, proxy) &#123;        if (NOCHANGE.includes(key)) &#123;            throw Error(`Error! $&#123;key&#125; is immutable.`);        &#125;        return Reflect.set(target, key, value, proxy);    &#125;,    deleteProperty(target, key) &#123;        if (NODELETE.includes(key)) &#123;            throw Error(`Error! $&#123;key&#125; cannot be deleted.`);        &#125;        return Reflect.deleteProperty(target, key);    &#125;,    get(target, key, proxy) &#123;        if (DEPRECATED.includes(key)) &#123;            console.warn(`Warning! $&#123;key&#125; is deprecated.`);        &#125;        var val = target[key];        return typeof val === &#39;function&#39; ?            function(...args) &#123;                Reflect.apply(target[key], target, args);            &#125; :            val;    &#125;&#125;);// these will throw errors or log warnings, respectivelydataStore.doNotChange = &quot;foo&quot;;  delete dataStore.noDelete;  dataStore.oldMethod();</code></pre><h3 id="3-5-过滤操作"><a href="#3-5-过滤操作" class="headerlink" title="3.5 过滤操作"></a>3.5 过滤操作</h3><blockquote><p>某些操作会非常占用资源，比如传输大文件，这个时候如果文件已经在分块发送了，就不需要在对新的请求作出相应（非绝对），这个时候就可以使用 <code>Proxy</code> 对当请求进行特征检测，并根据特征过滤出哪些是不需要响应的，哪些是需要响应的。下面的代码简单演示了过滤特征的方式，并不是完整代码，相信大家会理解其中的妙处</p></blockquote><pre><code class="js">let obj = &#123;      getGiantFile: function(fileId) &#123;/*...*/ &#125;&#125;;obj = new Proxy(obj, &#123;      get(target, key, proxy) &#123;        return function(...args) &#123;            const id = args[0];            let isEnroute = checkEnroute(id);            let isDownloading = checkStatus(id);                  let cached = getCached(id);            if (isEnroute || isDownloading) &#123;                return false;            &#125;            if (cached) &#123;                return cached;            &#125;            return Reflect.apply(target[key], target, args);        &#125;    &#125;&#125;);</code></pre><h3 id="3-6-中断代理"><a href="#3-6-中断代理" class="headerlink" title="3.6 中断代理"></a>3.6 中断代理</h3><blockquote><p><code>Proxy</code> 支持随时取消对 <code>target</code> 的代理，这一操作常用于完全封闭对数据或接口的访问。在下面的示例中，我们使用了 <code>Proxy.revocable</code> 方法创建了可撤销代理的代理对象：</p></blockquote><pre><code class="js">let sensitiveData = &#123; username: &#39;devbryce&#39; &#125;;const &#123;sensitiveData, revokeAccess&#125; = Proxy.revocable(sensitiveData, handler);function handleSuspectedHack()&#123;      revokeAccess();&#125;// logs &#39;devbryce&#39;console.log(sensitiveData.username);handleSuspectedHack();// TypeError: Revokedconsole.log(sensitiveData.username);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-一款vue3虚拟键盘</title>
      <link href="/2021/05/25/%E5%89%8D%E7%AB%AF/vue/vue-%E4%B8%80%E6%AC%BEvue3%E8%99%9A%E6%8B%9F%E9%94%AE%E7%9B%98/"/>
      <url>/2021/05/25/%E5%89%8D%E7%AB%AF/vue/vue-%E4%B8%80%E6%AC%BEvue3%E8%99%9A%E6%8B%9F%E9%94%AE%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>一款vue虚拟键盘(支持中文和手写)插件</p><span id="more"></span><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id=""><a href="#" class="headerlink" title=""></a><a href="https://camo.githubusercontent.com/9bff910d0d964fa006eaa9af591dbccf77cfcebcd012a36b12497f50d93b5e0a/68747470733a2f2f7777772e636d61707061782e636f6d2f656469746f725265736f757263652f6b6579626f6172642f6f76657276696577312e6a7067"><img src="https://camo.githubusercontent.com/9bff910d0d964fa006eaa9af591dbccf77cfcebcd012a36b12497f50d93b5e0a/68747470733a2f2f7777772e636d61707061782e636f6d2f656469746f725265736f757263652f6b6579626f6172642f6f76657276696577312e6a7067" alt="Demo"></a></h3><h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><h3 id="特性-🎉"><a href="#特性-🎉" class="headerlink" title="特性 🎉"></a>特性 🎉</h3><ul><li>支持多达五种键盘模式</li><li>支持自定义主题色</li><li>已集成丰富的中文字库</li><li>支持急速识别的手写能力</li><li>vue3.0 组件开箱即用</li></ul><h2 id="支持环境"><a href="#支持环境" class="headerlink" title="支持环境"></a>支持环境</h2><table><thead><tr><th><img src="http://cdn.tangyuxian.com/PicGoImages/20210525161448.png" alt="IE / Edge"> Edge</th><th><img src="http://cdn.tangyuxian.com/PicGoImages/20210525162406.png" alt="Firefox">Firefox</th><th><img src="http://cdn.tangyuxian.com/PicGoImages/20210525162413.png" alt="Chrome">Chrome</th><th><img src="http://cdn.tangyuxian.com/PicGoImages/20210525162418.png" alt="Safari">Safari</th><th><img src="http://cdn.tangyuxian.com/PicGoImages/20210525162629.png" alt="Opera">Opera</th></tr></thead><tbody><tr><td>Edge</td><td>last 2 versions</td><td>last 2 versions</td><td>last 2 versions</td><td>last 2 versions</td></tr></tbody></table><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="使用-npm-或-yarn-安装"><a href="#使用-npm-或-yarn-安装" class="headerlink" title="使用 npm 或 yarn 安装"></a>使用 npm 或 yarn 安装</h3><pre><code>$ npm install vue-keyboard-virtual-next --save$ yarn add vue-keyboard-virtual-next --save</code></pre><p>如果你的网络环境不佳，推荐使用 <a href="https://github.com/cnpm/cnpm">cnpm</a>。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="全局引入"><a href="#全局引入" class="headerlink" title="全局引入"></a>全局引入</h3><pre><code class="javascript">import App from &quot;./app.vue&quot;;import &#123; createApp &#125; from &quot;vue&quot;;import &quot;vue-keyboard-virtual-next/keyboard.min.css&quot;;import KeyBoard from &quot;vue-keyboard-virtual-next&quot;;createApp(App)  .use(keyBoard)  .mount(&quot;#app&quot;);</code></pre><h3 id="局部引入"><a href="#局部引入" class="headerlink" title="局部引入"></a>局部引入</h3><pre><code class="html">&lt;template&gt;  &lt;!-- keyboard 只识别带有 data-mode 标识的输入框 --&gt;  &lt;input data-mode v-model=&quot;value&quot; /&gt;  &lt;Key-Board       :handApi=&quot;&#39;https://service.chaunve.com/HandWriteRecognizerService.asmx/Command&#39;&quot;       :color=&quot;&#39;#06f&#39;&quot;  /&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  import &quot;keyboard-virtual-vue/keyboard.min.css&quot;;  import KeyBoard from &quot;keyboard-virtual-vue&quot;;  import &#123; defineComponent, ref &#125; from &quot;vue&quot;;  export default defineComponent(&#123;    components: &#123; KeyBoard &#125;,    setup() &#123;      const value = ref&lt;string&gt;(&quot;你好&quot;);      return &#123;        value,      &#125;;    &#125;,  &#125;);&lt;/script&gt;</code></pre><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><h3 id="Input标签属性"><a href="#Input标签属性" class="headerlink" title="Input标签属性"></a>Input标签属性</h3><table><thead><tr><th>属性</th><th>说明</th><th>类型</th><th>可选值</th><th>默认值</th></tr></thead><tbody><tr><td><strong>data-mode</strong></td><td>弹出输入法的类型： <code>en</code> 英文小写 <code>number</code>数字 <code>symbol</code> 标点 <code>handwrite</code> 手写 <code>不传</code> 默认中文</td><td>String</td><td><code>en</code> <code>number</code> <code>symbol</code> <code>handwrite</code></td><td><code>default as *</code></td></tr><tr><td><strong>data-prop</strong></td><td>注册的输入框的类型</td><td>String</td><td>*</td><td></td></tr></tbody></table><h3 id="Props属性"><a href="#Props属性" class="headerlink" title="Props属性"></a>Props属性</h3><table><thead><tr><th>参数</th><th>说明</th><th>默认值</th><th>类型</th><th>是否必须</th><th>版本</th></tr></thead><tbody><tr><td>v-model</td><td><em>绑定的输入框value</em>,可同时双向绑定多个输入框，不传则只与当前focus输入框做数据绑定关系</td><td></td><td>string|number</td><td>否</td><td>v1.0.0+</td></tr><tr><td>color</td><td><em>主题色</em></td><td><code>#eaa050</code></td><td>string</td><td>否</td><td>v1.0.0+</td></tr><tr><td>modeList</td><td><em>键盘渲染模式列表</em>，若不传handApi则不会出现手写板</td><td>[“handwrite”, “symbol”]</td><td>string[]</td><td>否</td><td>v1.0.0+</td></tr><tr><td>blurHide</td><td><em>是否当前输入框blur事件触发隐藏</em></td><td>true</td><td>boolean</td><td>否</td><td>v1.0.0+</td></tr><tr><td>showHandleBar</td><td><em>是否显示拖拽句柄</em></td><td>true</td><td>boolean</td><td>否</td><td>v1.0.0+</td></tr><tr><td>dargHandleText</td><td>拖拽句柄提示文字</td><td></td><td>string</td><td>否</td><td>v1.0.0+</td></tr><tr><td>modal</td><td><em>是否显示遮罩层</em></td><td>false</td><td>boolean</td><td>否</td><td>v1.0.0+</td></tr><tr><td>closeOnClickModal</td><td>是否点击遮罩层隐藏键盘</td><td>true</td><td>boolean</td><td>否</td><td>v1.0.0+</td></tr><tr><td>handApi</td><td>手写识别接口，若不传则无法切换手写模块</td><td></td><td>string</td><td>否</td><td>v1.0.0+</td></tr><tr><td>animateClass</td><td>键盘显隐动画，内置slide动画，如若需要其他动画，可传入相应类名自定义动画</td><td></td><td>string</td><td>否</td><td>v1.0.0+</td></tr></tbody></table><h3 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h3><table><thead><tr><th>参数</th><th>说明</th><th>类型</th><th>版本</th></tr></thead><tbody><tr><td>keyChange</td><td>按键触发事件，第一个参数为当前触发的按键的标识,<code>第二个参数为当前聚焦输入框的props值，若没有则直接返回当前聚焦的input元素（v1.0.1版本之后）</code></td><td>(<em>value</em>: string,prop:string|HTMLInputElement) =&gt; void</td><td>v1.0.0+</td></tr><tr><td>change</td><td>value改变事件，第一个参数为当前最新通过键盘输入的值，<code>第二个参数为当前聚焦输入框的props值，若没有则直接返回当前聚焦的input元素（v1.0.1版本之后）</code></td><td>(<em>value</em>: string,prop:string|HTMLInputElement) =&gt; void</td><td>v1.0.0+</td></tr><tr><td>closed</td><td>键盘关闭事件</td><td>() =&gt; void</td><td>v1.0.0+</td></tr><tr><td>modalClick</td><td>遮罩点击事件</td><td>() =&gt; void</td><td>v1.0.0+</td></tr></tbody></table><h2 id="Component-Event"><a href="#Component-Event" class="headerlink" title="Component Event"></a>Component Event</h2><table><thead><tr><th>方法名</th><th>说明</th><th>类型</th><th>版本</th></tr></thead><tbody><tr><td>reSignUp</td><td>重新给input注册绑定键盘,当页面有新的input标签出现时调用此方法</td><td>（）=&gt; void</td><td>v1.0.0+</td></tr><tr><td>getCurrentInput</td><td>获取当前聚焦的输入框</td><td>（）=&gt; HTMLInputElement | null</td><td>v1.0.1+</td></tr></tbody></table><pre><code class="html">&lt;template&gt;  &lt;!-- keyboard 只识别带有 data-mode 标识的输入框 --&gt;  &lt;input data-mode v-model=&quot;value&quot; /&gt;  &lt;Key-Board       :handApi=&quot;&#39;https://service.chaunve.com/HandWriteRecognizerService.asmx/Command&#39;&quot;       :color=&quot;&#39;#06f&#39;&quot;  /&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &quot;vue-keyboard-virtual-next/keyboard.min.css&quot;;import KeyBoard from &quot;vue-keyboard-virtual-next&quot;;import &#123; defineComponent, ref, onMounted &#125; from &quot;vue&quot;;export default defineComponent(&#123;  components: &#123; KeyBoard &#125;,  setup() &#123;    const value = ref&lt;string&gt;(&quot;你好&quot;);    const keyBoardRef = ref&lt;typeof KeyBoard | null&gt;(null);          onMounted(() =&gt; &#123;        // xxxx逻辑 给键盘重新注册输入框        keyBoardRef.value?.reSignUp();    &#125;)          return &#123;      value,      keyBoardRef    &#125;;  &#125;,&#125;);&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 工具 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-TLS/SSL握手过程</title>
      <link href="/2021/05/19/%E5%90%8E%E7%AB%AF/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-TLS-SSL%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/"/>
      <url>/2021/05/19/%E5%90%8E%E7%AB%AF/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-TLS-SSL%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>TLS握手的过程，其实就是秘钥交换的过程</p><span id="more"></span><p>TLS握手的过程，其实就是<strong>秘钥</strong>交换的过程，这也是整个TLS加密技术里最复杂的一个环节，因为客户端与服务器端协商秘钥的过程对第三方都是透明的，那么秘钥协商的过程不仅要保证<strong>秘钥</strong>的保密性，还要考虑<strong>前向安全性</strong>。</p><h3 id="A-RSA算法交换秘钥"><a href="#A-RSA算法交换秘钥" class="headerlink" title="A. RSA算法交换秘钥"></a>A. <strong>RSA算法交换秘钥</strong></h3><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210519154823.jpg" alt="img"> </p><p><strong>RSA交换秘钥流程：</strong></p><p>1：服务器给客户端发送数字证书(服务器公钥、域名、CA签名)。</p><p>2：使用CA公钥对证书进行验签，验签成功即可证明服务器身份(公钥合法，没被篡改)。</p><p>3：生成对称加密的秘钥，使用公钥对其加密，发送给服务器。</p><p>4：服务器使用私钥解密，得到对称加密的秘钥。</p><p>5：客户端与服务器使用对称加密传输数据。</p><p><strong>优点</strong>：通俗易懂，实现方便。</p><p><strong>缺点</strong>：不具备<strong>前向安全性</strong>，因为使用RSA非对称加密参与了秘钥的协商过程，一旦将来私钥泄漏，那么之前所有的传输数据，都可以被解密。目前这种方式已经被淘汰了。</p><h3 id="B-Diffie-Hellman算法交换秘钥"><a href="#B-Diffie-Hellman算法交换秘钥" class="headerlink" title="B. Diffie-Hellman算法交换秘钥"></a>B. <strong>Diffie-Hellman算法交换秘钥</strong></h3><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210519154830.png" alt="image-20210519153341372"></p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210519154836.png" alt="image-20210519153845069"></p><p><strong>优点</strong>：RSA不参与协商秘钥，协商过程使用的参数N\G\X\Y都是一次性的，在客户端可服务器的内存中，即使销毁，整个加密过程具有<strong>前向安全性</strong>。</p><p><strong>缺点</strong>：计算需要很大的系统开销，效率低下。目前这种方式也已经不被使用了。</p><h3 id="A-ECDHE椭圆曲线算法交换秘钥"><a href="#A-ECDHE椭圆曲线算法交换秘钥" class="headerlink" title="A. ECDHE椭圆曲线算法交换秘钥"></a>A. <strong>ECDHE椭圆曲线算法交换秘钥</strong></h3><p>ECDHE 算法是在 DHE 算法的基础上利用了 ECC 椭圆曲线特性，可以使用较少的开销计算出会话密钥。定理的推导过程：<a href="https://zhuanlan.zhihu.com/p/66794410">https://zhuanlan.zhihu.com/p/66794410</a> 可以参考此文章。</p><p>我用 Wireshark 工具抓了用 ECDHE 密钥协商算法的 TSL 握手过程，可以看到是四次握手：</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210519154843.jpg" alt="img"> </p><h4 id="a-TLS-第一次握手"><a href="#a-TLS-第一次握手" class="headerlink" title="a. TLS 第一次握手"></a>a. <strong>TLS 第一次握手</strong></h4><p>客户端首先会发一个「<strong>Client Hello</strong>」消息，消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的随机数（Client Random）。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210519154850.jpg" alt="img"> </p><h4 id="b-TLS-第二次握手"><a href="#b-TLS-第二次握手" class="headerlink" title="b. TLS 第二次握手"></a>b. <strong>TLS 第二次握手</strong></h4><p>服务端收到客户端的「<strong>Client Hello</strong>」，会返回「<strong>Server Hello</strong>」消息，消息面有服务器确认的 TLS 版本号，也给出了一个随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210519154855.jpg" alt="img"> </p><p>密码套件：Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA</p><p>密钥协商算法使用 ECDHE</p><p>签名算法使用 RSA</p><p>握手后的通信使用 AES 对称算法，密钥长度 128位，分组模式是CBC</p><p>摘要算法使用 SHA</p><p>接着，服务端为了证明自己的身份，发送「<strong>Certificate</strong>」消息，会把证书也发给客户端。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210519154900.jpg" alt="img"> </p><p>继续发送「<strong>Server Key Exchange</strong>」消息</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210519154906.jpg" alt="img"> </p><p>这个过程服务器做了三件事：</p><ol><li><p>选择了名为 named_curve 的椭圆曲线，选好了椭圆曲线相当于椭圆曲线基点 G 也定好了，这些都会公开给客户端。</p></li><li><p>生成随机数作为服务端椭圆曲线的私钥，保留到本地。</p></li><li><p>根据基点 G 和私钥计算出服务端的椭圆曲线公钥，这个会公开给客户端。为了保证这个椭圆曲线的公钥不被第三方篡改，服务端会用 RSA 签名算法给服务端的椭圆曲线公钥做个签名。</p></li></ol><p>继续发送[<strong>Server Hello Done</strong>」消息，服务端跟客户端表明：“这些就是我提供的信息，打招呼完毕”。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210519154912.jpg" alt="img"> </p><p>至此，TLS 两次握手就已经完成了，目前客户端和服务端通过明文共享了这几个信息：<strong>Client Random</strong>、<strong>Server Random</strong> 、<strong>使用的椭圆曲线</strong>、<strong>椭圆曲线基点 G</strong>、<strong>服务端椭圆曲线的公钥</strong>，这几个信息很重要，是后续生成会话密钥的材料。</p><h4 id="c-TLS-第三次握手"><a href="#c-TLS-第三次握手" class="headerlink" title="c. TLS 第三次握手"></a>c. <strong>TLS 第三次握手</strong></h4><p>客户端收到了服务端的证书后，自然要校验证书是否合法，如果证书合法，那么服务端到身份就是没问题的。校验证书到过程，会使用CA的公钥验证证书的签名，没问题了就可以继续往下进行。</p><p><strong>如果证书验证不合法：</strong></p><p>如果是Chrome浏览器，会给出警告提示，告诉你证书来源不合法，例如当年的12306，当然你也可以忽略警告，继续使用该证书也是可以的。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210519154925.jpg" alt="img"> </p><p>如果是SSL客户端程序，例如JAVA，会抛出证书验证不合法的错误。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210519154931.jpg" alt="img"> </p><p>Caused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: <strong>unable to find valid certification path to requested target</strong></p><p><strong>解决办法：</strong></p><p>1：去官方的CA认证中心对证书进行签名。</p><p>2：将我们自己创建的根证书提前导入浏览器。</p><p>3：配置客户端不检查证书来源。</p><p>客户端会生成一个随机数作为客户端椭圆曲线的私钥，然后再根据服务端前面给的信息，生成客户端的椭圆曲线公钥，然后用「<strong>Client Key Exchange</strong>」消息发给服务端。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210519154950.jpg" alt="img"> </p><p>至此，双方都有对方的椭圆曲线公钥、自己的椭圆曲线私钥、椭圆曲线基点 G。于是，双方都就计算出了共享秘钥。</p><p>还记得 TLS 握手阶段，客户端和服务端都会生成了一个随机数传递给对方吗？</p><p>最终的<strong>对称加密密钥</strong>，就是用「<strong>客户端随机数</strong> + <strong>服务端随机数</strong> + （<strong>ECDHE 算法算出的共享密钥</strong>） 」三个材料生成的。</p><p>之所以这么麻烦，是因为 TLS 设计者不信任客户端或服务器「伪随机数」的可靠性，为了保证真正的完全随机，把三个不可靠的随机数混合起来，那么「随机」的程度就非常高了，安全性更高。</p><p>算好会话密钥后，客户端会发一个「****Change Cipher Spec****」消息，告诉服务端后续改用对称算法加密通信。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210519155016.jpg" alt="img"> </p><p>接着，客户端会发「<strong>Encrypted Handshake Message</strong>」消息，把之前发送的数据做一个摘要，再用对称密钥加密一下，让服务端做个验证，验证下本次生成的对称密钥是否可以正常使用。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210519155021.jpg" alt="img"> </p><h4 id="d-TLS第四次握手"><a href="#d-TLS第四次握手" class="headerlink" title="d. TLS第四次握手"></a>d. <strong>TLS第四次握手</strong></h4><p>最后，服务端也会有一个同样的操作，发「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息，如果双方都验证加密和解密没问题，那么握手正式完成。于是，就可以正常收发加密的 HTTP 请求和响应了。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210519155106.jpg" alt="img"> </p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210519155047.jpg" alt="img"> </p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-TLS/SSL介绍及加解密过程</title>
      <link href="/2021/05/18/%E5%90%8E%E7%AB%AF/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-TLS-SSL%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%8A%A0%E8%A7%A3%E5%AF%86%E8%BF%87%E7%A8%8B/"/>
      <url>/2021/05/18/%E5%90%8E%E7%AB%AF/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-TLS-SSL%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%8A%A0%E8%A7%A3%E5%AF%86%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>简单了解TLS/SSL加解密过程</p><span id="more"></span><h2 id="1-TLS-SSL基本介绍"><a href="#1-TLS-SSL基本介绍" class="headerlink" title="1. TLS\SSL基本介绍"></a>1. <strong>TLS\SSL基本介绍</strong></h2><p>SSL(Secure Sockets Layer <a href="https://baike.baidu.com/item/%E5%AE%89%E5%85%A8%E5%A5%97%E6%8E%A5%E5%AD%97%E5%8D%8F%E8%AE%AE">安全套接字协议</a>),及其继任者<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%89%E5%85%A8">传输层安全</a>（Transport Layer Security，TLS）是为<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/9636548">网络通信</a>提供安全及<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7/110071">数据完整性</a>的一种安全协议。TLS与SSL在<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%B1%82/4329536">传输层</a>与<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E5%B1%82/16412033">应用层</a>之间对网络连接进行加密，SSL与TLS是一个东西。</p><p>无论是HTTPS(http传输加密)、WSS(websocket:ws传输加密)、还是其它应用程序之间的TLS传输，都与应用层协议无关，只是在TCP基础之上增加了一个加密过程。</p><p><strong>TLS加密原理图：</strong></p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210518154506.jpg" alt="img"> </p><h2 id="2-安装抓包工具"><a href="#2-安装抓包工具" class="headerlink" title="2. 安装抓包工具"></a>2. <strong>安装抓包工具</strong></h2><h3 id="A-官方下载地址"><a href="#A-官方下载地址" class="headerlink" title="A. 官方下载地址"></a>A. <strong>官方下载地址</strong></h3><p><a href="https://www.wireshark.org/download.html">https://www.wireshark.org/download.html</a></p><p>安装完成后打开软件，可以看到本机网卡列表，后续我们通过它抓包来学习TLS.</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210518154556.jpg" alt="img"> </p><h3 id="B-配置解密TSL数据"><a href="#B-配置解密TSL数据" class="headerlink" title="B. 配置解密TSL数据"></a>B. <strong>配置解密TSL数据</strong></h3><p><a href="https://liuhuaqiang.blog.csdn.net/article/details/80887436(%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B)">https://liuhuaqiang.blog.csdn.net/article/details/80887436(配置教程)</a></p><p>配置系统环境变量，SSLKEYLOGFILE  =  C:\ssl_key\sslog.log（注意后缀名一定用log不然不好使，不知道为啥）,这样浏览器和WEB服务器协商的TLS秘钥信息会存储到文件中，我们就可以利用Wireshark解密了。注意：C:\ssl_key文件夹需要手动创建。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210518154604.jpg" alt="img"> </p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210518154609.jpg" alt="img"> </p><h3 id="C-抓取本机地址数据包"><a href="#C-抓取本机地址数据包" class="headerlink" title="C. 抓取本机地址数据包"></a>C. <strong>抓取本机地址数据包</strong></h3><p>如果服务器与客户端都在同一台机器，正常客户端数据包是不走网卡的，所以正常情况抓不到，需要配置路由表，强制本机数据包也走网卡：</p><p>1.以管理员身份运行cmd</p><p>2.route add 本机ip mask 255.255.255.255 网关ip</p><p>如：route add 172.16.51.115 mask 255.255.255.255 172.16.1.1</p><p>使用完毕后用route delete 172.16.51.115 mask 255.255.255.255 172.16.1.1删除，否则所有本机报文都经过网卡出去走一圈回来很耗性能。</p><h2 id="3-配置Nginx-Https"><a href="#3-配置Nginx-Https" class="headerlink" title="3. 配置Nginx-Https"></a>3. <strong>配置Nginx-Https</strong></h2><p>nginx配置https需要用到私钥和证书，把前面生成好的直接拿来用(private_key_pkcs1.pem cert_x509.crt)。</p><p><strong>安装nginx</strong></p><pre><code>yum install epel-releaseyum updateyum install nginxsudo nginx -vnginx version: nginx/1.6.3</code></pre><p><strong>配置Https</strong></p><p>使用我们前面创建的pkcs#1格式的私钥和X509格式的证书。</p><pre><code> server &#123;  listen    443 ssl;  server_name  test_https;    root     /usr/share/nginx/html;     ssl_certificate &quot;/etc/nginx/certs/cert_x509.crt&quot;;    ssl_certificate_key &quot;/etc/nginx/certs/private_key_pkcs1.pem&quot;;    ssl_session_cache shared:SSL:1m;    ssl_session_timeout  10m;    ssl_ciphers HIGH:!aNULL:!MD5;    ssl_prefer_server_ciphers on;     location / &#123;    &#125;     error_page 404 /404.html;    location = /404.html &#123;    &#125;     error_page 500 502 503 504 /50x.html;    location = /50x.html &#123;    &#125;  &#125;</code></pre><p><strong>启动Nginx</strong></p><pre><code>systemctl start nginxsystemctl enable nginx</code></pre><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210518154621.png" alt="image-20210518154028092"></p><p>查看抓包效果，看到浏览器与Nginx通讯的数据已经全部抓到。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210518154627.png" alt="image-20210518154015760"></p><h2 id="4-TLS-SSL加解密过程"><a href="#4-TLS-SSL加解密过程" class="headerlink" title="4. TLS\SSL加解密过程"></a>4. TLS\SSL加解密过程</h2><p>我们首选使用普通socket明文传输，然后抓包，可以看到TCP三次握手以后就开始发数据了，数据是明文的，很容易被第三方窃。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210518154634.jpg" alt="img"> </p><p>我们查看数据包，通过wireshark可以抓取到明文内容helloAlice，数据是没有被加密的。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210518154639.jpg" alt="img"> </p><p>接下来我们来看看使用TLS以后的传输过程，除了TCP的三次握手以外，还多了SSL握手的数据包，握手的过程就是协商对称加密的秘钥，然后再发送数据。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210518154645.jpg" alt="img"> </p><p>我们打开ApplicationData查看TCP报文，数据被加密，已经看不到明文信息了。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210518154651.jpg" alt="img"> </p><p>SSL属于应用层协议，在普通Socket传输基础之上增加了一个TLS层，负责加密与解密数据，加密解密使用对称加密算法完成，客户端与服务器端使用相同的秘钥。由于交换秘钥算法比较复杂，一般高级语言都提供了相应类库，屏蔽了底层的细节，我们直接使用即可。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210518154657.jpg" alt="img"> </p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-RSA非对称加密</title>
      <link href="/2021/05/13/%E5%90%8E%E7%AB%AF/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-RSA%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
      <url>/2021/05/13/%E5%90%8E%E7%AB%AF/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-RSA%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>1977年，三位数学家Rivest[瑞斯特]、Shamir[沙米尔] 和 Adleman [阿德尔曼]设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法。</p><span id="more"></span><h2 id="1-RSA算法的起源"><a href="#1-RSA算法的起源" class="headerlink" title="1. RSA算法的起源"></a>1. <strong>RSA</strong>算法的起源</h2><p>1977年，三位数学家Rivest[瑞斯特]、Shamir[沙米尔] 和 Adleman [阿德尔曼]设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210513172712.jpg" alt="img"> </p><h2 id="2-RSA算法的特点"><a href="#2-RSA算法的特点" class="headerlink" title="2. RSA算法的特点"></a>2. <strong>RSA</strong>算法的特点</h2><p>RSA非对称加密算法在加密和解密时需要二个秘钥，称为：公钥和私钥，也可称作密钥对。</p><p>A. 公钥加密的数据只有与之对应的私钥才能解密。</p><p>B. 私钥加密的数据只有与之对应的公钥才能解密。</p><p>C. 我们可以创建很对的秘钥对，但是不同秘钥对之间不能够加密和解密。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210513172718.jpg" alt="img"> </p><h2 id="3-RSA数学定理"><a href="#3-RSA数学定理" class="headerlink" title="3. RSA数学定理"></a>3. <strong>RSA数学定理</strong></h2><p>加密定理：</p><blockquote><p> m^e ≡ c(mod n)</p></blockquote><p>解密定理：</p><blockquote><p> c^d ≡ m (mod n)<br>其中[n,e]就是公钥[3233, 17]，[n,d]就是私钥[3233, 2753]。</p></blockquote><p>m是明文65 ，c是密文2790。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210513172723.jpg" alt="img"> </p><h2 id="4、密钥生成的步骤"><a href="#4、密钥生成的步骤" class="headerlink" title="4、密钥生成的步骤"></a><strong>4、密钥生成的步骤</strong></h2><p>我们通过一个例子，来理解RSA算法。假设<a href="http://zh.wikipedia.org/wiki/%E7%88%B1%E4%B8%BD%E4%B8%9D%E4%B8%8E%E9%B2%8D%E4%BC%AF">爱丽丝</a>要与鲍勃进行加密通信，她该怎么生成公钥和私钥呢？</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/201307/bg2013070302.png" alt="img"></p><p><strong>第一步，随机选择两个不相等的质数p和q。</strong></p><p>爱丽丝选择了61和53。（实际应用中，这两个质数越大，就越难破解。）</p><p><strong>第二步，计算p和q的乘积n。</strong></p><p>爱丽丝就把61和53相乘。</p><blockquote><p>　　n = 61×53 = 3233</p></blockquote><p>n的长度就是密钥长度。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。</p><p><strong>第三步，计算n的欧拉函数φ(n)。</strong></p><p>根据公式：</p><blockquote><p>　　φ(n) = (p-1)(q-1)</p></blockquote><p>爱丽丝算出φ(3233)等于60×52，即3120。</p><p><strong>第四步，随机选择一个整数e，条件是1&lt; e &lt; φ(n)，且e与φ(n) 互质。</strong></p><p>爱丽丝就在1到3120之间，随机选择了17。（实际应用中，常常选择65537。）</p><p><strong>第五步，计算e对于φ(n)的模反元素d。</strong></p><p>所谓<a href="http://zh.wikipedia.org/wiki/%E6%A8%A1%E5%8F%8D%E5%85%83%E7%B4%A0">“模反元素”</a>就是指有一个整数d，可以使得ed被φ(n)除的余数为1。</p><blockquote><p>　　ed ≡ 1 (mod φ(n))</p></blockquote><p>这个式子等价于</p><blockquote><p>　　ed - 1 = kφ(n)</p></blockquote><p>于是，找到模反元素d，实质上就是对下面这个二元一次方程求解。</p><blockquote><p>　　ex + φ(n)y = 1</p></blockquote><p>已知 e=17, φ(n)=3120，</p><blockquote><p>　　17x + 3120y = 1</p></blockquote><p>这个方程可以用<a href="http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">“扩展欧几里得算法”</a>求解，此处省略具体过程。总之，爱丽丝算出一组整数解为 (x,y)=(2753,-15)，即 d=2753。</p><p>至此所有计算完成。</p><p><strong>第六步，将n和e封装成公钥，n和d封装成私钥。</strong></p><p>在爱丽丝的例子中，n=3233，e=17，d=2753，所以公钥就是 (3233,17)，私钥就是（3233, 2753）。</p><p>实际应用中，公钥和私钥的数据都采用<a href="http://zh.wikipedia.org/zh-cn/ASN.1">ASN.1</a>格式表达（<a href="http://hi.baidu.com/mathack/item/d0ad4cc1514a3663f7c95da2">实例</a>）。</p><h2 id="5、RSA算法的可靠性"><a href="#5、RSA算法的可靠性" class="headerlink" title="5、RSA算法的可靠性"></a><strong>5、RSA算法的可靠性</strong></h2><p>回顾上面的密钥生成步骤，一共出现六个数字：</p><blockquote><p>　　p<br>　　q<br>　　n<br>　　φ(n)<br>　　e<br>　　d</p></blockquote><p>这六个数字之中，公钥用到了两个（n和e），其余四个数字都是不公开的。其中最关键的是d，因为n和d组成了私钥，一旦d泄漏，就等于私钥泄漏。</p><p><strong>那么，有无可能在已知n和e的情况下，推导出d？</strong></p><blockquote><p>　　（1）ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。</p><p>　　（2）φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。</p><p>　　（3）n=pq。只有将n因数分解，才能算出p和q。</p></blockquote><p><strong>结论：如果n可以被因数分解，d就可以算出，也就意味着私钥被破解。</strong></p><p>可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。维基百科这样写道：</p><blockquote><p>　　“对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。</p><p>　　假如有人找到一种快速因数分解的算法，那么RSA的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA密钥才可能被暴力破解。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。</p><p>　　只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。”</p></blockquote><p>举例来说，你可以对3233进行因数分解（61×53），但是你没法对下面这个整数进行因数分解。</p><blockquote><p>　　12301866845301177551304949<br>　　58384962720772853569595334<br>　　79219732245215172640050726<br>　　36575187452021997864693899<br>　　56474942774063845925192557<br>　　32630345373154826850791702<br>　　61221429134616704292143116<br>　　02221240479274737794080665<br>　　351419597459856902143413</p></blockquote><p>它等于这样两个质数的乘积：</p><blockquote><p>　　33478071698956898786044169<br>　　84821269081770479498371376<br>　　85689124313889828837938780<br>　　02287614711652531743087737<br>　　814467999489<br>　　　　×<br>　　36746043666799590428244633<br>　　79962795263227915816434308<br>　　76426760322838157396665112<br>　　79233373417143396810270092<br>　　798736308917</p></blockquote><p>事实上，这大概是人类已经分解的最大整数（232个十进制位，768个二进制位）。比它更大的因数分解，还没有被报道过，因此目前被破解的最长RSA密钥就是768位。</p><h2 id="6、加密和解密"><a href="#6、加密和解密" class="headerlink" title="6、加密和解密"></a><strong>6、加密和解密</strong></h2><p>有了公钥和密钥，就能进行加密和解密了。</p><p><strong>（1）加密要用公钥 (n,e)</strong></p><p>假设鲍勃要向爱丽丝发送加密信息m，他就要用爱丽丝的公钥 (n,e) 对m进行加密。这里需要注意，m必须是整数（字符串可以取ascii值或unicode值），且m必须小于n。</p><p>所谓”加密”，就是算出下式的c：</p><blockquote><p>　　m^e ≡ c (mod n)</p></blockquote><p>爱丽丝的公钥是 (3233, 17)，鲍勃的m假设是65，那么可以算出下面的等式：</p><blockquote><p>　　65^17 ≡ 2790 (mod 3233)</p></blockquote><p>于是，c等于2790，鲍勃就把2790发给了爱丽丝。</p><p><strong>（2）解密要用私钥(n,d)</strong></p><p>爱丽丝拿到鲍勃发来的2790以后，就用自己的私钥(3233, 2753) 进行解密。可以证明，下面的等式一定成立：</p><blockquote><p>　　c^d ≡ m (mod n)</p></blockquote><p>也就是说，c的d次方除以n的余数为m。现在，c等于2790，私钥是(3233, 2753)，那么，爱丽丝算出</p><blockquote><p>　　2790^2753 ≡ 65 (mod 3233)</p></blockquote><p>因此，爱丽丝知道了鲍勃加密前的原文就是65。</p><p>至此，”加密–解密”的整个过程全部完成。</p><p>我们可以看到，如果不知道d，就没有办法从c求出m。而前面已经说过，要知道d就必须分解n，这是极难做到的，所以RSA算法保证了通信安全。</p><p>你可能会问，公钥(n,e) 只能加密小于n的整数m，那么如果要加密大于n的整数，该怎么办？有两种解决方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种”对称性加密算法”（比如<a href="https://zh.wikipedia.org/wiki/%E8%B5%84%E6%96%99%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86">DES</a>），用这种算法的密钥加密信息，再用RSA公钥加密DES密钥。</p><h2 id="7、私钥解密的证明"><a href="#7、私钥解密的证明" class="headerlink" title="7、私钥解密的证明"></a><strong>7、私钥解密的证明</strong></h2><p>最后，我们来证明，为什么用私钥解密，一定可以正确地得到m。也就是证明下面这个式子：</p><blockquote><p>　　c^d ≡ m (mod n)</p></blockquote><p>因为，根据加密规则</p><blockquote><p>　　ｍ^e ≡ c (mod n)</p></blockquote><p>于是，c可以写成下面的形式：</p><blockquote><p>　　c = m^e - kn</p></blockquote><p>将c代入要我们要证明的那个解密规则：</p><blockquote><p>　　(m^e - kn)^d ≡ m (mod n)</p></blockquote><p>它等同于求证</p><blockquote><p>　　m^ed ≡ m (mod n)</p></blockquote><p>由于</p><blockquote><p>　　ed ≡ 1 (mod φ(n))</p></blockquote><p>所以</p><blockquote><p>　　ed = hφ(n)+1</p></blockquote><p>将ed代入：</p><blockquote><p>　　m^(hφ(n)+1) ≡ m (mod n)</p></blockquote><p>接下来，分成两种情况证明上面这个式子。</p><p><strong>（1）m与n互质。</strong></p><p>根据欧拉定理，此时</p><blockquote><p>　　mφ(n) ≡ 1 (mod n)</p></blockquote><p>得到</p><blockquote><p>　　(m^φ(n))^h × m ≡ m (mod n)</p></blockquote><p>原式得到证明。</p><p><strong>（2）m与n不是互质关系。</strong></p><p>此时，由于n等于质数p和q的乘积，所以m必然等于kp或kq。</p><p>以 m = kp为例，考虑到这时k与q必然互质，则根据欧拉定理，下面的式子成立：</p><blockquote><p>　　(kp)^(q-1) ≡ 1 (mod q)</p></blockquote><p>进一步得到</p><blockquote><p>　　[(kp)^(q-1)]^(h(p-1) ) × kp ≡ kp (mod q)</p></blockquote><p>即</p><blockquote><p>　　(kp)^ed ≡ kp (mod q)</p></blockquote><p>将它改写成下面的等式</p><blockquote><p>　　(kp)^ed = tq + kp</p></blockquote><p>这时t必然能被p整除，即 t=t’p</p><blockquote><p>　　(kp)^ed = t’pq + kp</p></blockquote><p>因为 m=kp，n=pq，所以</p><blockquote><p>　　m^ed ≡ m (mod n)</p></blockquote><p>原式得到证明。</p><hr><p>部分内容摘自:<a href="https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">阮一峰的网络日志:RSA算法原理（二）</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-对称加密</title>
      <link href="/2021/05/13/%E5%90%8E%E7%AB%AF/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
      <url>/2021/05/13/%E5%90%8E%E7%AB%AF/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>加密和解密使用同样规则（”密钥”），这种算法被称为：”对称加密算法”。</p><span id="more"></span><p>1976年以前，所有的加密方法都是同一种模式，甲方选择某一种加密规则，对信息进行加密，乙方使用同一种规则，对信息进行解密，由于加密和解密使用同样规则（”密钥”），这种算法被称为：”对称加密算法”。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210513155053.jpg" alt="img"> </p><p>JAVA加密解密示例代码</p><pre><code class="java">package com.netty.demo.rsa; import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.security.SecureRandom; public class HexTest &#123;   /**   \* AES/ECB/PKCS5Padding (128)   \* AES加密 ECB模式 PKCS5填充方式 密钥长度必须为16个字节(128位)   */  public static void main(String[] args) throws Exception &#123;​    //密钥生成器​    KeyGenerator kgen = KeyGenerator.getInstance(&quot;AES&quot;);​    //设置密钥长度128位​    kgen.init(128, new SecureRandom());​    //生成key​    SecretKey key = kgen.generateKey(); ​    //长度为16的二进制数组，密钥我们自己生成也可以.​    byte[] keyBytes = key.getEncoded();​    System.out.println(&quot;秘钥长度是:&quot; + keyBytes.length + &quot;字节(byte) &quot; + keyBytes.length*8 +&quot;位(bit)&quot;); ​    //创建AES的密钥​    SecretKeySpec aesKey = new SecretKeySpec(keyBytes, &quot;AES&quot;); ​    //加密 模式 填充方式​    Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);​    cipher.init(Cipher.ENCRYPT_MODE, aesKey); ​    //加密​    byte[] encrypt = cipher.doFinal(&quot;Hello Alice&quot;.getBytes());​    System.out.println(&quot;加密后的字符串:&quot; + new String(encrypt)); ​    //解密​    cipher.init(Cipher.DECRYPT_MODE, aesKey);​    byte[] decrypt = cipher.doFinal(encrypt);​    System.out.println(&quot;解密后的字符串:&quot; + new String(decrypt));  &#125;&#125;</code></pre><p>输出结果：</p><pre><code>秘钥长度是:16字节(byte) 128位(bit)加密后的字符串:aT��be�������K5�解密后的字符串:Hello Alice</code></pre><p>加密过程：</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210513155714.jpg" alt="img"> </p><p>解密过程：</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210513155718.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-哈希算法</title>
      <link href="/2021/05/13/%E5%90%8E%E7%AB%AF/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2021/05/13/%E5%90%8E%E7%AB%AF/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>哈希算法、哈希函数、散列算法、散列函数、表达的都是一个意思。</p><span id="more"></span><p>哈希算法就是把任意长度的输入，通过算法，变换成固定长度的输出，该输出就是:“哈希值”，也可以称作：“信息摘要、指纹”等。</p><p>算法特点：</p><p>a. 输出不可逆：哈希值不能够还原回原文。</p><p>b. 输出定长：无论输入多长，输出总是固定长度(MD5输出总是128bit)。</p><p>c. 输入不变输出不变，输入改变输出一定变。</p><p>常见的哈希算法：</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210513143227.png" alt="image-20210513143215896"></p><p>JAVA-MD5算法演示代码：</p><pre><code class="java">package com.netty.demo.rsa;import io.netty.buffer.ByteBufUtil;import java.security.MessageDigest;public class HexTest &#123;  public static void main(String[] args) throws Exception &#123;  MessageDigest messageDigest = MessageDigest.getInstance(&quot;md5&quot;);  messageDigest.update(&quot;hello alice&quot;.getBytes());  byte[] digestBytes = messageDigest.digest();   System.out.println(&quot;length:&quot; + digestBytes.length + &quot; hex:&quot; + ByteBufUtil.hexDump(digestBytes));   //length:16 hex:9d082190e9eb2fd1a01a8657e5d726bb  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-Hex和base64的编解码原理</title>
      <link href="/2021/05/12/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Hex%E5%92%8Cbase64%E7%9A%84%E7%BC%96%E8%A7%A3%E7%A0%81%E5%8E%9F%E7%90%86/"/>
      <url>/2021/05/12/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Hex%E5%92%8Cbase64%E7%9A%84%E7%BC%96%E8%A7%A3%E7%A0%81%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>简要总结Hex和base64的编解码原理</p><span id="more"></span><h2 id="一-Hex编解码原理"><a href="#一-Hex编解码原理" class="headerlink" title="一. Hex编解码原理"></a>一. <strong>Hex编解码原理</strong></h2><p>二进制、十进制、十六进制的表示方式。</p><table><thead><tr><th>十进制与十六进制</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td><td>十进制</td></tr><tr><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td><td>十六进制</td></tr></tbody></table><table><thead><tr><th>二进制，十进制，十六进制</th><th></th></tr></thead><tbody><tr><td>11111111</td><td>二进制</td></tr><tr><td>255</td><td>十进制</td></tr><tr><td>FF</td><td>十六进制</td></tr></tbody></table><p>Hex编码：就是把1个二进制数转换为2个十六进制数。</p><p>1个二进制数：[11111001] ，转换为2个十六进制数：[F9]。</p><table><thead><tr><th>249</th><th>十进制</th><th></th></tr></thead><tbody><tr><td>11111001</td><td>二进制</td><td></td></tr><tr><td>1111</td><td>1001</td><td>4bit一组</td></tr><tr><td>15</td><td>9</td><td>十进制</td></tr><tr><td>F</td><td>9</td><td>十六进制</td></tr></tbody></table><p>Hex解码：就是把2个十六进制数转换为1个二进制数。</p><p>2个十六进制数：[F9]，转换为1个二进制数[11111001]。</p><table><thead><tr><th>F9</th><th>十六进制</th><th></th></tr></thead><tbody><tr><td>F</td><td>9</td><td>十六进制</td></tr><tr><td>1111</td><td>1001</td><td>4bit一组</td></tr><tr><td>11111001</td><td>二进制</td><td></td></tr></tbody></table><p>JAVA把二进制转换为16进制</p><pre><code class="java">import io.netty.buffer.ByteBufUtil;public class HexTest &#123;  public static void main(String[] args) &#123;   byte[] data = new byte[]&#123;(byte) 249, (byte) 249&#125;;   System.out.println(ByteBufUtil.hexDump(data));   //输出结果:f9f9  &#125;&#125;</code></pre><p>JAVA把十六进制转为二进制</p><pre><code class="java">import io.netty.buffer.ByteBufUtil;public class HexTest &#123;  public static void main(String[] args) &#123;    byte[] data = ByteBufUtil.decodeHexDump(&quot;f9f9&quot;);    System.out.println((data[0] &amp; 0xff) + &quot;|&quot; + (data[1] &amp; 0xff));   //249|249  &#125;&#125;</code></pre><h2 id="二-Base64-编解码原理"><a href="#二-Base64-编解码原理" class="headerlink" title="二. Base64 编解码原理"></a>二. <strong>Base64</strong> 编解码原理</h2><p>Base64编解码是通过一个码表，将字符串与二进制数据进行相互转换的过程。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210512145736.png" alt="image-20210512145733396"> </p><p>字符串原文：</p><pre><code>Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure. </code></pre><p>转换为base64字符串：</p><pre><code>TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=</code></pre><p>编码Man</p><p>Base编码将原来的3个字节编码为4个字符，把24个比特按6个一组转换为字符。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210512145656.png" alt="image-20210512145654633"></p><p>附:<a href="https://zh.wikipedia.org/wiki/ASCII">ASCII码表</a></p><p>如果要编码的字节数不能被3整除，最后会多出1个或2个字节，那么可以使用下面的方法进行处理：先在末尾补充字节，使其能够被3整除，然后再进行Base64的编码。在编码后的Base64文本后加上一个或两个=号，代表补足的字节数。也就是说，当最后剩余两个八位(待补足)字节（2个byte）时，最后一个6位的Base64字节块有四位是0值，最后附加上两个等号；如果最后剩余一个八位(待补足)字节（1个byte）时，最后一个6位的base字节块有两位是0值，最后附加一个等号。 参考下表：</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210512145618.png" alt="image-20210512145615005"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 编解码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node-node自定义环境变量NODE_ENV</title>
      <link href="/2021/04/26/%E5%89%8D%E7%AB%AF/node/node-node%E8%87%AA%E5%AE%9A%E4%B9%89%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FNODE_ENV/"/>
      <url>/2021/04/26/%E5%89%8D%E7%AB%AF/node/node-node%E8%87%AA%E5%AE%9A%E4%B9%89%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FNODE_ENV/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>记录一下如何指定node自定义环境变量NODE_ENV…</p><span id="more"></span><p>  在很多前端项目中都需要配置node的环境变量，通常在package.json的scripts命令内容和webpack配置文件中可以看到NODE_ENV这个变量，值一般为production或者product，也有人简写为’dev’或’prod’。</p><h4 id="NODE-ENV的作用"><a href="#NODE-ENV的作用" class="headerlink" title="NODE_ENV的作用"></a>NODE_ENV的作用</h4><p>​     通常这个变量用来区分开发与生产环境，加载不同的配置。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>​    node中有全局变量process表示当前node进程，process.env包含着关于系统环境的信息。但是process.env中并不存在NODE_ENV这个东西，NODE_ENV只是一个用户自定义的变量，当我们在服务启动时配置NODE_ENV,或在代码中给process.env.NODE_ENV赋值，js便能通过process.env.NODE_ENV获取信息，通常可以在package.json的scripts里设置</p><pre><code class="bash">  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,    &quot;start&quot;: &quot;SET NODE_ENV=production &amp;&amp; node index.js&quot;  &#125;,</code></pre><p>一般也可以在webpack配置文件中对NODE_ENV作默认处理</p><pre><code class="bash">NODE_ENV: process.env.NODE_ENV || &#39;development&#39;</code></pre><h4 id="不同平台下的设置"><a href="#不同平台下的设置" class="headerlink" title="不同平台下的设置"></a>不同平台下的设置</h4><p>在类unix系统和安装并使用了bash的windows的系统上:</p><pre><code class="bash">&quot;EXPORT  NODE_ENV=production &amp;&amp; webpack --config build/webpack.config.js&quot;</code></pre><p>在windows系统上：</p><pre><code class="bash">&quot;SET NODE_ENV=production &amp;&amp; webpack --config build/webpack.config.js&quot;</code></pre><p>还可以引用第三方插件<a href="https://www.npmjs.com/package/cross-env">cross-env</a>，兼容win和linux</p><pre><code class="bash">  &quot;scripts&quot;: &#123;        &quot;start&quot;: &quot;cross-env NODE_ENV=production  node index.js&quot;  &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网-AndroidHttpCapture网络诊断工具</title>
      <link href="/2021/04/23/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E4%BA%92%E8%81%94%E7%BD%91/%E4%BA%92%E8%81%94%E7%BD%91-AndroidHttpCapture%E7%BD%91%E7%BB%9C%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/"/>
      <url>/2021/04/23/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E4%BA%92%E8%81%94%E7%BD%91/%E4%BA%92%E8%81%94%E7%BD%91-AndroidHttpCapture%E7%BD%91%E7%BB%9C%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>一款针对于移动流量劫持而开发的手机抓包软件</p><span id="more"></span><p>是一款针对于移动流量劫持而开发的手机抓包软件，可以当作是Android版的‘Fiddler’<br>主要功能包括：手机端抓包、PING/DNS/TraceRoute诊断、抓包HAR数据上传分享<br>使用前请确保手机HTTP代理的关闭</p><h3 id="Demo-APK下载"><a href="#Demo-APK下载" class="headerlink" title="Demo APK下载"></a><a href="http://static.hk.darkal.cn/har/demo.apk">Demo APK下载</a></h3><h3 id="点击查看操作手册"><a href="#点击查看操作手册" class="headerlink" title="点击查看操作手册"></a><a href="http://static.hk.darkal.cn/har/guide/widget.guide.html">点击查看操作手册</a></h3><h2 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h2><h3 id="1．-HTTP-HTTPS抓包"><a href="#1．-HTTP-HTTPS抓包" class="headerlink" title="1． HTTP/HTTPS抓包"></a>1． HTTP/HTTPS抓包</h3><p>当用户通过AndroidHttpCapture访问页面的时候，所有的http请求都会被记录下来，然后这些请求包可以预览、分享、上传（上传接口的网址需自行在MainActivity修改）。</p><p><strong>第一次进入程序需要安装CA证书以便进行HTTPS抓包（原理同fiddler，MITM中间人）不安装证书的话无法抓取HTTPS的请求</strong> </p><p><strong>高版本的Android不允许跳转设置安装证书，需要自行在设置-&gt;安全和锁屏-&gt;加密与凭据-&gt;安装证书（证书位置：/har/littleproxy-mitm.pem）</strong> </p><p>预览页面可以查看从APP启动起所有网络请求数据，实现了按分页过滤、URL搜索功能，并可清空所有数据包<br>预览的内容包括Request Header、Request Cookie、Request Content、Response Header、Response Cookie、Response Content<br>Content内容如果为JSON将会自动格式化显示<br><a href="https://camo.githubusercontent.com/a112b0139a47d3d21701b3bf3f9e3a26e17f0c43fbf8950271a552c7b722c8e7/687474703a2f2f7374617469632e686b2e6461726b616c2e636e2f696d67642e7068703f7372633d2f323031362f30392f576563686174494d4737372e6a7065672677696474683d333530"><img src="http://cdn.tangyuxian.com/PicGoImages/20210423160705.jpeg" alt="image"></a> <a href="https://camo.githubusercontent.com/9deb259ce0f89b566964394dbd12f42a8daee0e5be7bfb2ca28abd7a5bc900b7/687474703a2f2f7374617469632e686b2e6461726b616c2e636e2f696d67642e7068703f7372633d2f323031362f30392f3233303638363636333934373738373932382e6a70672677696474683d333530"><img src="http://cdn.tangyuxian.com/PicGoImages/20210423160715.jpeg" alt="image"></a><br>分享功能将抓包生成的所有数据包打包为har文件并压缩为zip，支持分享到微信、QQ等</p><h3 id="2．-返回包注入"><a href="#2．-返回包注入" class="headerlink" title="2． 返回包注入"></a>2． 返回包注入</h3><p>支持修改流量返回包（该版本暂时只支持http的修改）<br><a href="https://camo.githubusercontent.com/76e1e85be70d4345f8a5eaa6bd564ee15d77c633f3d5d46fa86c487730157957/687474703a2f2f7374617469632e686b2e6461726b616c2e636e2f696d67642e7068703f7372633d2f323031362f30392f576563686174494d473138302e6a7065672677696474683d333530"><img src="http://cdn.tangyuxian.com/PicGoImages/20210423160730.jpeg" alt="image"></a> <a href="https://camo.githubusercontent.com/c1fce25a4b9723aa536e8d01e4bdd75728733caeff5dbdf02e02cc99086dee74/687474703a2f2f7374617469632e686b2e6461726b616c2e636e2f696d67642e7068703f7372633d2f323031362f30392f576563686174494d473138312e6a7065672677696474683d333530"><img src="http://cdn.tangyuxian.com/PicGoImages/20210423160816.jpeg" alt="image"></a></p><h3 id="3．-环境切换"><a href="#3．-环境切换" class="headerlink" title="3． 环境切换"></a>3． 环境切换</h3><p>支持切换模拟为微信、手Q，默认为普通浏览器。<br><a href="https://camo.githubusercontent.com/c074acb276946f69cb5f9394115b2c3c425905f2b785ad8d31c8644353d5859e/687474703a2f2f7374617469632e686b2e6461726b616c2e636e2f696d67642e7068703f7372633d2f323031362f30392f576563686174494d4738312e6a7065672677696474683d333530"><img src="http://cdn.tangyuxian.com/PicGoImages/20210423160921.jpeg" alt="image"></a></p><h3 id="4．-多样性输入：导航、地址栏、扫一扫、schema呼起"><a href="#4．-多样性输入：导航、地址栏、扫一扫、schema呼起" class="headerlink" title="4． 多样性输入：导航、地址栏、扫一扫、schema呼起"></a>4． 多样性输入：导航、地址栏、扫一扫、schema呼起</h3><p>支持地址栏直接输入地址，扫扫描二维码，以及schema呼起app并打开目标页面。<br>schema的协议格式为：jdhttpmonitor://webview?param={‘url’=’<a href="http://www.darkal.cn'}/">http://www.darkal.cn’}</a></p><h3 id="5．-Host配置"><a href="#5．-Host配置" class="headerlink" title="5． Host配置"></a>5． Host配置</h3><p>可以配置各域名的host<br><a href="https://camo.githubusercontent.com/b26091e3e3bc69d4861337cbb6b13e7ad90534d935f59d6a059af7907a744c25/687474703a2f2f7374617469632e686b2e6461726b616c2e636e2f696d67642e7068703f7372633d2f323031362f30392f576563686174494d4737392e6a7065672677696474683d33353026743d31"><img src="http://cdn.tangyuxian.com/PicGoImages/20210423160945.jpeg" alt="image"></a></p><h3 id="6．-查看console-log日志"><a href="#6．-查看console-log日志" class="headerlink" title="6． 查看console.log日志"></a>6． 查看console.log日志</h3><p><a href="https://camo.githubusercontent.com/43820f520afe0e8106f45674865a214fdd96f7ea5fb01079637670ba53d1aee6/687474703a2f2f7374617469632e686b2e6461726b616c2e636e2f696d67642e7068703f7372633d2f323031362f30392f576563686174494d4738322e6a7065672677696474683d333530"><img src="http://cdn.tangyuxian.com/PicGoImages/20210423160952.jpeg" alt="image"></a></p><h3 id="7．-网络工具"><a href="#7．-网络工具" class="headerlink" title="7． 网络工具"></a>7． 网络工具</h3><p>目前AndroidHttpCapture集成了常见的网络工具，如dns,ping,以及设备信息<br><a href="https://camo.githubusercontent.com/8cbb21b3aa6424836c3b2716e5a56dd3340d2e8017240bd275503d74886d69b0/687474703a2f2f7374617469632e686b2e6461726b616c2e636e2f696d67642e7068703f7372633d2f323031362f30392f3632313439353037383832362e6a70672677696474683d333530"><img src="http://cdn.tangyuxian.com/PicGoImages/20210423160959.jpeg" alt="image"></a></p><h3 id="8．-设置系统代理，监听其他app请求包"><a href="#8．-设置系统代理，监听其他app请求包" class="headerlink" title="8． 设置系统代理，监听其他app请求包"></a>8． 设置系统代理，监听其他app请求包</h3><p>当将用户手机的代理服务器设置为127.0.0.1:8888时，可以对其他app（例如微信）的HTTP数据进行抓包<br>（此时AndroidHttpCapture就是一个手机上的fiddler）<br><a href="https://camo.githubusercontent.com/f0b30bb8c009ea574d54fbeb0859632de6e4ff8674a9747899d96dd9c4d48c94/687474703a2f2f7374617469632e686b2e6461726b616c2e636e2f696d67642e7068703f7372633d2f323031362f30392f576563686174494d4738302e6a7065672677696474683d333530"><img src="http://cdn.tangyuxian.com/PicGoImages/20210423161006.jpeg" alt="image"></a></p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><ol><li><h3 id="分享的http包如何查看和分析？"><a href="#分享的http包如何查看和分析？" class="headerlink" title="分享的http包如何查看和分析？"></a>分享的http包如何查看和分析？</h3><p>  分享的文件解压后为.har文件,可以通过fiddler方式或者在线工具进行分析。<br>Fiddler方式需要先将包导到电脑上，然后使用fiddler导入该包：Import Sessions-&gt;Select Import Format -&gt;HTTPArchive -&gt;选择包，即可<br>在线工具外网：<a href="http://static.hk.darkal.cn/har/">http://static.hk.darkal.cn/har/</a> 只需要将包拖入此工具即可分析</p></li></ol><hr><p>工具地址:<a href="https://github.com/JZ-Darkal/AndroidHttpCapture">github地址:https://github.com/JZ-Darkal/AndroidHttpCapture</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 互联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器-高性能渲染十万条数据(虚拟列表)</title>
      <link href="/2021/04/16/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-%E9%AB%98%E6%80%A7%E8%83%BD%E6%B8%B2%E6%9F%93%E5%8D%81%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE-%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8/"/>
      <url>/2021/04/16/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-%E9%AB%98%E6%80%A7%E8%83%BD%E6%B8%B2%E6%9F%93%E5%8D%81%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE-%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>对于一次性插入大量数据的情况，一般有两种做法：时间分片,虚拟列表</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在工作中，有时会遇到需要一些不能使用分页方式来加载列表数据的业务情况，对于此，我们称这种列表叫做<code>长列表</code>。比如，在一些外汇交易系统中，前端会实时的展示用户的持仓情况(收益、亏损、手数等)，此时对于用户的持仓列表一般是不能分页的。</p><p>在<a href="/2021/04/16/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-%E9%AB%98%E6%80%A7%E8%83%BD%E6%B8%B2%E6%9F%93%E5%8D%81%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE-%E6%97%B6%E9%97%B4%E5%88%86%E7%89%87/">高性能渲染十万条数据(时间分片)</a>一文中，提到了可以使用<code>时间分片</code>的方式来对长列表进行渲染，但这种方式更适用于列表项的DOM结构十分简单的情况。本文会介绍使用<code>虚拟列表</code>的方式，来同时加载大量数据。</p><h2 id="为什么需要使用虚拟列表"><a href="#为什么需要使用虚拟列表" class="headerlink" title="为什么需要使用虚拟列表"></a>为什么需要使用虚拟列表</h2><p>假设我们的长列表需要展示10000条记录，我们同时将10000条记录渲染到页面中，先来看看需要花费多长时间：</p><pre><code class="html">&lt;button id=&quot;button&quot;&gt;button&lt;/button&gt;&lt;br&gt;&lt;ul id=&quot;container&quot;&gt;&lt;/ul&gt; </code></pre><pre><code class="javascript"> document.getElementById(&#39;button&#39;).addEventListener(&#39;click&#39;,function()&#123;    // 记录任务开始时间    let now = Date.now();    // 插入一万条数据    const total = 10000;    // 获取容器    let ul = document.getElementById(&#39;container&#39;);    // 将数据插入容器中    for (let i = 0; i &lt; total; i++) &#123;        let li = document.createElement(&#39;li&#39;);        li.innerText = ~~(Math.random() * total)        ul.appendChild(li);    &#125;    console.log(&#39;JS运行时间：&#39;,Date.now() - now);    setTimeout(()=&gt;&#123;      console.log(&#39;总运行时间：&#39;,Date.now() - now);    &#125;,0)    // print JS运行时间： 38    // print 总运行时间： 957   &#125;)</code></pre><p>当我们点击按钮，会同时向页面中加入一万条记录，通过控制台的输出，我们可以粗略的统计到，JS的运行时间为<code>38ms</code>,但渲染完成后的总时间为<code>957ms</code>。</p><p>简单说明一下，为何两次<code>console.log</code>的结果时间差异巨大，并且是如何简单来统计<code>JS运行时间</code>和<code>总渲染时间</code>：</p><ul><li>在 JS 的<code>Event Loop</code>中，当JS引擎所管理的执行栈中的事件以及所有微任务事件全部执行完后，才会触发渲染线程对页面进行渲染</li><li>第一个<code>console.log</code>的触发时间是在页面进行渲染之前，此时得到的间隔时间为JS运行所需要的时间</li><li>第二个<code>console.log</code>是放到 setTimeout 中的，它的触发时间是在渲染完成，在下一次<code>Event Loop</code>中执行的</li></ul><p><a href="https://juejin.im/post/6844903919789801486">关于Event Loop的详细内容请参见这篇文章–&gt;</a></p><p>然后，我们通过<code>Chrome</code>的<code>Performance</code>工具来详细的分析这段代码的性能瓶颈在哪里：</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210420102654.gif" alt="img"></p><p>从<code>Performance</code>可以看出，代码从执行到渲染结束，共消耗了<code>960.8ms</code>,其中的主要时间消耗如下：</p><ul><li>Event(click) : <code>40.84ms</code></li><li>Recalculate Style : <code>105.08ms</code></li><li>Layout : <code>731.56ms</code></li><li>Update Layer Tree : <code>58.87ms</code></li><li>Paint : <code>15.32ms</code></li></ul><p>从这里我们可以看出，我们的代码的执行过程中，消耗时间最多的两个阶段是<code>Recalculate Style</code>和<code>Layout</code>。</p><ul><li><code>Recalculate Style</code>：样式计算，浏览器根据css选择器计算哪些元素应该应用哪些规则，确定每个元素具体的样式。</li><li><code>Layout</code>：布局，知道元素应用哪些规则之后，浏览器开始计算它要占据的空间大小及其在屏幕的位置。</li></ul><p>在实际的工作中，列表项必然不会像例子中仅仅只由一个li标签组成，必然是由复杂DOM节点组成的。</p><p>那么可以想象的是，当列表项数过多并且列表项结构复杂的时候，同时渲染时，会在<code>Recalculate Style</code>和<code>Layout</code>阶段消耗大量的时间。</p><p>而<code>虚拟列表</code>就是解决这一问题的一种实现。</p><h2 id="什么是虚拟列表"><a href="#什么是虚拟列表" class="headerlink" title="什么是虚拟列表"></a>什么是虚拟列表</h2><p><code>虚拟列表</code>其实是按需显示的一种实现，即只对<code>可见区域</code>进行渲染，对<code>非可见区域</code>中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能。</p><p>假设有1万条记录需要同时渲染，我们屏幕的<code>可见区域</code>的高度为<code>500px</code>,而列表项的高度为<code>50px</code>，则此时我们在屏幕中最多只能看到10个列表项，那么在首次渲染的时候，我们只需加载10条即可。</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/29/16e15195cf16a558?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>说完首次加载，再分析一下当滚动发生时，我们可以通过计算当前滚动值得知此时在屏幕<code>可见区域</code>应该显示的列表项。</p><p>假设滚动发生，滚动条距顶部的位置为<code>150px</code>,则我们可得知在<code>可见区域</code>内的列表项为<code>第4项</code>至`第13项。</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/29/16e15197c273cbd9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>虚拟列表的实现，实际上就是在首屏加载的时候，只加载<code>可视区域</code>内需要的列表项，当滚动发生时，动态通过计算获得<code>可视区域</code>内的列表项，并将<code>非可视区域</code>内存在的列表项删除。</p><ul><li>计算当前<code>可视区域</code>起始数据索引(<code>startIndex</code>)</li><li>计算当前<code>可视区域</code>结束数据索引(<code>endIndex</code>)</li><li>计算当前<code>可视区域的</code>数据，并渲染到页面中</li><li>计算<code>startIndex</code>对应的数据在整个列表中的偏移位置<code>startOffset</code>并设置到列表上</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/10/29/16e1519a393dee2c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>由于只是对<code>可视区域</code>内的列表项进行渲染，所以为了保持列表容器的高度并可正常的触发滚动，将Html结构设计成如下结构：</p><pre><code class="html">&lt;div class=&quot;infinite-list-container&quot;&gt;    &lt;div class=&quot;infinite-list-phantom&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;infinite-list&quot;&gt;      &lt;!-- item-1 --&gt;      &lt;!-- item-2 --&gt;      &lt;!-- ...... --&gt;      &lt;!-- item-n --&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><ul><li><code>infinite-list-container</code> 为<code>可视区域</code>的容器</li><li><code>infinite-list-phantom</code> 为容器内的占位，高度为总列表高度，用于形成滚动条</li><li><code>infinite-list</code> 为列表项的<code>渲染区域</code></li></ul><p>接着，监听<code>infinite-list-container</code>的<code>scroll</code>事件，获取滚动位置<code>scrollTop</code></p><ul><li>假定<code>可视区域</code>高度固定，称之为<code>screenHeight</code></li><li>假定<code>列表每项</code>高度固定，称之为<code>itemSize</code></li><li>假定<code>列表数据</code>称之为<code>listData</code></li><li>假定<code>当前滚动位置</code>称之为<code>scrollTop</code></li></ul><p>则可推算出：</p><ul><li>列表总高度<code>listHeight</code> = listData.length * itemSize</li><li>可显示的列表项数<code>visibleCount</code> = Math.ceil(screenHeight / itemSize)</li><li>数据的起始索引<code>startIndex</code> = Math.floor(scrollTop / itemSize)</li><li>数据的结束索引<code>endIndex</code> = startIndex + visibleCount</li><li>列表显示数据为<code>visibleData</code> = listData.slice(startIndex,endIndex)</li></ul><p>当滚动后，由于<code>渲染区域</code>相对于<code>可视区域</code>已经发生了偏移，此时我需要获取一个偏移量<code>startOffset</code>，通过样式控制将<code>渲染区域</code>偏移至<code>可视区域</code>中。</p><ul><li>偏移量<code>startOffset</code> = scrollTop - (scrollTop % itemSize);</li></ul><p>最终的<code>简易代码</code>如下：</p><pre><code class="vue">&lt;template&gt;  &lt;div ref=&quot;list&quot; class=&quot;infinite-list-container&quot; @scroll=&quot;scrollEvent($event)&quot;&gt;    &lt;div class=&quot;infinite-list-phantom&quot; :style=&quot;&#123; height: listHeight + &#39;px&#39; &#125;&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;infinite-list&quot; :style=&quot;&#123; transform: getTransform &#125;&quot;&gt;      &lt;div ref=&quot;items&quot;        class=&quot;infinite-list-item&quot;        v-for=&quot;item in visibleData&quot;        :key=&quot;item.id&quot;        :style=&quot;&#123; height: itemSize + &#39;px&#39;,lineHeight: itemSize + &#39;px&#39; &#125;&quot;      &gt;&#123;&#123; item.value &#125;&#125;&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name:&#39;VirtualList&#39;,  props: &#123;    //所有列表数据    listData:&#123;      type:Array,      default:()=&gt;[]    &#125;,    //每项高度    itemSize: &#123;      type: Number,      default:200    &#125;  &#125;,  computed:&#123;    //列表总高度    listHeight()&#123;      return this.listData.length * this.itemSize;    &#125;,    //可显示的列表项数    visibleCount()&#123;      return Math.ceil(this.screenHeight / this.itemSize)    &#125;,    //偏移量对应的style    getTransform()&#123;      return `translate3d(0,$&#123;this.startOffset&#125;px,0)`;    &#125;,    //获取真实显示列表数据    visibleData()&#123;      return this.listData.slice(this.start, Math.min(this.end,this.listData.length));    &#125;  &#125;,  mounted() &#123;    this.screenHeight = this.$el.clientHeight;    this.start = 0;    this.end = this.start + this.visibleCount;  &#125;,  data() &#123;    return &#123;      //可视区域高度      screenHeight:0,      //偏移量      startOffset:0,      //起始索引      start:0,      //结束索引      end:null,    &#125;;  &#125;,  methods: &#123;    scrollEvent() &#123;      //当前滚动位置      let scrollTop = this.$refs.list.scrollTop;      //此时的开始索引      this.start = Math.floor(scrollTop / this.itemSize);      //此时的结束索引      this.end = this.start + this.visibleCount;      //此时的偏移量      this.startOffset = scrollTop - (scrollTop % this.itemSize);    &#125;  &#125;&#125;;&lt;/script&gt;</code></pre><p><a href="https://codesandbox.io/s/virtuallist-1-rp8pi">点击查看在线DEMO及完整代码</a></p><p>最终效果如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/29/16e151e017d7bba3?imageslim" alt="img"></p><h2 id="列表项动态高度"><a href="#列表项动态高度" class="headerlink" title="列表项动态高度"></a>列表项动态高度</h2><p>在之前的实现中，列表项的高度是固定的，因为高度固定，所以可以很轻易的获取列表项的整体高度以及滚动时的显示数据与对应的偏移量。而实际应用的时候，当列表中包含文本之类的可变内容，会导致列表项的高度并不相同。</p><p>比如这种情况：</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/29/16e1519f1e121be9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>在虚拟列表中应用动态高度的解决方案一般有如下三种：</p><blockquote><p>1.对组件属性<code>itemSize</code>进行扩展，支持传递类型为<code>数字</code>、<code>数组</code>、<code>函数</code></p></blockquote><ul><li>可以是一个固定值，如 100，此时列表项是固高的</li><li>可以是一个包含所有列表项高度的数据，如 [50, 20, 100, 80, …]</li><li>可以是一个根据列表项索引返回其高度的函数：(index: number): number</li></ul><p>这种方式虽然有比较好的灵活度，但仅适用于可以预先知道或可以通过计算得知列表项高度的情况，依然无法解决列表项高度由内容撑开的情况。</p><blockquote><p>2.将列表项<code>渲染到屏幕外</code>，对其高度进行测量并缓存，然后再将其渲染至可视区域内。</p></blockquote><p>由于预先渲染至屏幕外，再渲染至屏幕内，这导致渲染成本增加一倍，这对于数百万用户在低端移动设备上使用的产品来说是不切实际的。</p><blockquote><p>3.以<code>预估高度</code>先行渲染，然后获取真实高度并缓存。</p></blockquote><p>这是我选择的实现方式，可以避免前两种方案的不足。</p><p>接下来，来看如何简易的实现：</p><p>定义组件属性<code>estimatedItemSize</code>,用于接收<code>预估高度</code></p><pre><code>props: &#123;  //预估高度  estimatedItemSize:&#123;    type:Number  &#125;&#125;复制代码</code></pre><p>定义<code>positions</code>，用于列表项渲染后存储<code>每一项的高度以及位置</code>信息，</p><pre><code>this.positions = [  // &#123;  //   top:0,  //   bottom:100,  //   height:100  // &#125;];复制代码</code></pre><p>并在初始时根据<code>estimatedItemSize</code>对<code>positions</code>进行初始化。</p><pre><code>initPositions()&#123;  this.positions = this.listData.map((item,index)=&gt;&#123;    return &#123;      index,      height:this.estimatedItemSize,      top:index * this.estimatedItemSize,      bottom:(index + 1) * this.estimatedItemSize    &#125;  &#125;)&#125;复制代码</code></pre><p>由于列表项高度不定，并且我们维护了<code>positions</code>，用于记录每一项的位置，而<code>列表高度</code>实际就等于列表中最后一项的底部距离列表顶部的位置。</p><pre><code>//列表总高度listHeight()&#123;  return this.positions[this.positions.length - 1].bottom;&#125;复制代码</code></pre><p>由于需要在<code>渲染完成</code>后，获取列表每项的位置信息并缓存，所以使用钩子函数<code>updated</code>来实现：</p><pre><code>updated()&#123;  let nodes = this.$refs.items;  nodes.forEach((node)=&gt;&#123;    let rect = node.getBoundingClientRect();    let height = rect.height;    let index = +node.id.slice(1)    let oldHeight = this.positions[index].height;    let dValue = oldHeight - height;    //存在差值    if(dValue)&#123;      this.positions[index].bottom = this.positions[index].bottom - dValue;      this.positions[index].height = height;      for(let k = index + 1;k&lt;this.positions.length; k++)&#123;        this.positions[k].top = this.positions[k-1].bottom;        this.positions[k].bottom = this.positions[k].bottom - dValue;      &#125;    &#125;  &#125;)&#125;复制代码</code></pre><p>滚动后获取列表<code>开始索引</code>的方法修改为通过<code>缓存</code>获取：</p><pre><code>//获取列表起始索引getStartIndex(scrollTop = 0)&#123;  let item = this.positions.find(i =&gt; i &amp;&amp; i.bottom &gt; scrollTop);  return item.index;&#125;复制代码</code></pre><p>由于我们的缓存数据，本身就是有顺序的，所以获取<code>开始索引</code>的方法可以考虑通过<code>二分查找</code>的方式来降低检索次数：</p><pre><code>//获取列表起始索引getStartIndex(scrollTop = 0)&#123;  //二分法查找  return this.binarySearch(this.positions,scrollTop)&#125;,//二分法查找binarySearch(list,value)&#123;  let start = 0;  let end = list.length - 1;  let tempIndex = null;  while(start &lt;= end)&#123;    let midIndex = parseInt((start + end)/2);    let midValue = list[midIndex].bottom;    if(midValue === value)&#123;      return midIndex + 1;    &#125;else if(midValue &lt; value)&#123;      start = midIndex + 1;    &#125;else if(midValue &gt; value)&#123;      if(tempIndex === null || tempIndex &gt; midIndex)&#123;        tempIndex = midIndex;      &#125;      end = end - 1;    &#125;  &#125;  return tempIndex;&#125;,复制代码</code></pre><p>滚动后将<code>偏移量</code>的获取方式变更：</p><pre><code>scrollEvent() &#123;  //...省略  if(this.start &gt;= 1)&#123;    this.startOffset = this.positions[this.start - 1].bottom  &#125;else&#123;    this.startOffset = 0;  &#125;&#125;复制代码</code></pre><p>通过<a href="https://github.com/marak/Faker.js/">faker.js</a> 来创建一些<code>随机数据</code></p><pre><code>let data = [];for (let id = 0; id &lt; 10000; id++) &#123;  data.push(&#123;    id,    value: faker.lorem.sentences() // 长文本  &#125;)&#125;复制代码</code></pre><p><a href="https://codesandbox.io/s/virtuallist2-1bqk6">点击查看在线DEMO及完整代码</a></p><p>最终效果如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/29/16e151e96584b690?imageslim" alt="img"></p><p>从演示效果上看，我们实现了基于<code>文字内容动态撑高列表项</code>情况下的<code>虚拟列表</code>，但是我们可能会发现，当滚动过快时，会出现短暂的<code>白屏现象</code>。</p><p>为了使页面平滑滚动，我们还需要在<code>可见区域</code>的上方和下方渲染额外的项目，在滚动时给予一些<code>缓冲</code>，所以将屏幕分为三个区域：</p><ul><li>可视区域上方：<code>above</code></li><li>可视区域：<code>screen</code></li><li>可视区域下方：<code>below</code></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/10/29/16e151a59317cae7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>定义组件属性<code>bufferScale</code>,用于接收<code>缓冲区数据</code>与<code>可视区数据</code>的<code>比例</code></p><pre><code>props: &#123;  //缓冲区比例  bufferScale:&#123;    type:Number,    default:1  &#125;&#125;复制代码</code></pre><p>可视区上方渲染条数<code>aboveCount</code>获取方式如下：</p><pre><code>aboveCount()&#123;  return Math.min(this.start,this.bufferScale * this.visibleCount)&#125;复制代码</code></pre><p>可视区下方渲染条数<code>belowCount</code>获取方式如下：</p><pre><code>belowCount()&#123;  return Math.min(this.listData.length - this.end,this.bufferScale * this.visibleCount);&#125;复制代码</code></pre><p>真实渲染数据<code>visibleData</code>获取方式如下：</p><pre><code class="javascript">visibleData()&#123;  let start = this.start - this.aboveCount;  let end = this.end + this.belowCount;  return this._listData.slice(start, end);&#125;</code></pre><p><a href="https://codesandbox.io/s/virtuallist-3-i3h9v">点击查看在线DEMO及完整代码</a></p><p>最终效果如下：</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210416162829.gif" alt="img"></p><blockquote><p>基于这个方案，个人开发了一个基于Vue2.x的虚拟列表组件：<a href="https://github.com/chenqf/vue-virtual-listview">vue-virtual-listview</a>,可<a href="https://github.com/chenqf/vue-virtual-listview">点击查看完整代码</a>。</p></blockquote><h2 id="面向未来"><a href="#面向未来" class="headerlink" title="面向未来"></a>面向未来</h2><p>在前文中我们使用<code>监听scroll事件</code>的方式来触发可视区域中数据的更新，当滚动发生后，scroll事件会频繁触发，很多时候会造成<code>重复计算</code>的问题，从性能上来说无疑存在浪费的情况。</p><p>可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver">IntersectionObserver</a>替换监听scroll事件，<code>IntersectionObserver</code>可以监听目标元素是否出现在可视区域内，在监听的回调事件中执行可视区域数据的更新，并且<code>IntersectionObserver</code>的监听回调是异步触发，不随着目标元素的滚动而触发，性能消耗极低。</p><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>我们虽然实现了根据列表项动态高度下的虚拟列表，但如果列表项中包含图片，并且列表高度由图片撑开，由于图片会发送网络请求，此时无法保证我们在获取列表项真实高度时图片是否已经加载完成，从而造成计算不准确的情况。</p><p>这种情况下，如果我们能监听列表项的大小变化就能获取其真正的高度了。我们可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver">ResizeObserver</a>来监听列表项内容区域的高度改变，从而实时获取每一列表项的高度。</p><p>不过遗憾的是，在撰写本文的时候，仅有少数<a href="https://www.caniuse.com/#search=ResizeObserver">浏览器支持</a><code>ResizeObserver</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器-高性能渲染十万条数据(时间分片)</title>
      <link href="/2021/04/16/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-%E9%AB%98%E6%80%A7%E8%83%BD%E6%B8%B2%E6%9F%93%E5%8D%81%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE-%E6%97%B6%E9%97%B4%E5%88%86%E7%89%87/"/>
      <url>/2021/04/16/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-%E9%AB%98%E6%80%A7%E8%83%BD%E6%B8%B2%E6%9F%93%E5%8D%81%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE-%E6%97%B6%E9%97%B4%E5%88%86%E7%89%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>对于一次性插入大量数据的情况，一般有两种做法：时间分片,虚拟列表</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在实际工作中，我们很少会遇到一次性需要向页面中插入大量数据的情况，但是为了丰富我们的知识体系，我们有必要了解并清楚当遇到大量数据时，如何才能在不卡主页面的情况下渲染数据，以及其中背后的原理。</p><p>对于一次性插入大量数据的情况，一般有两种做法：</p><ol><li>时间分片</li><li>虚拟列表</li></ol><p>本文作为开篇，着重来介绍如何使用<code>时间分片</code>的方式来渲染大量数据，<code>虚拟列表</code>相关的内容，参见<a href="https://juejin.im/post/6844903982742110216">「前端进阶」高性能渲染十万条数据(虚拟列表)</a></p><h2 id="最粗暴的做法（一次性渲染）"><a href="#最粗暴的做法（一次性渲染）" class="headerlink" title="最粗暴的做法（一次性渲染）"></a>最粗暴的做法（一次性渲染）</h2><p>我们先来看看最粗暴的做法，一次性将大量数据插入到页面中：</p><pre><code class="javascript">&lt;ul id=&quot;container&quot;&gt;&lt;/ul&gt;复制代码// 记录任务开始时间let now = Date.now();// 插入十万条数据const total = 100000;// 获取容器let ul = document.getElementById(&#39;container&#39;);// 将数据插入容器中for (let i = 0; i &lt; total; i++) &#123;    let li = document.createElement(&#39;li&#39;);    li.innerText = ~~(Math.random() * total)    ul.appendChild(li);&#125;console.log(&#39;JS运行时间：&#39;,Date.now() - now);setTimeout(()=&gt;&#123;  console.log(&#39;总运行时间：&#39;,Date.now() - now);&#125;,0)// print: JS运行时间： 187// print: 总运行时间： 2844</code></pre><p>我们对十万条记录进行循环操作，JS的运行时间为<code>187ms</code>，还是蛮快的，但是最终渲染完成后的总时间确是<code>2844ms</code>。</p><p>简单说明一下，为何两次<code>console.log</code>的结果时间差异巨大，并且是如何简单来统计<code>JS运行时间</code>和<code>总渲染时间</code>：</p><ul><li>在 JS 的<code>Event Loop</code>中，当JS引擎所管理的执行栈中的事件以及所有微任务事件全部执行完后，才会触发渲染线程对页面进行渲染</li><li>第一个<code>console.log</code>的触发时间是在页面进行渲染之前，此时得到的间隔时间为JS运行所需要的时间</li><li>第二个<code>console.log</code>是放到 setTimeout 中的，它的触发时间是在渲染完成，在下一次<code>Event Loop</code>中执行的</li></ul><p><a href="https://juejin.im/post/6844903919789801486">关于Event Loop的详细内容请参见这篇文章–&gt;</a></p><p>依照两次<code>console.log</code>的结果，可以得出结论：</p><p>对于大量数据渲染的时候，JS运算并不是性能的瓶颈，性能的瓶颈主要在于渲染阶段</p><h2 id="使用定时器"><a href="#使用定时器" class="headerlink" title="使用定时器"></a>使用定时器</h2><p>从上面的例子，我们已经知道，页面的卡顿是由于同时渲染大量DOM所引起的，所以我们考虑将渲染过程分批进行</p><p>在这里，我们使用<code>setTimeout</code>来实现分批渲染</p><pre><code class="javascript">&lt;ul id=&quot;container&quot;&gt;&lt;/ul&gt;复制代码//需要插入的容器let ul = document.getElementById(&#39;container&#39;);// 插入十万条数据let total = 100000;// 一次插入 20 条let once = 20;//总页数let page = total/once//每条记录的索引let index = 0;//循环加载数据function loop(curTotal,curIndex)&#123;    if(curTotal &lt;= 0)&#123;        return false;    &#125;    //每页多少条    let pageCount = Math.min(curTotal , once);    setTimeout(()=&gt;&#123;        for(let i = 0; i &lt; pageCount; i++)&#123;            let li = document.createElement(&#39;li&#39;);            li.innerText = curIndex + i + &#39; : &#39; + ~~(Math.random() * total)            ul.appendChild(li)        &#125;        loop(curTotal - pageCount,curIndex + pageCount)    &#125;,0)&#125;loop(total,index);</code></pre><p>用一个gif图来看一下效果</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210416161357.gif" alt="img"></p><p>我们可以看到，页面加载的时间已经非常快了，每次刷新时可以很快的看到第一屏的所有数据，但是当我们快速滚动页面的时候，会发现页面出现闪屏或白屏的现象</p><h3 id="为什么会出现闪屏现象呢"><a href="#为什么会出现闪屏现象呢" class="headerlink" title="为什么会出现闪屏现象呢"></a>为什么会出现闪屏现象呢</h3><p>首先，理清一些概念。<code>FPS</code>表示的是每秒钟画面更新次数。我们平时所看到的连续画面都是由一幅幅静止画面组成的，每幅画面称为一<code>帧</code>，<code>FPS</code>是描述<code>帧</code>变化速度的物理量。</p><p>大多数电脑显示器的刷新频率是60Hz，大概相当于每秒钟重绘60次，<code>FPS</code>为60frame/s，为这个值的设定受屏幕分辨率、屏幕尺寸和显卡的影响。</p><p>因此，当你对着电脑屏幕什么也不做的情况下，大多显示器也会以每秒60次的频率正在不断的更新屏幕上的图像。</p><p>为什么你感觉不到这个变化？</p><p>那是因为人的眼睛有视觉停留效应，即前一副画面留在大脑的印象还没消失，紧接着后一副画面就跟上来了， 这中间只间隔了16.7ms(1000/60≈16.7)，所以会让你误以为屏幕上的图像是静止不动的。</p><p>而屏幕给你的这种感觉是对的，试想一下，如果刷新频率变成1次/秒，屏幕上的图像就会出现严重的闪烁， 这样就很容易引起眼睛疲劳、酸痛和头晕目眩等症状。</p><p>大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。 因此，最平滑动画的最佳循环间隔是1000ms/60，约等于16.6ms。</p><p>直观感受，不同帧率的体验：</p><ul><li>帧率能够达到 50 ～ 60 FPS 的动画将会相当流畅，让人倍感舒适；</li><li>帧率在 30 ～ 50 FPS 之间的动画，因各人敏感程度不同，舒适度因人而异；</li><li>帧率在 30 FPS 以下的动画，让人感觉到明显的卡顿和不适感；</li><li>帧率波动很大的动画，亦会使人感觉到卡顿。</li></ul><h3 id="简单聊一下-setTimeout-和闪屏现象"><a href="#简单聊一下-setTimeout-和闪屏现象" class="headerlink" title="简单聊一下 setTimeout 和闪屏现象"></a>简单聊一下 setTimeout 和闪屏现象</h3><ul><li><code>setTimeout</code>的执行时间并不是确定的。在JS中，<code>setTimeout</code>任务被放进事件队列中，只有主线程执行完才会去检查事件队列中的任务是否需要执行，因此<code>setTimeout</code>的实际执行时间可能会比其设定的时间晚一些。</li><li>刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的刷新频率可能会不同，而<code>setTimeout</code>只能设置一个固定时间间隔，这个时间不一定和屏幕的刷新时间相同。</li></ul><p>以上两种情况都会导致setTimeout的执行步调和屏幕的刷新步调不一致。</p><p>在<code>setTimeout</code>中对dom进行操作，必须要等到屏幕下次绘制时才能更新到屏幕上，如果两者步调不一致，就可能导致中间某一帧的操作被跨越过去，而直接更新下一帧的元素，从而导致丢帧现象。</p><h2 id="使用-requestAnimationFrame"><a href="#使用-requestAnimationFrame" class="headerlink" title="使用 requestAnimationFrame"></a>使用 requestAnimationFrame</h2><p>与<code>setTimeout</code>相比，<code>requestAnimationFrame</code>最大的优势是由系统来决定回调函数的执行时机。</p><p>如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms，换句话说就是，<code>requestAnimationFrame</code>的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象。</p><p>我们使用<code>requestAnimationFrame</code>来进行分批渲染：</p><pre><code class="html">&lt;ul id=&quot;container&quot;&gt;&lt;/ul&gt;</code></pre><pre><code class="javascript">//需要插入的容器let ul = document.getElementById(&#39;container&#39;);// 插入十万条数据let total = 100000;// 一次插入 20 条let once = 20;//总页数let page = total/once//每条记录的索引let index = 0;//循环加载数据function loop(curTotal,curIndex)&#123;    if(curTotal &lt;= 0)&#123;        return false;    &#125;    //每页多少条    let pageCount = Math.min(curTotal , once);    window.requestAnimationFrame(function()&#123;        for(let i = 0; i &lt; pageCount; i++)&#123;            let li = document.createElement(&#39;li&#39;);            li.innerText = curIndex + i + &#39; : &#39; + ~~(Math.random() * total)            ul.appendChild(li)        &#125;        loop(curTotal - pageCount,curIndex + pageCount)    &#125;)&#125;loop(total,index);</code></pre><p>看下效果</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210416161321.gif" alt="img"></p><p>我们可以看到，页面加载的速度很快，并且滚动的时候，也很流畅没有出现闪烁丢帧的现象。</p><p>这就结束了么，还可以再优化么？</p><p>当然~~</p><h2 id="使用-DocumentFragment"><a href="#使用-DocumentFragment" class="headerlink" title="使用 DocumentFragment"></a>使用 DocumentFragment</h2><p>先解释一下什么是 DocumentFragment ，文献引用自<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment">MDN</a></p><blockquote><p>DocumentFragment<code>，文档片段接口，表示一个没有父级文件的最小文档对象。它被作为一个轻量版的</code>Document<code>使用，用于存储已排好版的或尚未打理好格式的XML片段。最大的区别是因为</code>DocumentFragment<code>不是真实DOM树的一部分，它的变化不会触发DOM树的（重新渲染) ，且不会导致性能等问题。 可以使用</code>document.createDocumentFragment<code>方法或者构造函数来创建一个空的</code>DocumentFragment</p></blockquote><p>从MDN的说明中，我们得知<code>DocumentFragments</code>是DOM节点，但并不是DOM树的一部分，可以认为是存在内存中的，所以将子元素插入到文档片段时不会引起页面回流。</p><p>当<code>append</code>元素到<code>document</code>中时，被<code>append</code>进去的元素的样式表的计算是同步发生的，此时调用 getComputedStyle 可以得到样式的计算值。 而<code>append</code>元素到<code>documentFragment</code> 中时，是不会计算元素的样式表，所以<code>documentFragment</code> 性能更优。当然现在浏览器的优化已经做的很好了， 当<code>append</code>元素到<code>document</code>中后，没有访问 getComputedStyle 之类的方法时，现代浏览器也可以把样式表的计算推迟到脚本执行之后。</p><p>最后修改代码如下：</p><pre><code class="html">&lt;ul id=&quot;container&quot;&gt;&lt;/ul&gt;</code></pre><pre><code class="javascript">//需要插入的容器let ul = document.getElementById(&#39;container&#39;);// 插入十万条数据let total = 100000;// 一次插入 20 条let once = 20;//总页数let page = total/once//每条记录的索引let index = 0;//循环加载数据function loop(curTotal,curIndex)&#123;    if(curTotal &lt;= 0)&#123;        return false;    &#125;    //每页多少条    let pageCount = Math.min(curTotal , once);    window.requestAnimationFrame(function()&#123;        let fragment = document.createDocumentFragment();        for(let i = 0; i &lt; pageCount; i++)&#123;            let li = document.createElement(&#39;li&#39;);            li.innerText = curIndex + i + &#39; : &#39; + ~~(Math.random() * total)            fragment.appendChild(li)        &#125;        ul.appendChild(fragment)        loop(curTotal - pageCount,curIndex + pageCount)    &#125;)&#125;loop(total,index);</code></pre><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文更多的是提供一个思路，通过时间分片的方式来同时加载大量简单DOM。对于复杂DOM的情况，一般会用到虚拟列表的方式来实现，关于这一问题，会持续整理，敬请期待。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack-vueCli4全面配置</title>
      <link href="/2021/04/13/%E5%89%8D%E7%AB%AF/webpack/webpack-vueCli4%20%E5%85%A8%E9%9D%A2%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/04/13/%E5%89%8D%E7%AB%AF/webpack/webpack-vueCli4%20%E5%85%A8%E9%9D%A2%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>细致全面的 vue-cli4 配置信息。涵盖了使用 vue-cli 开发过程中大部分配置需求。</p><span id="more"></span><h1 id="vue-cli4-全面配置"><a href="#vue-cli4-全面配置" class="headerlink" title="vue-cli4 全面配置"></a>vue-cli4 全面配置</h1><p><span id="top">目录</span></p><ul><li><a href="#env">√ 配置多环境变量</a></li><li><a href="#base">√ 配置基础 vue.config.js</a></li><li><a href="#proxy">√ 配置 proxy 跨域</a></li><li><a href="#hmr">√ 修复 HMR(热更新)失效</a></li><li><a href="#lazyloading">√ 修复 Lazy loading routes Error： Cyclic dependency</a></li><li><a href="#alias">√ 添加别名 alias</a></li><li><a href="#compressimage">√ 压缩图片</a></li><li><a href="#spritesmith">√ 自动生成雪碧图</a></li><li><a href="#font">√ SVG 转 font 字体</a></li><li><a href="#svg">√ 使用 SVG 组件</a></li><li><a href="#removecss">√ 去除多余无效的 css</a></li><li><a href="#analyze">√ 添加打包分析</a></li><li><a href="#externals">√ 配置 externals 引入 cdn 资源</a></li><li><a href="#multiple-pages">√ 多页面打包 multi-page</a></li><li><a href="#moment">√ 删除 moment 语言包</a></li><li><a href="#log">√ 去掉 console.log</a></li><li><a href="#splitchunks">√ 利用 splitChunks 单独打包第三方模块</a></li><li><a href="#gzip">√ 开启 gzip 压缩</a></li><li><a href="#stylelint">√ 开启 stylelint 检测scss, css语法</a></li><li><a href="#globalscss">√ 为 sass 提供全局样式，以及全局变量</a></li><li><a href="#globalstylus">√ 为 stylus 提供全局变量</a></li><li><a href="#prerender">√ 预渲染 prerender-spa-plugin</a></li><li><a href="#ie">√ 添加 IE 兼容</a></li><li><a href="#alioss">√ 静态资源自动打包上传阿里 oss、华为 obs</a></li><li><a href="#allconfig">√ 完整依赖</a></li></ul><h3 id="✅-配置多环境变量"><a href="#✅-配置多环境变量" class="headerlink" title="✅ 配置多环境变量"></a><span id="env">✅ 配置多环境变量</span></h3><p>&emsp;&emsp;通过在 package.json 里的 scripts 配置项中添加–mode xxx 来选择不同环境</p><p>&emsp;&emsp;只有以 VUE_APP 开头的变量会被 webpack.DefinePlugin 静态嵌入到客户端侧的包中，代码中可以通过 process.env.VUE_APP_BASE_API 访问</p><p>&emsp;&emsp;NODE_ENV 和 BASE_URL 是两个特殊变量，在代码中始终可用</p><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>&emsp;&emsp;在项目根目录中新建.env, .env.production, .env.analyz 等文件</p><ul><li>.env</li></ul><p>&emsp;&emsp;serve 默认的本地开发环境配置</p><pre><code class="javascript">NODE_ENV = &quot;development&quot;BASE_URL = &quot;./&quot;VUE_APP_PUBLIC_PATH = &quot;./&quot;VUE_APP_API = &quot;https://test.staven630.com/api&quot;</code></pre><ul><li>.env.production</li></ul><p>&emsp;&emsp;build 默认的环境配置（正式服务器）</p><pre><code class="javascript">NODE_ENV = &quot;production&quot;BASE_URL = &quot;https://prod.staven630.com/&quot;VUE_APP_PUBLIC_PATH = &quot;https://prod.oss.com/staven-blog&quot;VUE_APP_API = &quot;https://prod.staven630.com/api&quot;ACCESS_KEY_ID = &quot;xxxxxxxxxxxxx&quot;ACCESS_KEY_SECRET = &quot;xxxxxxxxxxxxx&quot;REGION = &quot;oss-cn-hangzhou&quot;BUCKET = &quot;staven-prod&quot;PREFIX = &quot;staven-blog&quot;</code></pre><ul><li>.env.crm</li></ul><p>&emsp;&emsp;自定义 build 环境配置（预发服务器）</p><pre><code class="javascript">NODE_ENV = &quot;production&quot;BASE_URL = &quot;https://crm.staven630.com/&quot;VUE_APP_PUBLIC_PATH = &quot;https://crm.oss.com/staven-blog&quot;VUE_APP_API = &quot;https://crm.staven630.com/api&quot;ACCESS_KEY_ID = &quot;xxxxxxxxxxxxx&quot;ACCESS_KEY_SECRET = &quot;xxxxxxxxxxxxx&quot;REGION = &quot;oss-cn-hangzhou&quot;BUCKET = &quot;staven-crm&quot;PREFIX = &quot;staven-blog&quot;IS_ANALYZE = true;</code></pre><p>&emsp;&emsp;修改 package.json</p><pre><code class="javascript">&quot;scripts&quot;: &#123;  &quot;build&quot;: &quot;vue-cli-service build&quot;,  &quot;crm&quot;: &quot;vue-cli-service build --mode crm&quot;&#125;</code></pre><h5 id="使用环境变量"><a href="#使用环境变量" class="headerlink" title="使用环境变量"></a>使用环境变量</h5><pre><code class="javascript">&lt;template&gt;  &lt;div class=&quot;home&quot;&gt;    &lt;!-- template中使用环境变量 --&gt;     API: &#123;&#123; api &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;home&quot;,  data() &#123;    return &#123;      api: process.env.VUE_APP_API    &#125;;  &#125;,  mounted() &#123;    // js代码中使用环境变量    console.log(&quot;BASE_URL: &quot;, process.env.BASE_URL);    console.log(&quot;VUE_APP_API: &quot;, process.env.VUE_APP_API);  &#125;&#125;;&lt;/script&gt;</code></pre><p><a href="#top">▲ 回顶部</a></p><h3 id="✅-配置基础-vue-config-js"><a href="#✅-配置基础-vue-config-js" class="headerlink" title="✅ 配置基础 vue.config.js"></a><span id="base">✅ 配置基础 vue.config.js</span></h3><pre><code class="javascript">const IS_PROD = [&quot;production&quot;, &quot;prod&quot;].includes(process.env.NODE_ENV);module.exports = &#123;  publicPath: IS_PROD ? process.env.VUE_APP_PUBLIC_PATH : &quot;./&quot;, // 默认&#39;/&#39;，部署应用包时的基本 URL  // outputDir: process.env.outputDir || &#39;dist&#39;, // &#39;dist&#39;, 生产环境构建文件的目录  // assetsDir: &quot;&quot;, // 相对于outputDir的静态资源(js、css、img、fonts)目录  lintOnSave: false,  runtimeCompiler: true, // 是否使用包含运行时编译器的 Vue 构建版本  productionSourceMap: !IS_PROD, // 生产环境的 source map  parallel: require(&quot;os&quot;).cpus().length &gt; 1,  pwa: &#123;&#125;&#125;;</code></pre><p><a href="#top">▲ 回顶部</a></p><h3 id="✅-配置-proxy-代理解决跨域问题"><a href="#✅-配置-proxy-代理解决跨域问题" class="headerlink" title="✅ 配置 proxy 代理解决跨域问题"></a><span id="proxy">✅ 配置 proxy 代理解决跨域问题</span></h3><p>&emsp;&emsp;假设 mock 接口为<a href="https://www.easy-mock.com/mock/5bc75b55dc36971c160cad1b/sheets/1">https://www.easy-mock.com/mock/5bc75b55dc36971c160cad1b/sheets/1</a></p><pre><code class="javascript">module.exports = &#123;  devServer: &#123;    // overlay: &#123; // 让浏览器 overlay 同时显示警告和错误    //   warnings: true,    //   errors: true    // &#125;,    // open: false, // 是否打开浏览器    // host: &quot;localhost&quot;,    // port: &quot;8080&quot;, // 代理断就    // https: false,    // hotOnly: false, // 热更新    proxy: &#123;      &quot;/api&quot;: &#123;        target:          &quot;https://www.easy-mock.com/mock/5bc75b55dc36971c160cad1b/sheets&quot;, // 目标代理接口地址        secure: false,        changeOrigin: true, // 开启代理，在本地创建一个虚拟服务端        // ws: true, // 是否启用websockets        pathRewrite: &#123;          &quot;^/api&quot;: &quot;/&quot;        &#125;      &#125;    &#125;  &#125;&#125;;</code></pre><p>&emsp;&emsp;访问</p><pre><code class="javascript">&lt;script&gt;import axios from &quot;axios&quot;;export default &#123;  mounted() &#123;    axios.get(&quot;/api/1&quot;).then(res =&gt; &#123;      console.log(&#39;proxy:&#39;, res);    &#125;);  &#125;&#125;;&lt;/script&gt;</code></pre><p><a href="#top">▲ 回顶部</a></p><h3 id="✅-修复-HMR-热更新-失效"><a href="#✅-修复-HMR-热更新-失效" class="headerlink" title="✅ 修复 HMR(热更新)失效"></a><span id="hmr">✅ 修复 HMR(热更新)失效</span></h3><p>&emsp;&emsp;如果热更新失效，如下操作：</p><pre><code class="javascript">module.exports = &#123;  chainWebpack: config =&gt; &#123;    // 修复HMR    config.resolve.symlinks(true);  &#125;&#125;;</code></pre><p><a href="#top">▲ 回顶部</a></p><h3 id="✅-修复-Lazy-loading-routes-Error：-Cyclic-dependency-https-github-com-vuejs-vue-cli-issues-1669"><a href="#✅-修复-Lazy-loading-routes-Error：-Cyclic-dependency-https-github-com-vuejs-vue-cli-issues-1669" class="headerlink" title="✅ 修复 Lazy loading routes Error： Cyclic dependency https://github.com/vuejs/vue-cli/issues/1669"></a><span id="lazyloading">✅ 修复 Lazy loading routes Error： Cyclic dependency</span> <a href="https://github.com/vuejs/vue-cli/issues/1669">https://github.com/vuejs/vue-cli/issues/1669</a></h3><pre><code class="javascript">module.exports = &#123;  chainWebpack: config =&gt; &#123;    // 如果使用多页面打包，使用vue inspect --plugins查看html是否在结果数组中    config.plugin(&quot;html&quot;).tap(args =&gt; &#123;      // 修复 Lazy loading routes Error      args[0].chunksSortMode = &quot;none&quot;;      return args;    &#125;);  &#125;&#125;;</code></pre><p><a href="#top">▲ 回顶部</a></p><h3 id="✅-添加别名-alias"><a href="#✅-添加别名-alias" class="headerlink" title="✅ 添加别名 alias"></a><span id="alias">✅ 添加别名 alias</span></h3><pre><code class="javascript">const path = require(&quot;path&quot;);const resolve = dir =&gt; path.join(__dirname, dir);const IS_PROD = [&quot;production&quot;, &quot;prod&quot;].includes(process.env.NODE_ENV);module.exports = &#123;  chainWebpack: config =&gt; &#123;    // 添加别名    config.resolve.alias      .set(&quot;vue$&quot;, &quot;vue/dist/vue.esm.js&quot;)      .set(&quot;@&quot;, resolve(&quot;src&quot;))      .set(&quot;@assets&quot;, resolve(&quot;src/assets&quot;))      .set(&quot;@scss&quot;, resolve(&quot;src/assets/scss&quot;))      .set(&quot;@components&quot;, resolve(&quot;src/components&quot;))      .set(&quot;@plugins&quot;, resolve(&quot;src/plugins&quot;))      .set(&quot;@views&quot;, resolve(&quot;src/views&quot;))      .set(&quot;@router&quot;, resolve(&quot;src/router&quot;))      .set(&quot;@store&quot;, resolve(&quot;src/store&quot;))      .set(&quot;@layouts&quot;, resolve(&quot;src/layouts&quot;))      .set(&quot;@static&quot;, resolve(&quot;src/static&quot;));  &#125;&#125;;</code></pre><p><a href="#top">▲ 回顶部</a></p><h3 id="✅-压缩图片"><a href="#✅-压缩图片" class="headerlink" title="✅ 压缩图片"></a><span id="compressimage">✅ 压缩图片</span></h3><pre><code class="javascript">npm i -D image-webpack-loader</code></pre><p>&emsp;&emsp;在某些版本的 OSX 上安装可能会因缺少 libpng 依赖项而引发错误。可以通过安装最新版本的 libpng 来解决。</p><pre><code class="javascript">brew install libpng</code></pre><pre><code class="javascript">module.exports = &#123;  chainWebpack: config =&gt; &#123;    if (IS_PROD) &#123;      config.module        .rule(&quot;images&quot;)        .use(&quot;image-webpack-loader&quot;)        .loader(&quot;image-webpack-loader&quot;)        .options(&#123;          mozjpeg: &#123; progressive: true, quality: 65 &#125;,          optipng: &#123; enabled: false &#125;,          pngquant: &#123; quality: [0.65, 0.9], speed: 4 &#125;,          gifsicle: &#123; interlaced: false &#125;          // webp: &#123; quality: 75 &#125;        &#125;);    &#125;  &#125;&#125;;</code></pre><p><a href="#top">▲ 回顶部</a></p><h3 id="✅-自动生成雪碧图"><a href="#✅-自动生成雪碧图" class="headerlink" title="✅ 自动生成雪碧图"></a><span id="spritesmith">✅ 自动生成雪碧图</span></h3><p>&emsp;&emsp;默认 src/assets/icons 中存放需要生成雪碧图的 png 文件。首次运行 npm run serve/build 会生成雪碧图，并在跟目录生成 icons.json 文件。再次运行命令时，会对比 icons 目录内文件与 icons.json 的匹配关系，确定是否需要再次执行 webpack-spritesmith 插件。</p><pre><code class="bash">npm i -D webpack-spritesmith</code></pre><pre><code class="javascript">let has_sprite = true;let files = [];const icons = &#123;&#125;;try &#123;  fs.statSync(resolve(&quot;./src/assets/icons&quot;));  files = fs.readdirSync(resolve(&quot;./src/assets/icons&quot;));  files.forEach(item =&gt; &#123;    let filename = item.toLocaleLowerCase().replace(/_/g, &quot;-&quot;);    icons[filename] = true;  &#125;);&#125; catch (error) &#123;  fs.mkdirSync(resolve(&quot;./src/assets/icons&quot;));&#125;if (!files.length) &#123;  has_sprite = false;&#125; else &#123;  try &#123;    let iconsObj = fs.readFileSync(resolve(&quot;./icons.json&quot;), &quot;utf8&quot;);    iconsObj = JSON.parse(iconsObj);    has_sprite = files.some(item =&gt; &#123;      let filename = item.toLocaleLowerCase().replace(/_/g, &quot;-&quot;);      return !iconsObj[filename];    &#125;);    if (has_sprite) &#123;      fs.writeFileSync(resolve(&quot;./icons.json&quot;), JSON.stringify(icons, null, 2));    &#125;  &#125; catch (error) &#123;    fs.writeFileSync(resolve(&quot;./icons.json&quot;), JSON.stringify(icons, null, 2));    has_sprite = true;  &#125;&#125;// 雪碧图样式处理模板const SpritesmithTemplate = function(data) &#123;  // pc  let icons = &#123;&#125;;  let tpl = `.ico &#123;   display: inline-block;   background-image: url($&#123;data.sprites[0].image&#125;);   background-size: $&#123;data.spritesheet.width&#125;px $&#123;data.spritesheet.height&#125;px; &#125;`;  data.sprites.forEach(sprite =&gt; &#123;    const name = &quot;&quot; + sprite.name.toLocaleLowerCase().replace(/_/g, &quot;-&quot;);    icons[`$&#123;name&#125;.png`] = true;    tpl = `$&#123;tpl&#125; .ico-$&#123;name&#125;&#123;  width: $&#123;sprite.width&#125;px;   height: $&#123;sprite.height&#125;px;   background-position: $&#123;sprite.offset_x&#125;px $&#123;sprite.offset_y&#125;px;&#125;`;  &#125;);  return tpl;&#125;;module.exports = &#123;  configureWebpack: config =&gt; &#123;    const plugins = [];    if (has_sprite) &#123;      plugins.push(        new SpritesmithPlugin(&#123;          src: &#123;            cwd: path.resolve(__dirname, &quot;./src/assets/icons/&quot;), // 图标根路径            glob: &quot;**/*.png&quot; // 匹配任意 png 图标          &#125;,          target: &#123;            image: path.resolve(__dirname, &quot;./src/assets/images/sprites.png&quot;), // 生成雪碧图目标路径与名称            // 设置生成CSS背景及其定位的文件或方式            css: [              [                path.resolve(__dirname, &quot;./src/assets/scss/sprites.scss&quot;),                &#123;                  format: &quot;function_based_template&quot;                &#125;              ]            ]          &#125;,          customTemplates: &#123;            function_based_template: SpritesmithTemplate          &#125;,          apiOptions: &#123;            cssImageRef: &quot;../images/sprites.png&quot; // css文件中引用雪碧图的相对位置路径配置          &#125;,          spritesmithOptions: &#123;            padding: 2          &#125;        &#125;)      );    &#125;    config.plugins = [...config.plugins, ...plugins];  &#125;&#125;;</code></pre><p><a href="#top">▲ 回顶部</a></p><h3 id="✅-SVG-转-font-字体"><a href="#✅-SVG-转-font-字体" class="headerlink" title="✅ SVG 转 font 字体"></a><span id="font">✅ SVG 转 font 字体</span></h3><pre><code class="bash">npm i -D svgtofont</code></pre><p>&emsp;&emsp;根目录新增 scripts 目录，并新建 svg2font.js 文件：</p><pre><code class="javascript">const svgtofont = require(&quot;svgtofont&quot;);const path = require(&quot;path&quot;);const pkg = require(&quot;../package.json&quot;);svgtofont(&#123;  src: path.resolve(process.cwd(), &quot;src/assets/svg&quot;), // svg 图标目录路径  dist: path.resolve(process.cwd(), &quot;src/assets/fonts&quot;), // 输出到指定目录中  fontName: &quot;icon&quot;, // 设置字体名称  css: true, // 生成字体文件  startNumber: 20000, // unicode起始编号  svgicons2svgfont: &#123;    fontHeight: 1000,    normalize: true  &#125;,  // website = null, 没有演示html文件  website: &#123;    title: &quot;icon&quot;,    logo: &quot;&quot;,    version: pkg.version,    meta: &#123;      description: &quot;&quot;,      keywords: &quot;&quot;    &#125;,    description: ``,    links: [      &#123;        title: &quot;Font Class&quot;,        url: &quot;index.html&quot;      &#125;,      &#123;        title: &quot;Unicode&quot;,        url: &quot;unicode.html&quot;      &#125;    ],    footerInfo: ``  &#125;&#125;).then(() =&gt; &#123;  console.log(&quot;done!&quot;);&#125;);</code></pre><p>&emsp;&emsp;添加 package.json scripts 配置：</p><pre><code class="javascript">&quot;prebuild&quot;: &quot;npm run font&quot;,&quot;font&quot;: &quot;node scripts/svg2font.js&quot;,</code></pre><p>&emsp;&emsp;执行：</p><pre><code class="javascript">npm run font</code></pre><p><a href="#top">▲ 回顶部</a></p><h3 id="✅-使用-SVG-组件"><a href="#✅-使用-SVG-组件" class="headerlink" title="✅ 使用 SVG 组件"></a><span id="svg">✅ 使用 SVG 组件</span></h3><pre><code class="bash">npm i -D svg-sprite-loader</code></pre><p>&emsp;&emsp;新增 SvgIcon 组件。</p><pre><code class="javascript">&lt;template&gt;  &lt;svg class=&quot;svg-icon&quot;       aria-hidden=&quot;true&quot;&gt;    &lt;use :xlink:href=&quot;iconName&quot; /&gt;  &lt;/svg&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;SvgIcon&#39;,  props: &#123;    iconClass: &#123;      type: String,      required: true    &#125;  &#125;,  computed: &#123;    iconName() &#123;      return `#icon-$&#123;this.iconClass&#125;`    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.svg-icon &#123;  width: 1em;  height: 1em;  vertical-align: -0.15em;  fill: currentColor;  overflow: hidden;&#125;&lt;/style&gt;</code></pre><p>&emsp;&emsp;在 src 文件夹中创建 icons 文件夹。icons 文件夹中新增 svg 文件夹（用来存放 svg 文件）与 index.js 文件：</p><pre><code class="js">import SvgIcon from &quot;@/components/SvgIcon&quot;;import Vue from &quot;vue&quot;;// 注册到全局Vue.component(&quot;svg-icon&quot;, SvgIcon);const requireAll = requireContext =&gt; requireContext.keys().map(requireContext);const req = require.context(&quot;./svg&quot;, false, /\.svg$/);requireAll(req);</code></pre><p>&emsp;&emsp;在 main.js 中导入 icons/index.js</p><pre><code class="javascript">import &quot;@/icons&quot;;</code></pre><p>&emsp;&emsp;修改 vue.config.js</p><pre><code class="javascript">const path = require(&quot;path&quot;);const resolve = dir =&gt; path.join(__dirname, dir);module.exports = &#123;  chainWebpack: config =&gt; &#123;    const svgRule = config.module.rule(&quot;svg&quot;);    svgRule.uses.clear();    svgRule.exclude.add(/node_modules/);    svgRule      .test(/\.svg$/)      .use(&quot;svg-sprite-loader&quot;)      .loader(&quot;svg-sprite-loader&quot;)      .options(&#123;        symbolId: &quot;icon-[name]&quot;      &#125;);    const imagesRule = config.module.rule(&quot;images&quot;);    imagesRule.exclude.add(resolve(&quot;src/icons&quot;));    config.module.rule(&quot;images&quot;).test(/\.(png|jpe?g|gif|svg)(\?.*)?$/);  &#125;&#125;;</code></pre><p><a href="#top">▲ 回顶部</a></p><h3 id="✅-去除多余无效的-css"><a href="#✅-去除多余无效的-css" class="headerlink" title="✅ 去除多余无效的 css"></a><span id="removecss">✅ 去除多余无效的 css</span></h3><p>&emsp;&emsp;注：谨慎使用。可能出现各种样式丢失现象。</p><ul><li>方案一：@fullhuman/postcss-purgecss</li></ul><pre><code class="bash">npm i -D postcss-import @fullhuman/postcss-purgecss</code></pre><p>&emsp;&emsp;更新 postcss.config.js</p><pre><code class="javascript">const autoprefixer = require(&quot;autoprefixer&quot;);const postcssImport = require(&quot;postcss-import&quot;);const purgecss = require(&quot;@fullhuman/postcss-purgecss&quot;);const IS_PROD = [&quot;production&quot;, &quot;prod&quot;].includes(process.env.NODE_ENV);let plugins = [];if (IS_PROD) &#123;  plugins.push(postcssImport);  plugins.push(    purgecss(&#123;      content: [        &quot;./layouts/**/*.vue&quot;,        &quot;./components/**/*.vue&quot;,        &quot;./pages/**/*.vue&quot;      ],      extractors: [        &#123;          extractor: class Extractor &#123;            static extract(content) &#123;              const validSection = content.replace(                /&lt;style([\s\S]*?)&lt;\/style&gt;+/gim,                &quot;&quot;              );              return (                validSection.match(/[A-Za-z0-9-_/:]*[A-Za-z0-9-_/]+/g) || []              );            &#125;          &#125;,          extensions: [&quot;html&quot;, &quot;vue&quot;]        &#125;      ],      whitelist: [&quot;html&quot;, &quot;body&quot;],      whitelistPatterns: [        /el-.*/,        /-(leave|enter|appear)(|-(to|from|active))$/,        /^(?!cursor-move).+-move$/,        /^router-link(|-exact)-active$/      ],      whitelistPatternsChildren: [/^token/, /^pre/, /^code/]    &#125;)  );&#125;module.exports = &#123;  plugins: [...plugins, autoprefixer]&#125;;</code></pre><ul><li>方案二：purgecss-webpack-plugin</li></ul><pre><code class="bash">npm i -D glob-all purgecss-webpack-plugin</code></pre><pre><code class="javascript">const path = require(&quot;path&quot;);const glob = require(&quot;glob-all&quot;);const PurgecssPlugin = require(&quot;purgecss-webpack-plugin&quot;);const resolve = dir =&gt; path.join(__dirname, dir);const IS_PROD = [&quot;production&quot;, &quot;prod&quot;].includes(process.env.NODE_ENV);module.exports = &#123;  configureWebpack: config =&gt; &#123;    const plugins = [];    if (IS_PROD) &#123;      plugins.push(        new PurgecssPlugin(&#123;          paths: glob.sync([resolve(&quot;./**/*.vue&quot;)]),          extractors: [            &#123;              extractor: class Extractor &#123;                static extract(content) &#123;                  const validSection = content.replace(                    /&lt;style([\s\S]*?)&lt;\/style&gt;+/gim,                    &quot;&quot;                  );                  return (                    validSection.match(/[A-Za-z0-9-_/:]*[A-Za-z0-9-_/]+/g) || []                  );                &#125;              &#125;,              extensions: [&quot;html&quot;, &quot;vue&quot;]            &#125;          ],          whitelist: [&quot;html&quot;, &quot;body&quot;],          whitelistPatterns: [            /el-.*/,            /-(leave|enter|appear)(|-(to|from|active))$/,            /^(?!cursor-move).+-move$/,            /^router-link(|-exact)-active$/          ],          whitelistPatternsChildren: [/^token/, /^pre/, /^code/]        &#125;)      );    &#125;    config.plugins = [...config.plugins, ...plugins];  &#125;&#125;;</code></pre><p><a href="#top">▲ 回顶部</a></p><h3 id="✅-添加打包分析"><a href="#✅-添加打包分析" class="headerlink" title="✅ 添加打包分析"></a><span id="analyze">✅ 添加打包分析</span></h3><pre><code class="javascript">const BundleAnalyzerPlugin = require(&quot;webpack-bundle-analyzer&quot;)  .BundleAnalyzerPlugin;module.exports = &#123;  chainWebpack: config =&gt; &#123;    // 打包分析    if (IS_PROD) &#123;      config.plugin(&quot;webpack-report&quot;).use(BundleAnalyzerPlugin, [        &#123;          analyzerMode: &quot;static&quot;        &#125;      ]);    &#125;  &#125;&#125;;</code></pre><p><a href="#top">▲ 回顶部</a></p><h3 id="✅-配置-externals-引入-cdn-资源"><a href="#✅-配置-externals-引入-cdn-资源" class="headerlink" title="✅ 配置 externals 引入 cdn 资源"></a><span id="externals">✅ 配置 externals 引入 cdn 资源</span></h3><p>&emsp;&emsp;防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖</p><pre><code class="javascript">module.exports = &#123;  configureWebpack: config =&gt; &#123;    config.externals = &#123;      vue: &quot;Vue&quot;,      &quot;element-ui&quot;: &quot;ELEMENT&quot;,      &quot;vue-router&quot;: &quot;VueRouter&quot;,      vuex: &quot;Vuex&quot;,      axios: &quot;axios&quot;    &#125;;  &#125;,  chainWebpack: config =&gt; &#123;    const cdn = &#123;      // 访问https://unpkg.com/element-ui/lib/theme-chalk/index.css获取最新版本      css: [&quot;//unpkg.com/element-ui@2.10.1/lib/theme-chalk/index.css&quot;],      js: [        &quot;//unpkg.com/vue@2.6.10/dist/vue.min.js&quot;, // 访问https://unpkg.com/vue/dist/vue.min.js获取最新版本        &quot;//unpkg.com/vue-router@3.0.6/dist/vue-router.min.js&quot;,        &quot;//unpkg.com/vuex@3.1.1/dist/vuex.min.js&quot;,        &quot;//unpkg.com/axios@0.19.0/dist/axios.min.js&quot;,        &quot;//unpkg.com/element-ui@2.10.1/lib/index.js&quot;      ]    &#125;;    // 如果使用多页面打包，使用vue inspect --plugins查看html是否在结果数组中    config.plugin(&quot;html&quot;).tap(args =&gt; &#123;      // html中添加cdn      args[0].cdn = cdn;      return args;    &#125;);  &#125;&#125;;</code></pre><p>&emsp;&emsp;在 html 中添加</p><pre><code>&lt;!-- 使用CDN的CSS文件 --&gt;&lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp;htmlWebpackPlugin.options.cdn.css) &#123; %&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%= htmlWebpackPlugin.options.cdn.css[i] %&gt;&quot; /&gt;&lt;% &#125; %&gt;&lt;!-- 使用CDN的JS文件 --&gt;&lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp;htmlWebpackPlugin.options.cdn.js) &#123; %&gt;&lt;script  type=&quot;text/javascript&quot;  src=&quot;&lt;%= htmlWebpackPlugin.options.cdn.js[i] %&gt;&quot;&gt;&lt;/script&gt;&lt;% &#125; %&gt;</code></pre><p><a href="#top">▲ 回顶部</a></p><h3 id="✅-多页面打包-multi-page"><a href="#✅-多页面打包-multi-page" class="headerlink" title="✅ 多页面打包 multi-page"></a><span id="multiple-pages">✅ 多页面打包 multi-page</span></h3><p>&emsp;&emsp;多入口页面打包，建议在 src 目录下新建 pages 目录存放多页面模块。</p><ul><li>pages.config.js</li></ul><p>&emsp;&emsp; 配置多页面信息。src/main.js 文件对应 main 字段，其他根据参照 pages 为根路径为字段。如下:</p><pre><code class="javascript">module.exports = &#123;  &#39;admin&#39;: &#123;    template: &#39;public/index.html&#39;,    filename: &#39;admin.html&#39;,    title: &#39;后台管理&#39;,  &#125;,  &#39;mobile&#39;: &#123;    template: &#39;public/index.html&#39;,    filename: &#39;mobile.html&#39;,    title: &#39;移动端&#39;,  &#125;,  &#39;pc/crm&#39;: &#123;    template: &#39;public/index.html&#39;,    filename: &#39;pc-crm.html&#39;,    title: &#39;预发服务&#39;,  &#125;&#125;</code></pre><ul><li>vue.config.js</li></ul><p>&emsp;&emsp;vue.config.js 的 pages 字段为多页面提供配置</p><pre><code class="javascript">const glob = require(&quot;glob&quot;);const pagesInfo = require(&quot;./pages.config&quot;);const pages = &#123;&#125;;glob.sync(&#39;./src/pages/**/main.js&#39;).forEach(entry =&gt; &#123;  let chunk = entry.match(/\.\/src\/pages\/(.*)\/main\.js/)[1];  const curr = pagesInfo[chunk];  if (curr) &#123;    pages[chunk] = &#123;      entry,      ...curr,      chunk: [&quot;chunk-vendors&quot;, &quot;chunk-common&quot;, chunk]    &#125;  &#125;&#125;)module.exports = &#123;  chainWebpack: config =&gt; &#123;    // 防止多页面打包卡顿    config =&gt; config.plugins.delete(&quot;named-chunks&quot;);    return config;  &#125;,  pages&#125;;</code></pre><p>&emsp;&emsp;如果多页面打包需要使用 CDN，使用 vue inspect –plugins 查看 html 是否在结果数组中的形式。上例中 plugins 列表中存在’html-main’,’html-pages/admin’,’html-pages/mobile’， 没有’html’。因此不能再使用 config.plugin(“html”)。</p><pre><code class="javascript">const path = require(&quot;path&quot;);const resolve = dir =&gt; path.join(__dirname, dir);const IS_PROD = [&quot;production&quot;, &quot;prod&quot;].includes(process.env.NODE_ENV);const glob = require(&quot;glob&quot;);const pagesInfo = require(&quot;./pages.config&quot;);const pages = &#123;&#125;;glob.sync(&#39;./src/pages/**/main.js&#39;).forEach(entry =&gt; &#123;  let chunk = entry.match(/\.\/src\/pages\/(.*)\/main\.js/)[1];  const curr = pagesInfo[chunk];  if (curr) &#123;    pages[chunk] = &#123;      entry,      ...curr,      chunk: [&quot;chunk-vendors&quot;, &quot;chunk-common&quot;, chunk]    &#125;  &#125;&#125;);module.exports = &#123;  publicPath: IS_PROD ? process.env.VUE_APP_PUBLIC_PATH : &quot;./&quot;, //  configureWebpack: config =&gt; &#123;    config.externals = &#123;      vue: &quot;Vue&quot;,      &quot;element-ui&quot;: &quot;ELEMENT&quot;,      &quot;vue-router&quot;: &quot;VueRouter&quot;,      vuex: &quot;Vuex&quot;,      axios: &quot;axios&quot;    &#125;;  &#125;,  chainWebpack: config =&gt; &#123;    const cdn = &#123;      // 访问https://unpkg.com/element-ui/lib/theme-chalk/index.css获取最新版本      css: [&quot;//unpkg.com/element-ui@2.10.1/lib/theme-chalk/index.css&quot;],      js: [        &quot;//unpkg.com/vue@2.6.10/dist/vue.min.js&quot;, // 访问https://unpkg.com/vue/dist/vue.min.js获取最新版本        &quot;//unpkg.com/vue-router@3.0.6/dist/vue-router.min.js&quot;,        &quot;//unpkg.com/vuex@3.1.1/dist/vuex.min.js&quot;,        &quot;//unpkg.com/axios@0.19.0/dist/axios.min.js&quot;,        &quot;//unpkg.com/element-ui@2.10.1/lib/index.js&quot;      ]    &#125;;    // 防止多页面打包卡顿    config =&gt; config.plugins.delete(&quot;named-chunks&quot;);    // 多页面cdn添加    Object.keys(pagesInfo).forEach(page =&gt; &#123;      config.plugin(`html-$&#123;page&#125;`).tap(args =&gt; &#123;        // html中添加cdn        args[0].cdn = cdn;        // 修复 Lazy loading routes Error        args[0].chunksSortMode = &quot;none&quot;;        return args;      &#125;);    &#125;);    return config;  &#125;,  pages&#125;;</code></pre><p><a href="#top">▲ 回顶部</a></p><h3 id="✅-删除-moment-语言包"><a href="#✅-删除-moment-语言包" class="headerlink" title="✅ 删除 moment 语言包"></a><span id="moment">✅ 删除 moment 语言包</span></h3><p>&emsp;&emsp;删除 moment 除 zh-cn 中文包外的其它语言包，无需在代码中手动引入 zh-cn 语言包。</p><pre><code class="javascript">const webpack = require(&quot;webpack&quot;);module.exports = &#123;  chainWebpack: config =&gt; &#123;    config      .plugin(&quot;ignore&quot;)      .use(        new webpack.ContextReplacementPlugin(/moment[/\\]locale$/, /zh-cn$/)      );    return config;  &#125;&#125;;</code></pre><p><a href="#top">▲ 回顶部</a></p><h3 id="✅-去掉-console-log"><a href="#✅-去掉-console-log" class="headerlink" title="✅ 去掉 console.log"></a><span id="log">✅ 去掉 console.log</span></h3><h5 id="方法一：使用-babel-plugin-transform-remove-console-插件"><a href="#方法一：使用-babel-plugin-transform-remove-console-插件" class="headerlink" title="方法一：使用 babel-plugin-transform-remove-console 插件"></a>方法一：使用 babel-plugin-transform-remove-console 插件</h5><pre><code class="bash">npm i -D babel-plugin-transform-remove-console</code></pre><p>在 babel.config.js 中配置</p><pre><code>const IS_PROD = [&quot;production&quot;, &quot;prod&quot;].includes(process.env.NODE_ENV);const plugins = [];if (IS_PROD) &#123;  plugins.push(&quot;transform-remove-console&quot;);&#125;module.exports = &#123;  presets: [&quot;@vue/app&quot;, &#123; useBuiltIns: &quot;entry&quot; &#125;],  plugins&#125;;</code></pre><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><pre><code class="javascript">const UglifyJsPlugin = require(&quot;uglifyjs-webpack-plugin&quot;);module.exports = &#123;  configureWebpack: config =&gt; &#123;    if (IS_PROD) &#123;      const plugins = [];      plugins.push(        new UglifyJsPlugin(&#123;          uglifyOptions: &#123;            compress: &#123;              warnings: false,              drop_console: true,              drop_debugger: false,              pure_funcs: [&quot;console.log&quot;] //移除console            &#125;          &#125;,          sourceMap: false,          parallel: true        &#125;)      );      config.plugins = [...config.plugins, ...plugins];    &#125;  &#125;&#125;;</code></pre><p>&emsp;&emsp;如果使用 uglifyjs-webpack-plugin 会报错，可能存在 node_modules 中有些依赖需要 babel 转译。</p><p>&emsp;&emsp;而 vue-cli 的<a href="https://cli.vuejs.org/zh/config/#transpiledependencies">transpileDependencies</a>配置默认为[], babel-loader 会忽略所有 node_modules 中的文件。如果你想要通过 Babel 显式转译一个依赖，可以在这个选项中列出来。配置需要转译的第三方库。</p><p><a href="#top">▲ 回顶部</a></p><h3 id="利用-splitChunks-单独打包第三方模块"><a href="#利用-splitChunks-单独打包第三方模块" class="headerlink" title="利用 splitChunks 单独打包第三方模块"></a><span id="splitchunks">利用 splitChunks 单独打包第三方模块</span></h3><pre><code class="javascript">const IS_PROD = [&quot;production&quot;, &quot;prod&quot;].includes(process.env.NODE_ENV);module.exports = &#123;  configureWebpack: config =&gt; &#123;    if (IS_PROD) &#123;      config.optimization = &#123;        splitChunks: &#123;          cacheGroups: &#123;            common: &#123;              name: &quot;chunk-common&quot;,              chunks: &quot;initial&quot;,              minChunks: 2,              maxInitialRequests: 5,              minSize: 0,              priority: 1,              reuseExistingChunk: true,              enforce: true            &#125;,            vendors: &#123;              name: &quot;chunk-vendors&quot;,              test: /[\\/]node_modules[\\/]/,              chunks: &quot;initial&quot;,              priority: 2,              reuseExistingChunk: true,              enforce: true            &#125;,            elementUI: &#123;              name: &quot;chunk-elementui&quot;,              test: /[\\/]node_modules[\\/]element-ui[\\/]/,              chunks: &quot;all&quot;,              priority: 3,              reuseExistingChunk: true,              enforce: true            &#125;,            echarts: &#123;              name: &quot;chunk-echarts&quot;,              test: /[\\/]node_modules[\\/](vue-)?echarts[\\/]/,              chunks: &quot;all&quot;,              priority: 4,              reuseExistingChunk: true,              enforce: true            &#125;          &#125;        &#125;      &#125;;    &#125;  &#125;,  chainWebpack: config =&gt; &#123;    if (IS_PROD) &#123;      config.optimization.delete(&quot;splitChunks&quot;);    &#125;    return config;  &#125;&#125;;</code></pre><p><a href="#top">▲ 回顶部</a></p><h3 id="✅-开启-gzip-压缩"><a href="#✅-开启-gzip-压缩" class="headerlink" title="✅ 开启 gzip 压缩"></a><span id="gzip">✅ 开启 gzip 压缩</span></h3><pre><code class="bash">npm i -D compression-webpack-plugin</code></pre><pre><code class="javascript">const CompressionWebpackPlugin = require(&quot;compression-webpack-plugin&quot;);const IS_PROD = [&quot;production&quot;, &quot;prod&quot;].includes(process.env.NODE_ENV);const productionGzipExtensions = /\.(js|css|json|txt|html|ico|svg)(\?.*)?$/i;module.exports = &#123;  configureWebpack: config =&gt; &#123;    const plugins = [];    if (IS_PROD) &#123;      plugins.push(        new CompressionWebpackPlugin(&#123;          filename: &quot;[path].gz[query]&quot;,          algorithm: &quot;gzip&quot;,          test: productionGzipExtensions,          threshold: 10240,          minRatio: 0.8        &#125;)      );    &#125;    config.plugins = [...config.plugins, ...plugins];  &#125;&#125;;</code></pre><p>&emsp;&emsp;还可以开启比 gzip 体验更好的 Zopfli 压缩详见<a href="https://webpack.js.org/plugins/compression-webpack-plugin">https://webpack.js.org/plugins/compression-webpack-plugin</a></p><pre><code class="bash">npm i -D @gfx/zopfli brotli-webpack-plugin</code></pre><pre><code class="javascript">const CompressionWebpackPlugin = require(&quot;compression-webpack-plugin&quot;);const zopfli = require(&quot;@gfx/zopfli&quot;);const BrotliPlugin = require(&quot;brotli-webpack-plugin&quot;);const IS_PROD = [&quot;production&quot;, &quot;prod&quot;].includes(process.env.NODE_ENV);const productionGzipExtensions = /\.(js|css|json|txt|html|ico|svg)(\?.*)?$/i;module.exports = &#123;  configureWebpack: config =&gt; &#123;    const plugins = [];    if (IS_PROD) &#123;      plugins.push(        new CompressionWebpackPlugin(&#123;          algorithm(input, compressionOptions, callback) &#123;            return zopfli.gzip(input, compressionOptions, callback);          &#125;,          compressionOptions: &#123;            numiterations: 15          &#125;,          minRatio: 0.99,          test: productionGzipExtensions        &#125;)      );      plugins.push(        new BrotliPlugin(&#123;          test: productionGzipExtensions,          minRatio: 0.99        &#125;)      );    &#125;    config.plugins = [...config.plugins, ...plugins];  &#125;&#125;;</code></pre><p><a href="#top">▲ 回顶部</a></p><h3 id="✅-开启-stylelint-检测scss-css语法"><a href="#✅-开启-stylelint-检测scss-css语法" class="headerlink" title="✅ 开启 stylelint 检测scss, css语法"></a><span id="stylelint">✅ 开启 stylelint 检测scss, css语法</span></h3><pre><code class="bash">npm i -D stylelint stylelint-config-standard stylelint-config-prettier stylelint-webpack-plugin</code></pre><p>在文件夹创建stylelint.config.js,详细配置在<a href="https://stylelint.io/user-guide/configuration">这里</a></p><pre><code class="javascript">module.exports = &#123;  ignoreFiles: [&quot;**/*.js&quot;, &quot;src/assets/css/element-variables.scss&quot;, &quot;theme/&quot;],   extends: [&quot;stylelint-config-standard&quot;, &quot;stylelint-config-prettier&quot;],  rules: &#123;    &quot;no-empty-source&quot;: null,    &quot;at-rule-no-unknown&quot;: [      true,      &#123;        ignoreAtRules: [&quot;extend&quot;]      &#125;    ]  &#125;&#125;;</code></pre><p>启用webpack配置</p><pre><code class="javascript">const StylelintPlugin = require(&quot;stylelint-webpack-plugin&quot;);module.exports = &#123;  configureWebpack: config =&gt; &#123;    const plugins = [];    if (IS_DEV) &#123;      plugins.push(        new StylelintPlugin(&#123;          files: [&quot;src/**/*.vue&quot;, &quot;src/assets/**/*.scss&quot;],          fix: true //打开自动修复（谨慎使用！注意上面的配置不要加入js或html文件，会发生问题，js文件请手动修复）        &#125;)      );    &#125;    config.plugins = [...config.plugins, ...plugins];  &#125;&#125;</code></pre><p><a href="#top">▲ 回顶部</a></p><h3 id="✅-为-sass-提供全局样式，以及全局变量"><a href="#✅-为-sass-提供全局样式，以及全局变量" class="headerlink" title="✅ 为 sass 提供全局样式，以及全局变量"></a><span id="globalscss">✅ 为 sass 提供全局样式，以及全局变量</span></h3><p>&emsp;&emsp;可以通过在 main.js 中 Vue.prototype.$src = process.env.VUE_APP_PUBLIC_PATH;挂载环境变量中的配置信息，然后在js中使用$src 访问。</p><p>&emsp;&emsp;css 中可以使用注入 sass 变量访问环境变量中的配置信息</p><pre><code class="javascript">const IS_PROD = [&quot;production&quot;, &quot;prod&quot;].includes(process.env.NODE_ENV);module.exports = &#123;  css: &#123;    extract: IS_PROD,    sourceMap: false,    loaderOptions: &#123;      scss: &#123;        // 向全局sass样式传入共享的全局变量, $src可以配置图片cdn前缀        // 详情: https://cli.vuejs.org/guide/css.html#passing-options-to-pre-processor-loaders        prependData: `        @import &quot;@scss/variables.scss&quot;;        @import &quot;@scss/mixins.scss&quot;;        @import &quot;@scss/function.scss&quot;;        $src: &quot;$&#123;process.env.VUE_APP_OSS_SRC&#125;&quot;;        `      &#125;    &#125;  &#125;&#125;;</code></pre><p>在 scss 中引用</p><pre><code class="css">.home &#123;  background: url($src+&quot;/images/500.png&quot;);&#125;</code></pre><p><a href="#top">▲ 回顶部</a></p><h3 id="✅-为-stylus-提供全局变量"><a href="#✅-为-stylus-提供全局变量" class="headerlink" title="✅ 为 stylus 提供全局变量"></a><span id="globalstylus">✅ 为 stylus 提供全局变量</span></h3><pre><code class="bash">npm i -D style-resources-loader</code></pre><pre><code class="javascript">const path = require(&quot;path&quot;);const resolve = dir =&gt; path.resolve(__dirname, dir);const addStylusResource = rule =&gt; &#123;  rule    .use(&quot;style-resouce&quot;)    .loader(&quot;style-resources-loader&quot;)    .options(&#123;      patterns: [resolve(&quot;src/assets/stylus/variable.styl&quot;)]    &#125;);&#125;;module.exports = &#123;  chainWebpack: config =&gt; &#123;    const types = [&quot;vue-modules&quot;, &quot;vue&quot;, &quot;normal-modules&quot;, &quot;normal&quot;];    types.forEach(type =&gt;      addStylusResource(config.module.rule(&quot;stylus&quot;).oneOf(type))    );  &#125;&#125;;</code></pre><p><a href="#top">▲ 回顶部</a></p><h3 id="预渲染-prerender-spa-plugin"><a href="#预渲染-prerender-spa-plugin" class="headerlink" title="预渲染 prerender-spa-plugin"></a><span id="prerender">预渲染 prerender-spa-plugin</span></h3><pre><code class="bash">npm i -D prerender-spa-plugin</code></pre><pre><code class="javascript">const PrerenderSpaPlugin = require(&quot;prerender-spa-plugin&quot;);const path = require(&quot;path&quot;);const resolve = dir =&gt; path.join(__dirname, dir);const IS_PROD = [&quot;production&quot;, &quot;prod&quot;].includes(process.env.NODE_ENV);module.exports = &#123;  configureWebpack: config =&gt; &#123;    const plugins = [];    if (IS_PROD) &#123;      plugins.push(        new PrerenderSpaPlugin(&#123;          staticDir: resolve(&quot;dist&quot;),          routes: [&quot;/&quot;],          postProcess(ctx) &#123;            ctx.route = ctx.originalRoute;            ctx.html = ctx.html.split(/&gt;[\s]+&lt;/gim).join(&quot;&gt;&lt;&quot;);            if (ctx.route.endsWith(&quot;.html&quot;)) &#123;              ctx.outputPath = path.join(__dirname, &quot;dist&quot;, ctx.route);            &#125;            return ctx;          &#125;,          minify: &#123;            collapseBooleanAttributes: true,            collapseWhitespace: true,            decodeEntities: true,            keepClosingSlash: true,            sortAttributes: true          &#125;,          renderer: new PrerenderSpaPlugin.PuppeteerRenderer(&#123;            // 需要注入一个值，这样就可以检测页面当前是否是预渲染的            inject: &#123;&#125;,            headless: false,            // 视图组件是在API请求获取所有必要数据后呈现的，因此我们在dom中存在“data view”属性后创建页面快照            renderAfterDocumentEvent: &quot;render-event&quot;          &#125;)        &#125;)      );    &#125;    config.plugins = [...config.plugins, ...plugins];  &#125;&#125;;</code></pre><p>&emsp;&emsp;mounted()中添加 document.dispatchEvent(new Event(‘render-event’))</p><pre><code class="javascript">new Vue(&#123;  router,  store,  render: h =&gt; h(App),  mounted() &#123;    document.dispatchEvent(new Event(&quot;render-event&quot;));  &#125;&#125;).$mount(&quot;#app&quot;);</code></pre><h5 id="为自定义预渲染页面添加自定义-title、description、content"><a href="#为自定义预渲染页面添加自定义-title、description、content" class="headerlink" title="为自定义预渲染页面添加自定义 title、description、content"></a>为自定义预渲染页面添加自定义 title、description、content</h5><ul><li><p>删除 public/index.html 中关于 description、content 的 meta 标签。保留 title 标签</p></li><li><p>配置 router-config.js</p></li></ul><pre><code class="javascript">module.exports = &#123;  &quot;/&quot;: &#123;    title: &quot;首页&quot;,    keywords: &quot;首页关键词&quot;,    description: &quot;这是首页描述&quot;  &#125;,  &quot;/about.html&quot;: &#123;    title: &quot;关于我们&quot;,    keywords: &quot;关于我们页面关键词&quot;,    description: &quot;关于我们页面关键词描述&quot;  &#125;&#125;;</code></pre><ul><li>vue.config.js</li></ul><pre><code class="js">const path = require(&quot;path&quot;);const PrerenderSpaPlugin = require(&quot;prerender-spa-plugin&quot;);const routesConfig = require(&quot;./router-config&quot;);const resolve = dir =&gt; path.join(__dirname, dir);const IS_PROD = [&quot;production&quot;, &quot;prod&quot;].includes(process.env.NODE_ENV);module.exports = &#123;  configureWebpack: config =&gt; &#123;    const plugins = [];    if (IS_PROD) &#123;      // 预加载      plugins.push(        new PrerenderSpaPlugin(&#123;          staticDir: resolve(&quot;dist&quot;),          routes: Object.keys(routesConfig),          postProcess(ctx) &#123;            ctx.route = ctx.originalRoute;            ctx.html = ctx.html.split(/&gt;[\s]+&lt;/gim).join(&quot;&gt;&lt;&quot;);            ctx.html = ctx.html.replace(              /&lt;title&gt;(.*?)&lt;\/title&gt;/gi,              `&lt;title&gt;$&#123;                routesConfig[ctx.route].title              &#125;&lt;/title&gt;&lt;meta name=&quot;keywords&quot; content=&quot;$&#123;                routesConfig[ctx.route].keywords              &#125;&quot; /&gt;&lt;meta name=&quot;description&quot; content=&quot;$&#123;                routesConfig[ctx.route].description              &#125;&quot; /&gt;`            );            if (ctx.route.endsWith(&quot;.html&quot;)) &#123;              ctx.outputPath = path.join(__dirname, &quot;dist&quot;, ctx.route);            &#125;            return ctx;          &#125;,          minify: &#123;            collapseBooleanAttributes: true,            collapseWhitespace: true,            decodeEntities: true,            keepClosingSlash: true,            sortAttributes: true          &#125;,          renderer: new PrerenderSpaPlugin.PuppeteerRenderer(&#123;            // 需要注入一个值，这样就可以检测页面当前是否是预渲染的            inject: &#123;&#125;,            headless: false,            // 视图组件是在API请求获取所有必要数据后呈现的，因此我们在dom中存在“data view”属性后创建页面快照            renderAfterDocumentEvent: &quot;render-event&quot;          &#125;)        &#125;)      );    &#125;    config.plugins = [...config.plugins, ...plugins];  &#125;&#125;;</code></pre><p><a href="#top">▲ 回顶部</a></p><h3 id="✅-添加-IE-兼容"><a href="#✅-添加-IE-兼容" class="headerlink" title="✅ 添加 IE 兼容"></a><span id="ie">✅ 添加 IE 兼容</span></h3><p>&emsp;&emsp;在 main.js 中添加</p><pre><code class="javascript">import &#39;core-js/stable&#39;; import &#39;regenerator-runtime/runtime&#39;;</code></pre><p>配置 babel.config.js</p><pre><code class="javascript">const plugins = [];module.exports = &#123;  presets: [[&quot;@vue/app&quot;, &#123; useBuiltIns: &quot;entry&quot; &#125;]],  plugins: plugins&#125;;</code></pre><p><a href="#top">▲ 回顶部</a></p><h3 id="✅-静态资源自动打包上传阿里-oss、华为-obs"><a href="#✅-静态资源自动打包上传阿里-oss、华为-obs" class="headerlink" title="✅ 静态资源自动打包上传阿里 oss、华为 obs"></a><span id="alioss">✅ 静态资源自动打包上传阿里 oss、华为 obs</span></h3><p>&emsp;&emsp;开启文件上传 ali oss，需要将 publicPath 改成 ali oss 资源 url 前缀,也就是修改 VUE_APP_PUBLIC_PATH。具体配置参见<a href="https://github.com/staven630/webpack-oss">阿里 oss 插件 webpack-oss</a>、<a href="https://github.com/staven630/huawei-obs-plugin">华为 obs 插件 huawei-obs-plugin</a></p><pre><code class="bash">npm i -D webpack-oss</code></pre><pre><code class="javascript">const AliOssPlugin = require(&quot;webpack-oss&quot;);const IS_PROD = [&quot;production&quot;, &quot;prod&quot;].includes(process.env.NODE_ENV);const format = AliOssPlugin.getFormat();module.exports = &#123;  publicPath: IS_PROD ? `$&#123;process.env.VUE_APP_PUBLIC_PATH&#125;/$&#123;format&#125;` : &quot;./&quot;, // 默认&#39;/&#39;，部署应用包时的基本 URL  configureWebpack: config =&gt; &#123;    const plugins = [];    if (IS_PROD) &#123;      plugins.push(        new AliOssPlugin(&#123;          accessKeyId: process.env.ACCESS_KEY_ID,          accessKeySecret: process.env.ACCESS_KEY_SECRET,          region: process.env.REGION,          bucket: process.env.BUCKET,          prefix: process.env.PREFIX,          exclude: /.*\.html$/,          format        &#125;)      );    &#125;    config.plugins = [...config.plugins, ...plugins];  &#125;&#125;;</code></pre><p><a href="#top">▲ 回顶部</a></p><h3 id="✅-完整配置"><a href="#✅-完整配置" class="headerlink" title="✅ 完整配置"></a><span id="allconfig">✅ 完整配置</span></h3><pre><code class="javascript">const SpritesmithPlugin = require(&quot;webpack-spritesmith&quot;);const BundleAnalyzerPlugin = require(&quot;webpack-bundle-analyzer&quot;)  .BundleAnalyzerPlugin;const webpack = require(&quot;webpack&quot;);const path = require(&quot;path&quot;);const fs = require(&quot;fs&quot;);const resolve = dir =&gt; path.join(__dirname, dir);const IS_PROD = [&quot;production&quot;, &quot;prod&quot;].includes(process.env.NODE_ENV);const glob = require(&#39;glob&#39;)const pagesInfo = require(&#39;./pages.config&#39;)const pages = &#123;&#125;glob.sync(&#39;./src/pages/**/main.js&#39;).forEach(entry =&gt; &#123;  let chunk = entry.match(/\.\/src\/pages\/(.*)\/main\.js/)[1];  const curr = pagesInfo[chunk];  if (curr) &#123;    pages[chunk] = &#123;      entry,      ...curr,      chunk: [&quot;chunk-vendors&quot;, &quot;chunk-common&quot;, chunk]    &#125;  &#125;&#125;)let has_sprite = true;let files = [];const icons = &#123;&#125;;try &#123;  fs.statSync(resolve(&quot;./src/assets/icons&quot;));  files = fs.readdirSync(resolve(&quot;./src/assets/icons&quot;));  files.forEach(item =&gt; &#123;    let filename = item.toLocaleLowerCase().replace(/_/g, &quot;-&quot;);    icons[filename] = true;  &#125;);&#125; catch (error) &#123;  fs.mkdirSync(resolve(&quot;./src/assets/icons&quot;));&#125;if (!files.length) &#123;  has_sprite = false;&#125; else &#123;  try &#123;    let iconsObj = fs.readFileSync(resolve(&quot;./icons.json&quot;), &quot;utf8&quot;);    iconsObj = JSON.parse(iconsObj);    has_sprite = files.some(item =&gt; &#123;      let filename = item.toLocaleLowerCase().replace(/_/g, &quot;-&quot;);      return !iconsObj[filename];    &#125;);    if (has_sprite) &#123;      fs.writeFileSync(resolve(&quot;./icons.json&quot;), JSON.stringify(icons, null, 2));    &#125;  &#125; catch (error) &#123;    fs.writeFileSync(resolve(&quot;./icons.json&quot;), JSON.stringify(icons, null, 2));    has_sprite = true;  &#125;&#125;// 雪碧图样式处理模板const SpritesmithTemplate = function (data) &#123;  // pc  let icons = &#123;&#125;  let tpl = `.ico &#123;   display: inline-block;   background-image: url($&#123;data.sprites[0].image&#125;);   background-size: $&#123;data.spritesheet.width&#125;px $&#123;data.spritesheet.height&#125;px; &#125;`  data.sprites.forEach(sprite =&gt; &#123;    const name = &#39;&#39; + sprite.name.toLocaleLowerCase().replace(/_/g, &#39;-&#39;)    icons[`$&#123;name&#125;.png`] = true    tpl = `$&#123;tpl&#125; .ico-$&#123;name&#125;&#123;  width: $&#123;sprite.width&#125;px;   height: $&#123;sprite.height&#125;px;   background-position: $&#123;sprite.offset_x&#125;px $&#123;sprite.offset_y&#125;px;&#125;`  &#125;)  return tpl&#125;module.exports = &#123;  publicPath: IS_PROD ? process.env.VUE_APP_PUBLIC_PATH : &quot;./&quot;, // 默认&#39;/&#39;，部署应用包时的基本 URL  // outputDir: process.env.outputDir || &#39;dist&#39;, // &#39;dist&#39;, 生产环境构建文件的目录  // assetsDir: &quot;&quot;, // 相对于outputDir的静态资源(js、css、img、fonts)目录  configureWebpack: config =&gt; &#123;    const plugins = [];    if (has_sprite) &#123;      // 生成雪碧图      plugins.push(        new SpritesmithPlugin(&#123;          src: &#123;            cwd: path.resolve(__dirname, &#39;./src/assets/icons/&#39;), // 图标根路径            glob: &#39;**/*.png&#39; // 匹配任意 png 图标          &#125;,          target: &#123;            image: path.resolve(__dirname, &#39;./src/assets/images/sprites.png&#39;), // 生成雪碧图目标路径与名称            // 设置生成CSS背景及其定位的文件或方式            css: [              [                path.resolve(__dirname, &#39;./src/assets/scss/sprites.scss&#39;),                &#123;                  format: &#39;function_based_template&#39;                &#125;              ]            ]          &#125;,          customTemplates: &#123;            function_based_template: SpritesmithTemplate          &#125;,          apiOptions: &#123;            cssImageRef: &#39;../images/sprites.png&#39; // css文件中引用雪碧图的相对位置路径配置          &#125;,          spritesmithOptions: &#123;            padding: 2          &#125;        &#125;)      )    &#125;    config.externals = &#123;      vue: &quot;Vue&quot;,      &quot;element-ui&quot;: &quot;ELEMENT&quot;,      &quot;vue-router&quot;: &quot;VueRouter&quot;,      vuex: &quot;Vuex&quot;,      axios: &quot;axios&quot;    &#125;;    config.plugins = [...config.plugins, ...plugins];  &#125;,  chainWebpack: config =&gt; &#123;    // 修复HMR    config.resolve.symlinks(true);    // config.plugins.delete(&#39;preload&#39;);    // config.plugins.delete(&#39;prefetch&#39;);    config      .plugin(&quot;ignore&quot;)      .use(        new webpack.ContextReplacementPlugin(/moment[/\\]locale$/, /zh-cn$/)      );    // 添加别名    config.resolve.alias      .set(&quot;vue$&quot;, &quot;vue/dist/vue.esm.js&quot;)      .set(&quot;@&quot;, resolve(&quot;src&quot;))      .set(&quot;@apis&quot;, resolve(&quot;src/apis&quot;))      .set(&quot;@assets&quot;, resolve(&quot;src/assets&quot;))      .set(&quot;@scss&quot;, resolve(&quot;src/assets/scss&quot;))      .set(&quot;@components&quot;, resolve(&quot;src/components&quot;))      .set(&quot;@middlewares&quot;, resolve(&quot;src/middlewares&quot;))      .set(&quot;@mixins&quot;, resolve(&quot;src/mixins&quot;))      .set(&quot;@plugins&quot;, resolve(&quot;src/plugins&quot;))      .set(&quot;@router&quot;, resolve(&quot;src/router&quot;))      .set(&quot;@store&quot;, resolve(&quot;src/store&quot;))      .set(&quot;@utils&quot;, resolve(&quot;src/utils&quot;))      .set(&quot;@views&quot;, resolve(&quot;src/views&quot;))      .set(&quot;@layouts&quot;, resolve(&quot;src/layouts&quot;));    const cdn = &#123;      // 访问https://unpkg.com/element-ui/lib/theme-chalk/index.css获取最新版本      css: [&quot;//unpkg.com/element-ui@2.10.1/lib/theme-chalk/index.css&quot;],      js: [        &quot;//unpkg.com/vue@2.6.10/dist/vue.min.js&quot;, // 访问https://unpkg.com/vue/dist/vue.min.js获取最新版本        &quot;//unpkg.com/vue-router@3.0.6/dist/vue-router.min.js&quot;,        &quot;//unpkg.com/vuex@3.1.1/dist/vuex.min.js&quot;,        &quot;//unpkg.com/axios@0.19.0/dist/axios.min.js&quot;,        &quot;//unpkg.com/element-ui@2.10.1/lib/index.js&quot;      ]    &#125;;    // 如果使用多页面打包，使用vue inspect --plugins查看html是否在结果数组中    // config.plugin(&quot;html&quot;).tap(args =&gt; &#123;    //   // html中添加cdn    //   args[0].cdn = cdn;    //   // 修复 Lazy loading routes Error    //   args[0].chunksSortMode = &quot;none&quot;;    //   return args;    // &#125;);    // 防止多页面打包卡顿    config =&gt; config.plugins.delete(&#39;named-chunks&#39;)    // 多页面cdn添加    Object.keys(pagesInfo).forEach(page =&gt; &#123;      config.plugin(`html-$&#123;page&#125;`).tap(args =&gt; &#123;        // html中添加cdn        args[0].cdn = cdn;        // 修复 Lazy loading routes Error        args[0].chunksSortMode = &quot;none&quot;;        return args;      &#125;);    &#125;)    if (IS_PROD) &#123;      // 压缩图片      config.module        .rule(&quot;images&quot;)        .test(/\.(png|jpe?g|gif|svg)(\?.*)?$/)        .use(&quot;image-webpack-loader&quot;)        .loader(&quot;image-webpack-loader&quot;)        .options(&#123;          mozjpeg: &#123; progressive: true, quality: 65 &#125;,          optipng: &#123; enabled: false &#125;,          pngquant: &#123; quality: [0.65, 0.90], speed: 4 &#125;,          gifsicle: &#123; interlaced: false &#125;        &#125;);      // 打包分析      config.plugin(&quot;webpack-report&quot;).use(BundleAnalyzerPlugin, [        &#123;          analyzerMode: &quot;static&quot;        &#125;      ]);    &#125;    // 使用svg组件    const svgRule = config.module.rule(&quot;svg&quot;);    svgRule.uses.clear();    svgRule.exclude.add(/node_modules/);    svgRule      .test(/\.svg$/)      .use(&quot;svg-sprite-loader&quot;)      .loader(&quot;svg-sprite-loader&quot;)      .options(&#123;        symbolId: &quot;icon-[name]&quot;      &#125;);    const imagesRule = config.module.rule(&quot;images&quot;);    imagesRule.exclude.add(resolve(&quot;src/icons&quot;));    config.module.rule(&quot;images&quot;).test(/\.(png|jpe?g|gif|svg)(\?.*)?$/);    return config;  &#125;,  pages,  css: &#123;    extract: IS_PROD,    sourceMap: false,    loaderOptions: &#123;      scss: &#123;        // 向全局sass样式传入共享的全局变量, $src可以配置图片cdn前缀        // 详情: https://cli.vuejs.org/guide/css.html#passing-options-to-pre-processor-loaders        prependData: `          @import &quot;@scss/variables.scss&quot;;          @import &quot;@scss/mixins.scss&quot;;          @import &quot;@scss/function.scss&quot;;          $src: &quot;$&#123;process.env.VUE_APP_BASE_API&#125;&quot;;          `      &#125;    &#125;  &#125;,  lintOnSave: false,  runtimeCompiler: true, // 是否使用包含运行时编译器的 Vue 构建版本  productionSourceMap: !IS_PROD, // 生产环境的 source map  parallel: require(&quot;os&quot;).cpus().length &gt; 1,  pwa: &#123;&#125;,  devServer: &#123;    // overlay: &#123; // 让浏览器 overlay 同时显示警告和错误    //   warnings: true,    //   errors: true    // &#125;,    // open: false, // 是否打开浏览器    // host: &quot;localhost&quot;,    // port: &quot;8080&quot;, // 代理断就    // https: false,    // hotOnly: false, // 热更新    proxy: &#123;      &quot;/api&quot;: &#123;        target:          &quot;https://www.easy-mock.com/mock/5bc75b55dc36971c160cad1b/sheets&quot;, // 目标代理接口地址        secure: false,        changeOrigin: true, // 开启代理，在本地创建一个虚拟服务端        // ws: true, // 是否启用websockets        pathRewrite: &#123;          &quot;^/api&quot;: &quot;/&quot;        &#125;      &#125;    &#125;  &#125;&#125;;</code></pre><hr><p>文章来源:<a href="https://github.com/staven630/vue-cli4-config">github文章:vue-cli4 全面配置</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 工具 </tag>
            
            <tag> vue </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-常用的js工具函数</title>
      <link href="/2021/04/08/%E5%89%8D%E7%AB%AF/JavaScript/js-%E5%B8%B8%E7%94%A8%E7%9A%84js%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/"/>
      <url>/2021/04/08/%E5%89%8D%E7%AB%AF/JavaScript/js-%E5%B8%B8%E7%94%A8%E7%9A%84js%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>整理一下前端开发中常用的工具方法，有了这些工具函数就可以高效的处理任务和信息了。</p><span id="more"></span><h4 id="1-邮箱"><a href="#1-邮箱" class="headerlink" title="1.邮箱"></a>1.邮箱</h4><pre><code class="javascript">export const isEmail = (s) =&gt; &#123;    return /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]&#123;2,3&#125;)&#123;1,2&#125;)$/.test(s)&#125;</code></pre><h4 id="2-手机号码"><a href="#2-手机号码" class="headerlink" title="2.手机号码"></a>2.手机号码</h4><pre><code class="javascript">export const isMobile = (s) =&gt; &#123;    return /^1[0-9]&#123;10&#125;$/.test(s)&#125;</code></pre><h4 id="3-电话号码"><a href="#3-电话号码" class="headerlink" title="3.电话号码"></a>3.电话号码</h4><pre><code class="javascript">export const isPhone = (s) =&gt; &#123;    return /^([0-9]&#123;3,4&#125;-)?[0-9]&#123;7,8&#125;$/.test(s)&#125;</code></pre><h4 id="4-是否为url地址"><a href="#4-是否为url地址" class="headerlink" title="4.是否为url地址"></a>4.是否为url地址</h4><pre><code class="javascript">export const isURL = (s) =&gt; &#123;    return /^http[s]?:\/\/.*/.test(s)&#125;</code></pre><h4 id="5-是否字符串"><a href="#5-是否字符串" class="headerlink" title="5.是否字符串"></a>5.是否字符串</h4><pre><code class="javascript">export const isString = (o) =&gt; &#123;    return Object.prototype.toString.call(o).slice(8, -1) === &#39;String&#39;&#125;</code></pre><h4 id="6-是否数字"><a href="#6-是否数字" class="headerlink" title="6.是否数字"></a>6.是否数字</h4><pre><code class="javascript">export const isNumber = (o) =&gt; &#123;    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Number&#39;&#125;</code></pre><h4 id="7-是否为boolean"><a href="#7-是否为boolean" class="headerlink" title="7.是否为boolean"></a>7.是否为boolean</h4><pre><code class="javascript">export const isBoolean = (o) =&gt; &#123;    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Boolean&#39;&#125;</code></pre><h4 id="8-是否为函数"><a href="#8-是否为函数" class="headerlink" title="8.是否为函数"></a>8.是否为函数</h4><pre><code class="javascript">export const isFunction = (o) =&gt; &#123;    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Function&#39;&#125;</code></pre><h4 id="9-是否为null"><a href="#9-是否为null" class="headerlink" title="9.是否为null"></a>9.是否为null</h4><pre><code class="javascript">export const isNull = (o) =&gt; &#123;    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Null&#39;&#125;</code></pre><h4 id="10-是否为undefined"><a href="#10-是否为undefined" class="headerlink" title="10.是否为undefined"></a>10.是否为undefined</h4><pre><code class="javascript">export const isUndefined = (o) =&gt; &#123;    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Undefined&#39;&#125;</code></pre><h4 id="11-是否为对象"><a href="#11-是否为对象" class="headerlink" title="11.是否为对象"></a>11.是否为对象</h4><pre><code class="javascript">export const isObj = (o) =&gt; &#123;    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Object&#39;&#125;</code></pre><h4 id="12-是否为数组"><a href="#12-是否为数组" class="headerlink" title="12.是否为数组"></a>12.是否为数组</h4><pre><code class="javascript">export const isArray = (o) =&gt; &#123;    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Array&#39;&#125;</code></pre><h4 id="13-是否为时间"><a href="#13-是否为时间" class="headerlink" title="13.是否为时间"></a>13.是否为时间</h4><pre><code class="javascript">export const isDate = (o) =&gt; &#123;    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Date&#39;&#125;</code></pre><h4 id="14-是否为正则"><a href="#14-是否为正则" class="headerlink" title="14.是否为正则"></a>14.是否为正则</h4><pre><code class="javascript">export const isRegExp = (o) =&gt; &#123;    return Object.prototype.toString.call(o).slice(8, -1) === &#39;RegExp&#39;&#125;</code></pre><h4 id="15-是否为错误对象"><a href="#15-是否为错误对象" class="headerlink" title="15.是否为错误对象"></a>15.是否为错误对象</h4><pre><code class="javascript">export const isError = (o) =&gt; &#123;    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Error&#39;&#125;</code></pre><h4 id="16-是否为Symbol函数"><a href="#16-是否为Symbol函数" class="headerlink" title="16.是否为Symbol函数"></a>16.是否为Symbol函数</h4><pre><code class="javascript">export const isSymbol = (o) =&gt; &#123;    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Symbol&#39;&#125;</code></pre><h4 id="17-是否为Promise对象"><a href="#17-是否为Promise对象" class="headerlink" title="17.是否为Promise对象"></a>17.是否为Promise对象</h4><pre><code class="javascript">export const isPromise = (o) =&gt; &#123;    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Promise&#39;&#125;</code></pre><h4 id="18-是否为Set对象"><a href="#18-是否为Set对象" class="headerlink" title="18.是否为Set对象"></a>18.是否为Set对象</h4><pre><code class="javascript">export const isSet = (o) =&gt; &#123;        return Object.prototype.toString.call(o).slice(8, -1) === &#39;Set&#39; &#125; </code></pre><h4 id="19-是否是微信浏览器"><a href="#19-是否是微信浏览器" class="headerlink" title="19.是否是微信浏览器"></a>19.是否是微信浏览器</h4><pre><code class="javascript">export const isWeiXin = () =&gt; &#123;    return (navigator.userAgent.toLowerCase()).match(/microMessenger/i) == &#39;micromessenger&#39;&#125;</code></pre><h4 id="20-是否为移动端"><a href="#20-是否为移动端" class="headerlink" title="20.是否为移动端"></a>20.是否为移动端</h4><pre><code class="javascript">export const isDeviceMobile = () =&gt; &#123;    return /android|webos|iphone|ipod|balckberry/i.test(ua)&#125;</code></pre><h4 id="21-是否是QQ浏览器"><a href="#21-是否是QQ浏览器" class="headerlink" title="21.是否是QQ浏览器"></a>21.是否是QQ浏览器</h4><pre><code class="javascript">export const isQQBrowser = () =&gt; &#123;    return !!ua.match(/mqqbrowser|qzone|qqbrowser|qbwebviewtype/i)&#125;</code></pre><h4 id="22-是否为ios"><a href="#22-是否为ios" class="headerlink" title="22.是否为ios"></a>22.是否为ios</h4><pre><code class="javascript">export const isIos = () =&gt; &#123;  var u = navigator.userAgent;  if (u.indexOf(&#39;Android&#39;) &gt; -1 || u.indexOf(&#39;Linux&#39;) &gt; -1) &#123;      // 安卓手机    return false  &#125; else if (u.indexOf(&#39;iPhone&#39;) &gt; -1) &#123;    // 苹果手机    return true  &#125; else if (u.indexOf(&#39;iPad&#39;) &gt; -1) &#123;     // iPad    return false  &#125; else if (u.indexOf(&#39;Windows Phone&#39;) &gt; -1) &#123;    //winphone手机    return false  &#125; else &#123;    return false  &#125;&#125;</code></pre><h4 id="23-是否为PC端"><a href="#23-是否为PC端" class="headerlink" title="23.是否为PC端"></a>23.是否为PC端</h4><pre><code class="javascript">export const isPC = () =&gt; &#123;  var userAgentInfo = navigator.userAgent;  var Agents = [&quot;Android&quot;, &quot;iPhone&quot;,    &quot;SymbianOS&quot;, &quot;Windows Phone&quot;,    &quot;iPad&quot;, &quot;iPod&quot;];  var flag = true;  for (var v = 0; v &lt; Agents.length; v++) &#123;    if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123;      flag = false;      break;    &#125;  &#125;  return flag;&#125;</code></pre><h4 id="24-去除html标签"><a href="#24-去除html标签" class="headerlink" title="24.去除html标签"></a>24.去除html标签</h4><pre><code class="javascript">export const removeHtmltag = (str) =&gt; &#123;    return str.replace(/&lt;[^&gt;]+&gt;/g, &#39;&#39;)&#125;</code></pre><h4 id="25-获取url参数"><a href="#25-获取url参数" class="headerlink" title="25.获取url参数"></a>25.获取url参数</h4><pre><code class="javascript">export const getQueryString = (name) =&gt; &#123;  const reg = new RegExp(&#39;(^|&amp;)&#39; + name + &#39;=([^&amp;]*)(&amp;|$)&#39;, &#39;i&#39;);  const search = window.location.search.split(&#39;?&#39;)[1] || &#39;&#39;;  const r = search.match(reg) || [];  return r[2];&#125;</code></pre><h4 id="26-动态引入js"><a href="#26-动态引入js" class="headerlink" title="26.动态引入js"></a>26.动态引入js</h4><pre><code class="javascript">export const injectScript = (src) =&gt; &#123;  const s = document.createElement(&#39;script&#39;);  s.type = &#39;text/javascript&#39;;  s.async = true;  s.src = src;  const t = document.getElementsByTagName(&#39;script&#39;)[0];  t.parentNode.insertBefore(s, t);&#125;</code></pre><h4 id="27-根据url地址下载"><a href="#27-根据url地址下载" class="headerlink" title="27.根据url地址下载"></a>27.根据url地址下载</h4><pre><code class="javascript">export const download = (url) =&gt; &#123;  var isChrome = navigator.userAgent.toLowerCase().indexOf(&#39;chrome&#39;) &gt; -1;  var isSafari = navigator.userAgent.toLowerCase().indexOf(&#39;safari&#39;) &gt; -1;  if (isChrome || isSafari) &#123;    var link = document.createElement(&#39;a&#39;);    link.href = url;    if (link.download !== undefined) &#123;      var fileName = url.substring(url.lastIndexOf(&#39;/&#39;) + 1, url.length);      link.download = fileName;    &#125;    if (document.createEvent) &#123;      var e = document.createEvent(&#39;MouseEvents&#39;);      e.initEvent(&#39;click&#39;, true, true);      link.dispatchEvent(e);      return true;    &#125;  &#125;  if (url.indexOf(&#39;?&#39;) === -1) &#123;    url += &#39;?download&#39;;  &#125;  window.open(url, &#39;_self&#39;);  return true;&#125;</code></pre><h4 id="28-el是否包含某个class"><a href="#28-el是否包含某个class" class="headerlink" title="28.el是否包含某个class"></a>28.el是否包含某个class</h4><pre><code class="javascript">export const hasClass = (el, className) =&gt; &#123;  let reg = new RegExp(&#39;(^|\\s)&#39; + className + &#39;(\\s|$)&#39;)  return reg.test(el.className)&#125;</code></pre><h4 id="29-el添加某个class"><a href="#29-el添加某个class" class="headerlink" title="29.el添加某个class"></a>29.el添加某个class</h4><pre><code class="javascript">export const addClass = (el, className) =&gt; &#123;  if (hasClass(el, className)) &#123;    return  &#125;  let newClass = el.className.split(&#39; &#39;)  newClass.push(className)  el.className = newClass.join(&#39; &#39;)&#125;</code></pre><h4 id="30-el去除某个class"><a href="#30-el去除某个class" class="headerlink" title="30.el去除某个class"></a>30.el去除某个class</h4><pre><code class="javascript">export const removeClass = (el, className) =&gt; &#123;  if (!hasClass(el, className)) &#123;    return  &#125;  let reg = new RegExp(&#39;(^|\\s)&#39; + className + &#39;(\\s|$)&#39;, &#39;g&#39;)  el.className = el.className.replace(reg, &#39; &#39;)&#125;</code></pre><h4 id="31-获取滚动的坐标"><a href="#31-获取滚动的坐标" class="headerlink" title="31.获取滚动的坐标"></a>31.获取滚动的坐标</h4><pre><code class="javascript">export const getScrollPosition = (el = window) =&gt; (&#123;  x: el.pageXOffset !== undefined ? el.pageXOffset : el.scrollLeft,  y: el.pageYOffset !== undefined ? el.pageYOffset : el.scrollTop&#125;);</code></pre><h4 id="32-滚动到顶部"><a href="#32-滚动到顶部" class="headerlink" title="32.滚动到顶部"></a>32.滚动到顶部</h4><pre><code class="javascript">export const scrollToTop = () =&gt; &#123;  const c = document.documentElement.scrollTop || document.body.scrollTop;  if (c &gt; 0) &#123;    window.requestAnimationFrame(scrollToTop);    window.scrollTo(0, c - c / 8);  &#125;&#125;</code></pre><h4 id="33-el是否在视口范围内"><a href="#33-el是否在视口范围内" class="headerlink" title="33.el是否在视口范围内"></a>33.el是否在视口范围内</h4><pre><code class="javascript">export const elementIsVisibleInViewport = (el, partiallyVisible = false) =&gt; &#123;  const &#123; top, left, bottom, right &#125; = el.getBoundingClientRect();  const &#123; innerHeight, innerWidth &#125; = window;  return partiallyVisible    ? ((top &gt; 0 &amp;&amp; top &lt; innerHeight) || (bottom &gt; 0 &amp;&amp; bottom &lt; innerHeight)) &amp;&amp;    ((left &gt; 0 &amp;&amp; left &lt; innerWidth) || (right &gt; 0 &amp;&amp; right &lt; innerWidth))    : top &gt;= 0 &amp;&amp; left &gt;= 0 &amp;&amp; bottom &lt;= innerHeight &amp;&amp; right &lt;= innerWidth;&#125;</code></pre><h4 id="34-洗牌算法随机"><a href="#34-洗牌算法随机" class="headerlink" title="34.洗牌算法随机"></a>34.洗牌算法随机</h4><pre><code class="javascript">export const shuffle = (arr) =&gt; &#123;  var result = [],    random;  while (arr.length &gt; 0) &#123;    random = Math.floor(Math.random() * arr.length);    result.push(arr[random])    arr.splice(random, 1)  &#125;  return result;&#125;</code></pre><h4 id="35-劫持粘贴板"><a href="#35-劫持粘贴板" class="headerlink" title="35.劫持粘贴板"></a>35.劫持粘贴板</h4><pre><code class="javascript">export const copyTextToClipboard = (value) =&gt; &#123;  var textArea = document.createElement(&quot;textarea&quot;);  textArea.style.background = &#39;transparent&#39;;  textArea.value = value;  document.body.appendChild(textArea);  textArea.select();  try &#123;    var successful = document.execCommand(&#39;copy&#39;);  &#125; catch (err) &#123;    console.log(&#39;Oops, unable to copy&#39;);  &#125;  document.body.removeChild(textArea);&#125;</code></pre><h4 id="36-判断类型集合"><a href="#36-判断类型集合" class="headerlink" title="36.判断类型集合"></a>36.判断类型集合</h4><pre><code class="javascript">export const checkStr = (str, type) =&gt; &#123;  switch (type) &#123;    case &#39;phone&#39;:   //手机号码      return /^1[3|4|5|6|7|8|9][0-9]&#123;9&#125;$/.test(str);    case &#39;tel&#39;:     //座机      return /^(0\d&#123;2,3&#125;-\d&#123;7,8&#125;)(-\d&#123;1,4&#125;)?$/.test(str);    case &#39;card&#39;:    //身份证      return /(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/.test(str);    case &#39;pwd&#39;:     //密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线      return /^[a-zA-Z]\w&#123;5,17&#125;$/.test(str)    case &#39;postal&#39;:  //邮政编码      return /[1-9]\d&#123;5&#125;(?!\d)/.test(str);    case &#39;QQ&#39;:      //QQ号      return /^[1-9][0-9]&#123;4,9&#125;$/.test(str);    case &#39;email&#39;:   //邮箱      return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str);    case &#39;money&#39;:   //金额(小数点2位)      return /^\d*(?:\.\d&#123;0,2&#125;)?$/.test(str);    case &#39;URL&#39;:     //网址      return /(http|ftp|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^=%&amp;:/~\+#]*[\w\-\@?^=%&amp;/~\+#])?/.test(str)    case &#39;IP&#39;:      //IP      return /((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))/.test(str);    case &#39;date&#39;:    //日期时间      return /^(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;) (\d&#123;2&#125;)(?:\:\d&#123;2&#125;|:(\d&#123;2&#125;):(\d&#123;2&#125;))$/.test(str) || /^(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;)$/.test(str)    case &#39;number&#39;:  //数字      return /^[0-9]$/.test(str);    case &#39;english&#39;: //英文      return /^[a-zA-Z]+$/.test(str);    case &#39;chinese&#39;: //中文      return /^[\\u4E00-\\u9FA5]+$/.test(str);    case &#39;lower&#39;:   //小写      return /^[a-z]+$/.test(str);    case &#39;upper&#39;:   //大写      return /^[A-Z]+$/.test(str);    case &#39;HTML&#39;:    //HTML标记      return /&lt;(&quot;[^&quot;]*&quot;|&#39;[^&#39;]*&#39;|[^&#39;&quot;&gt;])*&gt;/.test(str);    default:      return true;  &#125;&#125;</code></pre><h4 id="37-严格的身份证校验"><a href="#37-严格的身份证校验" class="headerlink" title="37.严格的身份证校验"></a>37.严格的身份证校验</h4><pre><code class="javascript">export const isCardID = (sId) =&gt; &#123;  if (!/(^\d&#123;15&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/.test(sId)) &#123;    console.log(&#39;你输入的身份证长度或格式错误&#39;)    return false  &#125;  //身份证城市  var aCity = &#123; 11: &quot;北京&quot;, 12: &quot;天津&quot;, 13: &quot;河北&quot;, 14: &quot;山西&quot;, 15: &quot;内蒙古&quot;, 21: &quot;辽宁&quot;, 22: &quot;吉林&quot;, 23: &quot;黑龙江&quot;, 31: &quot;上海&quot;, 32: &quot;江苏&quot;, 33: &quot;浙江&quot;, 34: &quot;安徽&quot;, 35: &quot;福建&quot;, 36: &quot;江西&quot;, 37: &quot;山东&quot;, 41: &quot;河南&quot;, 42: &quot;湖北&quot;, 43: &quot;湖南&quot;, 44: &quot;广东&quot;, 45: &quot;广西&quot;, 46: &quot;海南&quot;, 50: &quot;重庆&quot;, 51: &quot;四川&quot;, 52: &quot;贵州&quot;, 53: &quot;云南&quot;, 54: &quot;西藏&quot;, 61: &quot;陕西&quot;, 62: &quot;甘肃&quot;, 63: &quot;青海&quot;, 64: &quot;宁夏&quot;, 65: &quot;新疆&quot;, 71: &quot;台湾&quot;, 81: &quot;香港&quot;, 82: &quot;澳门&quot;, 91: &quot;国外&quot; &#125;;  if (!aCity[parseInt(sId.substr(0, 2))]) &#123;    console.log(&#39;你的身份证地区非法&#39;)    return false  &#125;  // 出生日期验证  var sBirthday = (sId.substr(6, 4) + &quot;-&quot; + Number(sId.substr(10, 2)) + &quot;-&quot; + Number(sId.substr(12, 2))).replace(/-/g, &quot;/&quot;),    d = new Date(sBirthday)  if (sBirthday != (d.getFullYear() + &quot;/&quot; + (d.getMonth() + 1) + &quot;/&quot; + d.getDate())) &#123;    console.log(&#39;身份证上的出生日期非法&#39;)    return false  &#125;  // 身份证号码校验  var sum = 0,    weights = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2],    codes = &quot;10X98765432&quot;  for (var i = 0; i &lt; sId.length - 1; i++) &#123;    sum += sId[i] * weights[i];  &#125;  var last = codes[sum % 11]; //计算出来的最后一位身份证号码  if (sId[sId.length - 1] != last) &#123;    console.log(&#39;你输入的身份证号非法&#39;)    return false  &#125;  return true&#125;</code></pre><h4 id="38-随机数范围"><a href="#38-随机数范围" class="headerlink" title="38.随机数范围"></a>38.随机数范围</h4><pre><code class="javascript">export const random = (min, max) =&gt; &#123;  if (arguments.length === 2) &#123;    return Math.floor(min + Math.random() * ((max + 1) - min))  &#125; else &#123;    return null;  &#125;&#125;</code></pre><h4 id="39-将阿拉伯数字翻译成中文的大写数字"><a href="#39-将阿拉伯数字翻译成中文的大写数字" class="headerlink" title="39.将阿拉伯数字翻译成中文的大写数字"></a>39.将阿拉伯数字翻译成中文的大写数字</h4><pre><code class="javascript">export const numberToChinese = (num) =&gt; &#123;  var AA = new Array(&quot;零&quot;, &quot;一&quot;, &quot;二&quot;, &quot;三&quot;, &quot;四&quot;, &quot;五&quot;, &quot;六&quot;, &quot;七&quot;, &quot;八&quot;, &quot;九&quot;, &quot;十&quot;);  var BB = new Array(&quot;&quot;, &quot;十&quot;, &quot;百&quot;, &quot;仟&quot;, &quot;萬&quot;, &quot;億&quot;, &quot;点&quot;, &quot;&quot;);  var a = (&quot;&quot; + num).replace(/(^0*)/g, &quot;&quot;).split(&quot;.&quot;),    k = 0,    re = &quot;&quot;;  for (var i = a[0].length - 1; i &gt;= 0; i--) &#123;    switch (k) &#123;      case 0:        re = BB[7] + re;        break;      case 4:        if (!new RegExp(&quot;0&#123;4&#125;//d&#123;&quot; + (a[0].length - i - 1) + &quot;&#125;$&quot;)          .test(a[0]))          re = BB[4] + re;        break;      case 8:        re = BB[5] + re;        BB[7] = BB[5];        k = 0;        break;    &#125;    if (k % 4 == 2 &amp;&amp; a[0].charAt(i + 2) != 0 &amp;&amp; a[0].charAt(i + 1) == 0)      re = AA[0] + re;    if (a[0].charAt(i) != 0)      re = AA[a[0].charAt(i)] + BB[k % 4] + re;    k++;  &#125;  if (a.length &gt; 1) // 加上小数部分(如果有小数部分)  &#123;    re += BB[6];    for (var i = 0; i &lt; a[1].length; i++)      re += AA[a[1].charAt(i)];  &#125;  if (re == &#39;一十&#39;)    re = &quot;十&quot;;  if (re.match(/^一/) &amp;&amp; re.length == 3)    re = re.replace(&quot;一&quot;, &quot;&quot;);  return re;&#125;</code></pre><h4 id="40-将数字转换为大写金额"><a href="#40-将数字转换为大写金额" class="headerlink" title="40.将数字转换为大写金额"></a>40.将数字转换为大写金额</h4><pre><code class="javascript">export const changeToChinese = (Num) =&gt; &#123;  //判断如果传递进来的不是字符的话转换为字符  if (typeof Num == &quot;number&quot;) &#123;    Num = new String(Num);  &#125;;  Num = Num.replace(/,/g, &quot;&quot;) //替换tomoney()中的“,”  Num = Num.replace(/ /g, &quot;&quot;) //替换tomoney()中的空格  Num = Num.replace(/￥/g, &quot;&quot;) //替换掉可能出现的￥字符  if (isNaN(Num)) &#123; //验证输入的字符是否为数字    //alert(&quot;请检查小写金额是否正确&quot;);    return &quot;&quot;;  &#125;;  //字符处理完毕后开始转换，采用前后两部分分别转换  var part = String(Num).split(&quot;.&quot;);  var newchar = &quot;&quot;;  //小数点前进行转化  for (var i = part[0].length - 1; i &gt;= 0; i--) &#123;    if (part[0].length &gt; 10) &#123;      return &quot;&quot;;      //若数量超过拾亿单位，提示    &#125;    var tmpnewchar = &quot;&quot;    var perchar = part[0].charAt(i);    switch (perchar) &#123;      case &quot;0&quot;:        tmpnewchar = &quot;零&quot; + tmpnewchar;        break;      case &quot;1&quot;:        tmpnewchar = &quot;壹&quot; + tmpnewchar;        break;      case &quot;2&quot;:        tmpnewchar = &quot;贰&quot; + tmpnewchar;        break;      case &quot;3&quot;:        tmpnewchar = &quot;叁&quot; + tmpnewchar;        break;      case &quot;4&quot;:        tmpnewchar = &quot;肆&quot; + tmpnewchar;        break;      case &quot;5&quot;:        tmpnewchar = &quot;伍&quot; + tmpnewchar;        break;      case &quot;6&quot;:        tmpnewchar = &quot;陆&quot; + tmpnewchar;        break;      case &quot;7&quot;:        tmpnewchar = &quot;柒&quot; + tmpnewchar;        break;      case &quot;8&quot;:        tmpnewchar = &quot;捌&quot; + tmpnewchar;        break;      case &quot;9&quot;:        tmpnewchar = &quot;玖&quot; + tmpnewchar;        break;    &#125;    switch (part[0].length - i - 1) &#123;      case 0:        tmpnewchar = tmpnewchar + &quot;元&quot;;        break;      case 1:        if (perchar != 0) tmpnewchar = tmpnewchar + &quot;拾&quot;;        break;      case 2:        if (perchar != 0) tmpnewchar = tmpnewchar + &quot;佰&quot;;        break;      case 3:        if (perchar != 0) tmpnewchar = tmpnewchar + &quot;仟&quot;;        break;      case 4:        tmpnewchar = tmpnewchar + &quot;万&quot;;        break;      case 5:        if (perchar != 0) tmpnewchar = tmpnewchar + &quot;拾&quot;;        break;      case 6:        if (perchar != 0) tmpnewchar = tmpnewchar + &quot;佰&quot;;        break;      case 7:        if (perchar != 0) tmpnewchar = tmpnewchar + &quot;仟&quot;;        break;      case 8:        tmpnewchar = tmpnewchar + &quot;亿&quot;;        break;      case 9:        tmpnewchar = tmpnewchar + &quot;拾&quot;;        break;    &#125;    var newchar = tmpnewchar + newchar;  &#125;  //小数点之后进行转化  if (Num.indexOf(&quot;.&quot;) != -1) &#123;    if (part[1].length &gt; 2) &#123;      // alert(&quot;小数点之后只能保留两位,系统将自动截断&quot;);      part[1] = part[1].substr(0, 2)    &#125;    for (i = 0; i &lt; part[1].length; i++) &#123;      tmpnewchar = &quot;&quot;      perchar = part[1].charAt(i)      switch (perchar) &#123;        case &quot;0&quot;:          tmpnewchar = &quot;零&quot; + tmpnewchar;          break;        case &quot;1&quot;:          tmpnewchar = &quot;壹&quot; + tmpnewchar;          break;        case &quot;2&quot;:          tmpnewchar = &quot;贰&quot; + tmpnewchar;          break;        case &quot;3&quot;:          tmpnewchar = &quot;叁&quot; + tmpnewchar;          break;        case &quot;4&quot;:          tmpnewchar = &quot;肆&quot; + tmpnewchar;          break;        case &quot;5&quot;:          tmpnewchar = &quot;伍&quot; + tmpnewchar;          break;        case &quot;6&quot;:          tmpnewchar = &quot;陆&quot; + tmpnewchar;          break;        case &quot;7&quot;:          tmpnewchar = &quot;柒&quot; + tmpnewchar;          break;        case &quot;8&quot;:          tmpnewchar = &quot;捌&quot; + tmpnewchar;          break;        case &quot;9&quot;:          tmpnewchar = &quot;玖&quot; + tmpnewchar;          break;      &#125;      if (i == 0) tmpnewchar = tmpnewchar + &quot;角&quot;;      if (i == 1) tmpnewchar = tmpnewchar + &quot;分&quot;;      newchar = newchar + tmpnewchar;    &#125;  &#125;  //替换所有无用汉字  while (newchar.search(&quot;零零&quot;) != -1)    newchar = newchar.replace(&quot;零零&quot;, &quot;零&quot;);  newchar = newchar.replace(&quot;零亿&quot;, &quot;亿&quot;);  newchar = newchar.replace(&quot;亿万&quot;, &quot;亿&quot;);  newchar = newchar.replace(&quot;零万&quot;, &quot;万&quot;);  newchar = newchar.replace(&quot;零元&quot;, &quot;元&quot;);  newchar = newchar.replace(&quot;零角&quot;, &quot;&quot;);  newchar = newchar.replace(&quot;零分&quot;, &quot;&quot;);  if (newchar.charAt(newchar.length - 1) == &quot;元&quot;) &#123;    newchar = newchar + &quot;整&quot;  &#125;  return newchar;&#125;</code></pre><h4 id="41-判断一个元素是否在数组中"><a href="#41-判断一个元素是否在数组中" class="headerlink" title="41.判断一个元素是否在数组中"></a>41.判断一个元素是否在数组中</h4><pre><code class="javascript">export const contains = (arr, val) =&gt; &#123;    return arr.indexOf(val) != -1 ? true : false;&#125;</code></pre><h4 id="42-数组排序-type-1：从小到大-2：从大到小-3：随机"><a href="#42-数组排序-type-1：从小到大-2：从大到小-3：随机" class="headerlink" title="42.数组排序, {type} 1：从小到大 2：从大到小 3：随机"></a>42.数组排序, {type} 1：从小到大 2：从大到小 3：随机</h4><pre><code class="javascript">export const sort = (arr, type = 1) =&gt; &#123;  return arr.sort((a, b) =&gt; &#123;    switch (type) &#123;    case 1:      return a - b;    case 2:      return b - a;    case 3:      return Math.random() - 0.5;    default:      return arr;    &#125;  &#125;)&#125;</code></pre><h4 id="43-数组去重"><a href="#43-数组去重" class="headerlink" title="43.数组去重"></a>43.数组去重</h4><pre><code class="javascript">export const unique = (arr) =&gt; &#123;  if (Array.hasOwnProperty(&#39;from&#39;)) &#123;    return Array.from(new Set(arr));  &#125; else &#123;    var n = &#123;&#125;, r = [];    for (var i = 0; i &lt; arr.length; i++) &#123;      if (!n[arr[i]]) &#123;        n[arr[i]] = true;        r.push(arr[i]);      &#125;    &#125;    return r;  &#125;&#125;</code></pre><h4 id="44-求两个集合的并集"><a href="#44-求两个集合的并集" class="headerlink" title="44.求两个集合的并集"></a>44.求两个集合的并集</h4><pre><code class="javascript">export const union = (a, b) =&gt; &#123;  var newArr = a.concat(b);  return this.unique(newArr); // 见43&#125;</code></pre><h4 id="45-求两个集合的交集"><a href="#45-求两个集合的交集" class="headerlink" title="45.求两个集合的交集"></a>45.求两个集合的交集</h4><pre><code class="javascript">export const intersect = (a, b) =&gt; &#123;  var _this = this;  a = this.unique(a);  return this.map(a, function (o) &#123;    return _this.contains(b, o) ? o : null; // contains方法见41  &#125;);&#125;</code></pre><h4 id="46-删除数组指定元素"><a href="#46-删除数组指定元素" class="headerlink" title="46.删除数组指定元素"></a>46.删除数组指定元素</h4><pre><code class="javascript">export const remove = (arr, ele) =&gt; &#123;  var index = arr.indexOf(ele);  if (index &gt; -1) &#123;    arr.splice(index, 1);  &#125;  return arr;&#125;</code></pre><h4 id="47-将类数组转换为数组"><a href="#47-将类数组转换为数组" class="headerlink" title="47.将类数组转换为数组"></a>47.将类数组转换为数组</h4><pre><code class="javascript">export const formArray = (ary) =&gt; &#123;  var arr = [];  if (Array.isArray(ary)) &#123;    arr = ary;  &#125; else &#123;    arr = Array.prototype.slice.call(ary);  &#125;;  return arr;&#125;</code></pre><h4 id="48-找出数组最大值"><a href="#48-找出数组最大值" class="headerlink" title="48.找出数组最大值"></a>48.找出数组最大值</h4><pre><code class="javascript">export const max = (arr) =&gt; &#123;  return Math.max.apply(null, arr);&#125;</code></pre><h4 id="49-找出数组最小值"><a href="#49-找出数组最小值" class="headerlink" title="49.找出数组最小值"></a>49.找出数组最小值</h4><pre><code class="javascript">export const min = (arr) =&gt; &#123;    return Math.min.apply(null, arr);&#125;</code></pre><h4 id="50-数组求和"><a href="#50-数组求和" class="headerlink" title="50.数组求和"></a>50.数组求和</h4><pre><code class="javascript">export const sum = (arr) =&gt; &#123;    return arr.reduce((pre, cur) =&gt; &#123;        return pre + cur    &#125;)&#125;</code></pre><h4 id="51-数组平均数"><a href="#51-数组平均数" class="headerlink" title="51.数组平均数"></a>51.数组平均数</h4><pre><code class="javascript">export const average = (arr) =&gt; &#123;    return this.sum(arr) / arr.length&#125;</code></pre><h4 id="52-去除空格-type-1-所有空格-2-前后空格-3-前空格-4-后空格"><a href="#52-去除空格-type-1-所有空格-2-前后空格-3-前空格-4-后空格" class="headerlink" title="52.去除空格,type: 1-所有空格 2-前后空格 3-前空格 4-后空格"></a>52.去除空格,<code>type: 1-所有空格 2-前后空格 3-前空格 4-后空格</code></h4><pre><code class="javascript">export const trim = (str, type) =&gt; &#123;  type = type || 1  switch (type) &#123;    case 1:      return str.replace(/\s+/g, &quot;&quot;);    case 2:      return str.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);    case 3:      return str.replace(/(^\s*)/g, &quot;&quot;);    case 4:      return str.replace(/(\s*$)/g, &quot;&quot;);    default:      return str;  &#125;&#125;</code></pre><h4 id="53-字符转换-type-1-首字母大写-2：首字母小写-3：大小写转换-4：全部大写-5：全部小写"><a href="#53-字符转换-type-1-首字母大写-2：首字母小写-3：大小写转换-4：全部大写-5：全部小写" class="headerlink" title="53.字符转换,type: 1:首字母大写 2：首字母小写 3：大小写转换 4：全部大写 5：全部小写"></a>53.字符转换,type: 1:首字母大写 2：首字母小写 3：大小写转换 4：全部大写 5：全部小写</h4><pre><code class="javascript">export const changeCase = (str, type) =&gt; &#123;  type = type || 4  switch (type) &#123;    case 1:      return str.replace(/\b\w+\b/g, function (word) &#123;        return word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase();      &#125;);    case 2:      return str.replace(/\b\w+\b/g, function (word) &#123;        return word.substring(0, 1).toLowerCase() + word.substring(1).toUpperCase();      &#125;);    case 3:      return str.split(&#39;&#39;).map(function (word) &#123;        if (/[a-z]/.test(word)) &#123;          return word.toUpperCase();        &#125; else &#123;          return word.toLowerCase()        &#125;      &#125;).join(&#39;&#39;)    case 4:      return str.toUpperCase();    case 5:      return str.toLowerCase();    default:      return str;  &#125;&#125;</code></pre><h4 id="54-检测密码强度"><a href="#54-检测密码强度" class="headerlink" title="54.检测密码强度"></a>54.检测密码强度</h4><pre><code class="javascript">export const checkPwd = (str) =&gt; &#123;  var Lv = 0;  if (str.length &lt; 6) &#123;    return Lv  &#125;  if (/[0-9]/.test(str)) &#123;    Lv++  &#125;  if (/[a-z]/.test(str)) &#123;    Lv++  &#125;  if (/[A-Z]/.test(str)) &#123;    Lv++  &#125;  if (/[\.|-|_]/.test(str)) &#123;    Lv++  &#125;  return Lv;&#125;</code></pre><h4 id="55-函数节流器"><a href="#55-函数节流器" class="headerlink" title="55.函数节流器"></a>55.函数节流器</h4><pre><code class="javascript">export const debouncer = (fn, time, interval = 200) =&gt; &#123;  if (time - (window.debounceTimestamp || 0) &gt; interval) &#123;    fn &amp;&amp; fn();    window.debounceTimestamp = time;  &#125;&#125;</code></pre><h4 id="56-在字符串中插入新字符串"><a href="#56-在字符串中插入新字符串" class="headerlink" title="56.在字符串中插入新字符串"></a>56.在字符串中插入新字符串</h4><pre><code class="javascript">export const insertStr = (soure, index, newStr) =&gt; &#123;  var str = soure.slice(0, index) + newStr + soure.slice(index);  return str;&#125;</code></pre><h4 id="57-判断两个对象是否键值相同"><a href="#57-判断两个对象是否键值相同" class="headerlink" title="57.判断两个对象是否键值相同"></a>57.判断两个对象是否键值相同</h4><pre><code class="javascript">export const isObjectEqual = (a, b) =&gt; &#123;  var aProps = Object.getOwnPropertyNames(a);  var bProps = Object.getOwnPropertyNames(b);  if (aProps.length !== bProps.length) &#123;    return false;  &#125;  for (var i = 0; i &lt; aProps.length; i++) &#123;    var propName = aProps[i];    if (a[propName] !== b[propName]) &#123;      return false;    &#125;  &#125;  return true;&#125;</code></pre><h4 id="58-16进制颜色转RGBRGBA字符串"><a href="#58-16进制颜色转RGBRGBA字符串" class="headerlink" title="58.16进制颜色转RGBRGBA字符串"></a>58.16进制颜色转RGBRGBA字符串</h4><pre><code class="javascript">export const colorToRGB = (val, opa) =&gt; &#123;  var pattern = /^(#?)[a-fA-F0-9]&#123;6&#125;$/; //16进制颜色值校验规则  var isOpa = typeof opa == &#39;number&#39;; //判断是否有设置不透明度  if (!pattern.test(val)) &#123; //如果值不符合规则返回空字符    return &#39;&#39;;  &#125;  var v = val.replace(/#/, &#39;&#39;); //如果有#号先去除#号  var rgbArr = [];  var rgbStr = &#39;&#39;;  for (var i = 0; i &lt; 3; i++) &#123;    var item = v.substring(i * 2, i * 2 + 2);    var num = parseInt(item, 16);    rgbArr.push(num);  &#125;  rgbStr = rgbArr.join();  rgbStr = &#39;rgb&#39; + (isOpa ? &#39;a&#39; : &#39;&#39;) + &#39;(&#39; + rgbStr + (isOpa ? &#39;,&#39; + opa : &#39;&#39;) + &#39;)&#39;;  return rgbStr;&#125;</code></pre><h4 id="59-追加url参数"><a href="#59-追加url参数" class="headerlink" title="59.追加url参数"></a>59.追加url参数</h4><pre><code class="javascript">export const appendQuery = (url, key, value) =&gt; &#123;  var options = key;  if (typeof options == &#39;string&#39;) &#123;    options = &#123;&#125;;    options[key] = value;  &#125;  options = $.param(options);  if (url.includes(&#39;?&#39;)) &#123;    url += &#39;&amp;&#39; + options  &#125; else &#123;    url += &#39;?&#39; + options  &#125;  return url;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git-tortoiseGit版本库管理客户端</title>
      <link href="/2021/03/24/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/git-tortoisegit%E7%89%88%E6%9C%AC%E5%BA%93%E7%AE%A1%E7%90%86%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>/2021/03/24/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/git-tortoisegit%E7%89%88%E6%9C%AC%E5%BA%93%E7%AE%A1%E7%90%86%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>TortoiseGit 简称 tgit, 中文名海龟Git, 有一个前辈海龟SVN, TortoiseSVN和TortoiseGit都是非常优秀的开源的版本库客户端. 分为32位版与64位版.并且支持各种语言,包括简体中文(Chinese, simplified; zh_CN).</p><span id="more"></span><h2 id="下载git"><a href="#下载git" class="headerlink" title="下载git"></a>下载git</h2><p>git官网下载:<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p><h2 id="下载tortoisegit"><a href="#下载tortoisegit" class="headerlink" title="下载tortoisegit"></a>下载tortoisegit</h2><p>tortoisegit官网下载:<a href="https://tortoisegit.org/download/">https://tortoisegit.org/download</a></p><h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210326153841.png" alt="image-20210326153831143"></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markerdown-高效上传图片工具PicGo</title>
      <link href="/2021/03/24/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/md/markerdown-%E9%AB%98%E6%95%88%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%B7%A5%E5%85%B7PicGo/"/>
      <url>/2021/03/24/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/md/markerdown-%E9%AB%98%E6%95%88%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%B7%A5%E5%85%B7PicGo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在使用Typora时可随时便捷上传图片</p><span id="more"></span><h2 id="一-应用场景"><a href="#一-应用场景" class="headerlink" title="一 应用场景"></a>一 应用场景</h2><p>在编写markerdown文档时,需要插入图片,因文档最终上传到云端,所以需要将网络图片地址插入其中;</p><p><strong>PicGo</strong>工具在Typora中内置并集成,可使用该插件将本地或其它网络图片直接上传到云端</p><h2 id="二-下载地址"><a href="#二-下载地址" class="headerlink" title="二 下载地址"></a>二 下载地址</h2><p>官方网站:<a href="https://molunerfinn.com/PicGo/">https://molunerfinn.com/PicGo/</a></p><p>下载地址:<a href="https://github.com/Molunerfinn/picgo/releases">https://github.com/Molunerfinn/picgo/releases</a></p><h2 id="三-使用方式"><a href="#三-使用方式" class="headerlink" title="三 使用方式"></a>三 使用方式</h2><h4 id="1下载PicGo并配置"><a href="#1下载PicGo并配置" class="headerlink" title="1下载PicGo并配置"></a>1下载PicGo并配置</h4><p>​    下载安装完毕后,参照<a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html">文档</a>进行配置,如图是糖糖的配置项</p><p>​    <img src="http://cdn.tangyuxian.com/PicGoImages/20210324162152.png" alt="image-20210324162149788"></p><p>这里推荐<a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html#github%E5%9B%BE%E5%BA%8A">github配置</a>,设定的自定义域名为<strong>jsdelivr</strong>可享有免费的CDN加速</p><p><a href="https://cdn.jsdelivr.net/gh/%60[github%E7%94%A8%E6%88%B7%E5%90%8D]%60/%60[%E4%BB%93%E5%BA%93%E5%90%8D]%60@%60[%E7%89%88%E6%9C%AC%E5%88%86%E6%94%AF]%60">https://cdn.jsdelivr.net/gh/`[github用户名]`/`[仓库名]`@`[版本分支]`</a></p><p>例如:<a href="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@master">https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@master</a></p><h4 id="2-在Typora中配置"><a href="#2-在Typora中配置" class="headerlink" title="2 在Typora中配置"></a>2 在Typora中配置</h4><img src="http://cdn.tangyuxian.com/PicGoImages/20210324162544.png" alt="image-20210324162542890"  /><p>在<code>文件</code>-&gt;<code>偏好设置</code>-&gt;<code>图像</code>中配置<code>上传服务设定</code></p><p>按照图中配置即可</p><p>插件配置方式可参照<a href="https://support.typora.io/Upload-Image/">官方文档</a>进行配置</p><h4 id="3-使用"><a href="#3-使用" class="headerlink" title="3 使用"></a>3 使用</h4><p>日常编辑时,可随时截图,在Typora处粘贴,右键图片便可看到<code>上传图片</code>功能,上传成功后会自动替换本地图片路径;</p><p>在网上复制文章中,会夹带网络地址的图片,部分网络图片因为<strong>防盗链</strong>技术,无法在自己的网站上显示这些图,同样可以在图片上右键选择<code>上传图片</code>,将图片上传到自己的服务源,一劳永逸</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markerdown </tag>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markerdown-Typora编辑器</title>
      <link href="/2021/03/24/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/md/markerdown-Typora%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>/2021/03/24/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/md/markerdown-Typora%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Typora 是一款支持实时预览的 Markdown 文本编辑器</p><span id="more"></span><h2 id="一-了解Markdown"><a href="#一-了解Markdown" class="headerlink" title="一 了解Markdown"></a>一 了解Markdown</h2><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/iconfinder_markdown_298823.png" alt="img"></p><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p><p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p><p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p><p>Markdown 编写的文档后缀为 <strong>.md</strong>, <strong>.markdown</strong>。</p><p>更多详细内容可参照<a href="https://www.runoob.com/markdown/md-tutorial.html">菜鸟教程:Markdown</a></p><h2 id="二-书写工具"><a href="#二-书写工具" class="headerlink" title="二 书写工具"></a>二 书写工具</h2><p>Typora官方网站:<a href="https://www.typora.io/">https://www.typora.io/</a></p><p>Typora中文网站:<a href="https://www.typora.net/">https://www.typora.net/</a></p><p>国内码云上的发行版本:<a href="https://gitee.com/typora-mirror/Typora-Mirror/releases">https://gitee.com/typora-mirror/Typora-Mirror/releases</a></p><h2 id="三-语法"><a href="#三-语法" class="headerlink" title="三 语法"></a>三 语法</h2><h4 id="1-字体编辑"><a href="#1-字体编辑" class="headerlink" title="1. 字体编辑"></a>1. 字体编辑</h4><h5 id="1-1-标题"><a href="#1-1-标题" class="headerlink" title="1.1 标题"></a>1.1 标题</h5><pre><code class="text"># 一级标题        快捷键Ctrl+1## 二级标题       快捷键Ctrl+2### 三级标题      快捷键Ctrl+3#### 四级标题     快捷键Ctrl+4##### 五级标题    快捷键Ctrl+5###### 六级标题   快捷键Ctrl+6</code></pre><p><code>三级标题 快捷键Ctrl+3</code></p><h5 id="1-2-字体大小"><a href="#1-2-字体大小" class="headerlink" title="1.2 字体大小"></a>1.2 字体大小</h5><pre><code class="text">快捷键：Ctrl+数字  或 Ctrl+加减号  或  ### （几个#表示几级标题，同上）</code></pre><h5 id="1-3-字体加粗"><a href="#1-3-字体加粗" class="headerlink" title="1.3 字体加粗"></a>1.3 字体加粗</h5><pre><code class="text">快捷键：Ctrl+b示 例：**加粗内容**</code></pre><h5 id="1-4-斜体"><a href="#1-4-斜体" class="headerlink" title="1.4 斜体"></a>1.4 斜体</h5><pre><code class="text">快捷键：ctrl+i示 例：*斜体*</code></pre><h5 id="1-5-删除线"><a href="#1-5-删除线" class="headerlink" title="1.5 删除线"></a>1.5 删除线</h5><pre><code class="text">快捷键：alt+shift+5示 例：~~删除的内容~~</code></pre><h5 id="1-6-下划线"><a href="#1-6-下划线" class="headerlink" title="1.6 下划线"></a>1.6 下划线</h5><pre><code class="text">快捷键：Ctrl+u示 例：&lt;u&gt;下划线内容&lt;/u&gt;</code></pre><h5 id="1-7-文本居中"><a href="#1-7-文本居中" class="headerlink" title="1.7 文本居中"></a>1.7 文本居中</h5><pre><code class="text">操作：&lt;center&gt;居中内容&lt;/center&gt;</code></pre><h5 id="1-8-脚注"><a href="#1-8-脚注" class="headerlink" title="1.8 脚注"></a>1.8 脚注</h5><pre><code class="text">操作：这块有个脚注[^脚注]     [^脚注]:填写脚注的内容示例：有一个github网址[^1]     [^1]:https://github.com/</code></pre><p>注意：使用1.9~1.11功能前，请先在 文件 - &gt; 偏好设置 中的Markdwn中勾选对应的功能，然后重启软件，就可以用了，操作如下图所示</p><p><img src="https://pic1.zhimg.com/80/v2-ef6d571b0f47c9e4fc20b7f2dee47a68_720w.jpg" alt="img"></p><h5 id="1-9-上标"><a href="#1-9-上标" class="headerlink" title="1.9 上标"></a>1.9 上标</h5><pre><code class="text">使用这个特性，请先在文件 -&gt; 偏好设置 中的Markdwn选择开启。操作：^ + 字体 + ^示例：X^2^</code></pre><h5 id="1-10-下标"><a href="#1-10-下标" class="headerlink" title="1.10 下标"></a>1.10 下标</h5><pre><code class="text">操作：~ + 字体 + ~示例：H~2~O     X~long\ text~</code></pre><h5 id="1-11-文字高亮"><a href="#1-11-文字高亮" class="headerlink" title="1.11 文字高亮"></a>1.11 文字高亮</h5><pre><code class="text">操作：==高亮文字==</code></pre><h4 id="2-列表"><a href="#2-列表" class="headerlink" title="2. 列表"></a>2. 列表</h4><h5 id="2-1-有序列表"><a href="#2-1-有序列表" class="headerlink" title="2.1 有序列表"></a>2.1 有序列表</h5><pre><code class="text">操作：数字+英文小数点(.)+空格示例：1. list1     2. list2</code></pre><h5 id="2-2-无序列表"><a href="#2-2-无序列表" class="headerlink" title="2.2 无序列表"></a>2.2 无序列表</h5><pre><code class="text">操作：- +空格 或 * + 空格示例： - list1      - list2</code></pre><h4 id="3-插入"><a href="#3-插入" class="headerlink" title="3. 插入"></a>3. 插入</h4><h5 id="3-1-插入代码块"><a href="#3-1-插入代码块" class="headerlink" title="3.1 插入代码块"></a>3.1 插入代码块</h5><pre><code class="text">快捷键：shift+~~~</code></pre><h5 id="3-2-插入数学公式"><a href="#3-2-插入数学公式" class="headerlink" title="3.2 插入数学公式"></a>3.2 插入数学公式</h5><pre><code class="text">操作：$$ + enter示例：$$ + enter后输入11+12，结果如下所示</code></pre><h5 id="3-3-插入引用"><a href="#3-3-插入引用" class="headerlink" title="3.3 插入引用"></a>3.3 插入引用</h5><pre><code class="text">操作：&gt; + 空格示例：&gt; + 空格后，输入 引用的内容，结果如下所示 </code></pre><h5 id="3-4-插入链接"><a href="#3-4-插入链接" class="headerlink" title="3.4 插入链接"></a>3.4 插入链接</h5><pre><code class="text">操 作:Ctrl+k弹出后，输入 [输入标题名](输入链接地址) 即可示 例1：[百度一下，你就知道](https://www.baidu.com/)示 例2：这是 [百度一下，你就知道](https://www.baidu.com/ &quot;百度&quot;) 的链接.  示 例3：这是 [github][1] 的链接.         [1]: https://github.com/ &quot;github&quot;ps：按住ctrl点击链接可直接打开</code></pre><h5 id="3-5-插入注释"><a href="#3-5-插入注释" class="headerlink" title="3.5 插入注释"></a>3.5 插入注释</h5><pre><code class="text">操作：[^文字]：文字示例：[^1]：文献1</code></pre><h5 id="3-6-插入表格"><a href="#3-6-插入表格" class="headerlink" title="3.6 插入表格"></a>3.6 插入表格</h5><pre><code class="text">快捷键：ctrl+t示 例：按完快捷键后，弹出下图，选择对应的行和列，点击确定即可。</code></pre><p><img src="https://pic2.zhimg.com/80/v2-f44eb3bc4a5a55951c7efcb2eb11f72d_720w.jpg" alt="img"></p><h5 id="3-7-插入图片"><a href="#3-7-插入图片" class="headerlink" title="3.7 插入图片"></a>3.7 插入图片</h5><pre><code class="text">操作：直接拖动  或 ctrl+shift+i(相对路径地址)示例：![](C:\1.jpg)</code></pre><h5 id="3-8-插入分隔符"><a href="#3-8-插入分隔符" class="headerlink" title="3.8 插入分隔符"></a>3.8 插入分隔符</h5><pre><code class="text">操作：--- + enter  或者 *** + enter</code></pre><h5 id="3-9-插入表情"><a href="#3-9-插入表情" class="headerlink" title="3.9 插入表情"></a>3.9 插入表情</h5><pre><code class="text">操作： ：+ 单词 +:示例： :smile:      :cry:</code></pre><h5 id="3-10-插入目录"><a href="#3-10-插入目录" class="headerlink" title="3.10 插入目录"></a>3.10 插入目录</h5><p>操作：[toc]+enter</p><h5 id="3-11-公式内换行"><a href="#3-11-公式内换行" class="headerlink" title="3.11 公式内换行"></a>3.11 公式内换行</h5><p>操作：\</p><h5 id="3-12-公式内左对齐"><a href="#3-12-公式内左对齐" class="headerlink" title="3.12 公式内左对齐"></a>3.12 公式内左对齐</h5><p>操作：在公式最开始加\begin{aligned}，然后每个等号前加&amp;，即&amp;=，每一行用\换行，然后最后一句输完后\end{aligned}</p><p>实例：\begin{aligned}d(x,y)&amp;=\sqrt{(x_1-y_1)^2+(x_2-y_2)^2+\dots+(x_n-y_n)^2}\&amp;=\sqrt{\sum_{i=1}^{n}{(x_i-y_i)^2}} \end{aligned}</p><p>公式如下：</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210324155609.png"></p><h5 id="3-13-矩阵表示"><a href="#3-13-矩阵表示" class="headerlink" title="3.13 矩阵表示"></a>3.13 矩阵表示</h5><p>操作：<code>\begin&#123;matrix&#125;</code>和<code>\end&#123;matrix&#125;</code>说明在它们之间的是矩阵<br><code>1 &amp; 2 &amp; 3\\</code>表示第一行的元素，其中用<code>&amp;</code>来分割每一个元素，用<code>\\</code>来换行<br>实例: \left[\begin{matrix} 1 &amp; 2 &amp; 3\ 4 &amp; 5 &amp; 6 \end{matrix}\right]</p><p><img src="https://raw.githubusercontent.com/tangyuxian/blog_image/master/PicGo/20210324155643.png"></p><h5 id="3-14-希腊字母表示"><a href="#3-14-希腊字母表示" class="headerlink" title="3.14 希腊字母表示"></a>3.14 希腊字母表示</h5><p><img src="https://pic3.zhimg.com/80/v2-68922903c83e504e3e3e4efd5b7327fa_720w.jpg" alt="img"></p><h5 id="3-15-箭头表示"><a href="#3-15-箭头表示" class="headerlink" title="3.15 箭头表示"></a>3.15 箭头表示</h5><p><img src="https://pic3.zhimg.com/80/v2-42ff8eb3a827056b16b2133f58009abe_720w.jpg" alt="img"></p><h5 id="3-16-公式大全"><a href="#3-16-公式大全" class="headerlink" title="3.16 公式大全"></a>3.16 公式大全</h5><p><img src="https://pic2.zhimg.com/80/v2-2f57dd9499cba748a39be06d2104fe21_720w.jpg" alt="img"></p><h5 id="3-17-二进制运算-相关符号"><a href="#3-17-二进制运算-相关符号" class="headerlink" title="3.17 二进制运算/相关符号"></a>3.17 二进制运算/相关符号</h5><p><img src="https://pic3.zhimg.com/80/v2-fd7827f7c554e1f2c6d9a356f868a0fe_720w.jpg" alt="img"></p><h5 id="3-18-空格表示"><a href="#3-18-空格表示" class="headerlink" title="3.18 空格表示"></a>3.18 空格表示</h5><p>在公式中如果需要有空格，可以用+空格的方式来实现</p><p>实例：max \ a</p><h5 id="3-19-花括号表示"><a href="#3-19-花括号表示" class="headerlink" title="3.19 花括号表示"></a>3.19 花括号表示</h5><p>为了美观，常用公式中可能会用到花括号</p><p>实例：c(u)=\begin{cases} \sqrt\frac{1}{N}，u=0\ \sqrt\frac{2}{N}， u\neq0\end{cases}</p><p>结果展示如下：</p><p><img src="https://www.zhihu.com/equation?tex=c(u)=%5Cbegin%7Bcases%7D+%5Csqrt%5Cfrac%7B1%7D%7BN%7D%EF%BC%8Cu=0%5C%5C+%5Csqrt%5Cfrac%7B2%7D%7BN%7D%EF%BC%8C+u%5Cneq0%5Cend%7Bcases%7D+" alt="[公式]"></p><hr><p>语法来源:<a href="https://zhuanlan.zhihu.com/p/90561228">知乎文章:Typora的安装和语法</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markerdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器-回流和重绘</title>
      <link href="/2021/03/24/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/"/>
      <url>/2021/03/24/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>回流一定会触发重绘，而重绘不一定会回流</p><span id="more"></span><h2 id="html-加载时发生了什么"><a href="#html-加载时发生了什么" class="headerlink" title="html 加载时发生了什么"></a>html 加载时发生了什么</h2><p>在页面加载时，浏览器把获取到的HTML代码解析成1个DOM树，DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等。<br> 浏览器把所有样式(用户定义的CSS和用户代理)解析成样式结构体<br> DOM Tree 和样式结构体组合后构建render tree, render tree类似于DOM tree，但区别很大，因为render tree能识别样式，render tree中每个NODE都有自己的style，而且render tree不包含隐藏的节点(比如display:none的节点，还有head节点)，因为这些节点不会用于呈现，而且不会影响呈现的，所以就不会包含到 render tree中。我自己简单的理解就是DOM Tree和我们写的CSS结合在一起之后，渲染出了render tree。</p><p><strong>注:浏览器渲染机制可以参考<a href="/2021/03/22/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/">浏览器-页面渲染过程</a>一文</strong></p><h2 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h2><h4 id="什么是回流"><a href="#什么是回流" class="headerlink" title="什么是回流"></a>什么是回流</h4><p>当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。</p><h4 id="什么是重绘"><a href="#什么是重绘" class="headerlink" title="什么是重绘"></a>什么是重绘</h4><p>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。</p><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><p>他们的区别很大：<br> 回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流<br> 当页面布局和几何属性改变时就需要回流<br> 比如：添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变</p><h2 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h2><h4 id="浏览器的帮忙"><a href="#浏览器的帮忙" class="headerlink" title="浏览器的帮忙"></a>浏览器的帮忙</h4><p>所以我们能得知回流比重绘的代价要更高，回流的花销跟render tree有多少节点需要重新构建有关系<br> 因为这些机制的存在，所以浏览器会帮助我们优化这些操作，浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p><h4 id="自己的优化"><a href="#自己的优化" class="headerlink" title="自己的优化"></a>自己的优化</h4><p>但是靠浏览器不如靠自己，我们可以改变一些写法减少回流和重绘<br> 比如改变样式的时候，不去改变他们每个的样式，而是直接改变className 就要用到cssText 但是要注意有一个问题，会把原有的cssText清掉，比如原来的style中有’display:none;’，那么执行完上面的JS后，display就被删掉了。<br> 为了解决这个问题，可以采用cssText累加的方法，但是IE不支持累加，前面添一个分号可以解决。<br> 还有添加节点的时候比如要添加一个div里面有三个子元素p，如果添加div再在里面添加三次p，这样就触发很多次回流和重绘，我们可以用cloneNode(true or false) 来避免，一次把要添加的都克隆好再appened</p><hr><p>参考文档:<a href="https://www.jianshu.com/p/e081f9aa03fb">简书文章:什么是回流，什么是重绘，有什么区别？</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器-页面渲染过程</title>
      <link href="/2021/03/22/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/"/>
      <url>/2021/03/22/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>从解析html构建dom树开始分析</p><span id="more"></span><h2 id="一-概览"><a href="#一-概览" class="headerlink" title="一 概览"></a>一 概览</h2><p>1、解析HTML，生成DOM树；</p><p>2、解析CSS，生成CSS规则树；</p><p>3、合并DOM树和CSS规则树，生成render树；</p><p>4、布局render树(layout/reflow)；</p><p>5、绘制render树(print)，绘制页面像素信息；</p><p>6、浏览器将各层的信息发送给GUI，GUI将各层合成，显示在屏幕上。</p><h2 id="二-分析"><a href="#二-分析" class="headerlink" title="二 分析"></a>二 分析</h2><h4 id="1-构建dom树"><a href="#1-构建dom树" class="headerlink" title="1 构建dom树"></a>1 构建dom树</h4><p>构建过程：Bytes-&gt;Characters-&gt;Tokens-&gt;Nodes-&gt;Dom</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1fbb64456195ec4ee38120bdaa0eb137.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/55fe0d9b8e517df129302bf703cd2628.png" alt="55fe0d9b8e517df129302bf703cd2628.png"></p><p>网络中传输的内容其实是0和1这种字节数据，浏览器在收到字节数据后，才将字节数据转换为字符串；</p><p>当数据转换为字符串以后，浏览器会先将这些字符串通过词法分析转换为标记(token)，这一过程叫做标记化。Token中会标识出当前Token是“开始标签”还是“结束标签”亦或是“文本”等信息。</p><p>结束化结束之后，这些标记紧接着就会被转换为Node，这些Node会根据不同Node之前的联系生成DOM树(Document Object Model)。</p><p>除了HTML文件还有CSS文件和JS文件。</p><h4 id="2-构建CSSOM树"><a href="#2-构建CSSOM树" class="headerlink" title="2 构建CSSOM树"></a>2 构建CSSOM树</h4><p>构建过程：Bytes-&gt;Characters-&gt;Tokens-&gt;Nodes-&gt;CSSOM</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a7b772966b0cc0e5a701bbd1a628d1dc.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/76f61d92296bbdba2cc5b919a3551c58.png" alt="img"></p><p>在这个过程中，浏览器会确定下一个节点的样式，并且这个过程是非常消耗资源的。因为节点的样式可以直接设置，也可以通过继承获得，浏览器必须递归CSSOM树才能确定具体的元素的样式。</p><h4 id="3-构建渲染树-呈现树Render-Tree"><a href="#3-构建渲染树-呈现树Render-Tree" class="headerlink" title="3 构建渲染树(呈现树Render Tree)"></a>3 构建渲染树(呈现树Render Tree)</h4><p>合并DOM树和CSSOM树构建渲染树</p><p>1、过滤掉不可见节点(脚本标记、元标记)</p><p>2、过滤掉样式隐藏的节点(display:none)</p><p>根据渲染树来布局，计算节点的几何信息(layout)</p><p>将各个节点绘制在屏幕上(paint)</p><p><img src="/images/view/render_tree.png" alt="img"></p><p>只有当DOM树和CSSOM树都构建完成之后才可以进行渲染树的构建，所以这两步是对整体渲染起阻塞作用的，当然了DOM树是必须的，它提供给页面内容，而CSSOM的必要性并不是太明显，所以在CSSOM构建的过程中可以做一些优化。在做优化前先要了解这几个知识点。</p><p>1、默认情况下，CSS是阻塞渲染的资源</p><p>2、我们可以通过媒体查询和媒体类型把一部分CSS标记为不阻塞渲染</p><p>(媒体查询的不足就是会严重影响关键渲染路径的性能)</p><p>3、浏览器<strong>会下载所有CSS资源</strong>、无论它阻塞还是不阻塞</p><p>根据上面三个知识点，会让你很清晰的知道，CSS优化可以做的事情就是，根据不同CSS使用场景和优先级的不同进行不阻塞标记。</p><p>如果是必要的CSS就请尽早的加载(1、引用位置靠前，2、减小文件体积)到客户端，这样就减少了对首次渲染的阻塞</p><h2 id="三-JavaScript对渲染的影响"><a href="#三-JavaScript对渲染的影响" class="headerlink" title="三 JavaScript对渲染的影响"></a>三 JavaScript对渲染的影响</h2><p>可以修改网页的方方面面，内容、样式、以及响应用户的交互。不过，javascript也会阻止DOM的构建和延缓网页渲染。下面我们来了解一下javascript和DOM、CSSOM的依赖关系。</p><p>javascript能修改内容和样式</p><p>无论(内联javascript还是外部javascript文件)都会阻止DOM的构建</p><p>DOM构建过程中如果遇到(非异步加载async)的javascript标签，浏览器将会终止DOM的构建，立即执行javascript。</p><p>这就是为什么非异步执行的javascript要放在尾部或者将可执行代码要放在DOMContentLoaded回调中？</p><p>因为如果该javascript代码操作了未构建完的DOM节点就会因为无法获取该节点而无法执行响应的操作。</p><p>CSSOM的构建影响javascript的执行</p><p>如果在浏览器尚未完成CSSOM的下载和构建时，去运行javascript脚本，那么浏览器会延迟脚本的执行和DOM的构建，直至完成CSSOM的下载和构建。可以这样理解，当出现非异步加载的javascript时，CSSOM构建完成时间是早于javascript的执行，两者早于DOMContentloaded(即DOM构建彻底完成)。</p><p>未优化–javascript正常加载</p><p><img src="https://img-blog.csdnimg.cn/img_convert/98c1f4d59ad41b430d0a8526033e33ec.png" alt="img"></p><p>优化后–javascript异步加载</p><p><img src="https://img-blog.csdnimg.cn/img_convert/603c037ccd269bee3e8b7384bbe37ac5.png" alt="img"></p><p>根据上面的分析，我们可以清楚的认识到，非必要优先加载的js，选择异步加载是最优选择。<br>为什么大家普遍把这样的代码放在body最底部？</p><p>JS文件不止会阻塞DOM的构建，也会导致CSSOM的构建。不完整的CSSOM是无法使用的，JavaScript想要访问CSSOM并更改它，就必须得到完整的CSSOM。所以导致浏览器在未完成CSSOM的构建的时候想要运行JavaScript。这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript。</p><p><strong>JavaScript并不是必须放在底部</strong>，我们可以为script标签添加属性：</p><p><code>defer</code>属性，表示js文件会并行下载，但是会放到HTML解析完成后顺序执行。</p><p><code>async</code>属性，对于没有任何依赖的js文件可以使用，表示JS文件下载和解析不会阻塞渲染。</p><p>async与defer的区别在于，如果已经加载好，就会开始执行，即使仍在HTML解析阶段，所以这种方式加载的JavaScript依然会阻塞load事件。</p><p>async-scrapt可能在DOMContentLoaded触发直线或之后执行，但一定在load之前执行，所以多个async-script的执行顺序是不确定的。</p><h2 id="四-优化策略"><a href="#四-优化策略" class="headerlink" title="四 优化策略"></a>四 优化策略</h2><p>1、从文件大小考虑</p><p>2、将css放在头部，将js放在尾部</p><p>3、减少资源请求数量</p><p>4、下载的内容是否要在首屏上使用</p><p>5、script标签的使用加defer或async属性。</p><p>测试工具：<strong>Lighthouse</strong> 可以快速测试你的网页，并提供性能报告</p><p>监控工具：<strong>Nivigation Timing Api</strong> 设置你的代码，实时监控用户使用过程中的性能。</p><hr><p>参考文档:</p><p><a href="https://blog.csdn.net/weixin_39631632/article/details/113010250">csdn文章:页面dom渲染过程</a></p><p><a href="https://blog.csdn.net/weixin_42130786/article/details/113010254">csdn文章:页面渲染原理</a></p><p><a href="https://segmentfault.com/a/1190000010298038">segmentfault文章:浏览器渲染页面过程与页面优化</a></p><p>扩展阅读:<a href="https://juejin.cn/post/6869279683230629896">掘金文章:从输入url到页面展示发生了什么？</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器-跨域及其解决方案</title>
      <link href="/2021/03/19/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-%E8%B7%A8%E5%9F%9F%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2021/03/19/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-%E8%B7%A8%E5%9F%9F%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>跨域是指一个域下的文档或脚本试图去请求另一个域下的资源</p><span id="more"></span><h2 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a><strong>什么是跨域？</strong></h2><p>跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。</p><p>广义的跨域：</p><pre><code>1.) 资源跳转： A链接、重定向、表单提交2.) 资源嵌入： &lt;link&gt;、&lt;script&gt;、&lt;img&gt;、&lt;frame&gt;等dom标签，还有样式中background:url()、@font-face()等文件外链3.) 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等</code></pre><p>其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。</p><p><strong>什么是同源策略？</strong><br>同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><p>同源策略限制以下几种行为：</p><pre><code>1.) Cookie、LocalStorage 和 IndexDB 无法读取2.) DOM 和 Js对象无法获得3.) AJAX 请求不能发送</code></pre><h2 id="常见跨域场景"><a href="#常见跨域场景" class="headerlink" title="常见跨域场景"></a><strong>常见跨域场景</strong></h2><pre><code class="text">URL                                      说明                    是否允许通信http://www.domain.com/a.jshttp://www.domain.com/b.js         同一域名，不同文件或路径           允许http://www.domain.com/lab/c.jshttp://www.domain.com:8000/a.jshttp://www.domain.com/b.js         同一域名，不同端口                不允许 http://www.domain.com/a.jshttps://www.domain.com/b.js        同一域名，不同协议                不允许 http://www.domain.com/a.jshttp://192.168.4.12/b.js           域名和域名对应相同ip              不允许 http://www.domain.com/a.jshttp://x.domain.com/b.js           主域相同，子域不同                不允许http://domain.com/c.js http://www.domain1.com/a.jshttp://www.domain2.com/b.js        不同域名                         不允许</code></pre><h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a><strong>跨域解决方案</strong></h2><p>1、 通过jsonp跨域<br>2、 document.domain + iframe跨域<br>3、 location.hash + iframe<br>4、 window.name + iframe跨域<br>5、 postMessage跨域<br>6、 跨域资源共享（CORS）<br>7、 nginx代理跨域<br>8、 nodejs中间件代理跨域<br>9、 WebSocket协议跨域</p><h4 id="一、-通过jsonp跨域"><a href="#一、-通过jsonp跨域" class="headerlink" title="一、 通过jsonp跨域"></a><strong>一、 通过jsonp跨域</strong></h4><p>通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。</p><p>1.）原生实现：</p><pre><code> &lt;script&gt;    var script = document.createElement(&#39;script&#39;);    script.type = &#39;text/javascript&#39;;    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数    script.src = &#39;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#39;;    document.head.appendChild(script);    // 回调执行函数    function handleCallback(res) &#123;        alert(JSON.stringify(res));    &#125; &lt;/script&gt;</code></pre><p>服务端返回如下（返回时即执行全局函数）：</p><pre><code>handleCallback(&#123;&quot;status&quot;: true, &quot;user&quot;: &quot;admin&quot;&#125;)</code></pre><p>2.）jquery ajax：</p><pre><code>$.ajax(&#123;    url: &#39;http://www.domain2.com:8080/login&#39;,    type: &#39;get&#39;,    dataType: &#39;jsonp&#39;,  // 请求方式为jsonp    jsonpCallback: &quot;handleCallback&quot;,    // 自定义回调函数名    data: &#123;&#125;&#125;);</code></pre><p>3.）vue.js：</p><pre><code>this.$http.jsonp(&#39;http://www.domain2.com:8080/login&#39;, &#123;    params: &#123;&#125;,    jsonp: &#39;handleCallback&#39;&#125;).then((res) =&gt; &#123;    console.log(res); &#125;)</code></pre><p>后端node.js代码示例：</p><pre><code>var querystring = require(&#39;querystring&#39;);var http = require(&#39;http&#39;);var server = http.createServer();server.on(&#39;request&#39;, function(req, res) &#123;    var params = qs.parse(req.url.split(&#39;?&#39;)[1]);    var fn = params.callback;    // jsonp返回设置    res.writeHead(200, &#123; &#39;Content-Type&#39;: &#39;text/javascript&#39; &#125;);    res.write(fn + &#39;(&#39; + JSON.stringify(params) + &#39;)&#39;);    res.end();&#125;);server.listen(&#39;8080&#39;);console.log(&#39;Server is running at port 8080...&#39;);</code></pre><p>jsonp缺点：只能实现get一种请求。</p><h4 id="二、-document-domain-iframe跨域"><a href="#二、-document-domain-iframe跨域" class="headerlink" title="二、 document.domain + iframe跨域"></a><strong>二、 document.domain + iframe跨域</strong></h4><p>此方案仅限主域相同，子域不同的跨域应用场景。</p><p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p><p>1.）父窗口：(<a href="http://www.domain.com/a.html">http://www.domain.com/a.html</a>)</p><pre><code>&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;&lt;script&gt;    document.domain = &#39;domain.com&#39;;    var user = &#39;admin&#39;;&lt;/script&gt;</code></pre><p>2.）子窗口：(<a href="http://child.domain.com/b.html">http://child.domain.com/b.html</a>)</p><pre><code>&lt;script&gt;    document.domain = &#39;domain.com&#39;;    // 获取父窗口中变量    alert(&#39;get js data from parent ---&gt; &#39; + window.parent.user);&lt;/script&gt;</code></pre><h4 id="三、-location-hash-iframe跨域"><a href="#三、-location-hash-iframe跨域" class="headerlink" title="三、 location.hash + iframe跨域"></a><strong>三、 location.hash + iframe跨域</strong></h4><p>实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p><p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p><p>1.）a.html：(<a href="http://www.domain1.com/a.html">http://www.domain1.com/a.html</a>)</p><pre><code>&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt;    var iframe = document.getElementById(&#39;iframe&#39;);    // 向b.html传hash值    setTimeout(function() &#123;        iframe.src = iframe.src + &#39;#user=admin&#39;;    &#125;, 1000);        // 开放给同域c.html的回调方法    function onCallback(res) &#123;        alert(&#39;data from c.html ---&gt; &#39; + res);    &#125;&lt;/script&gt;</code></pre><p>2.）b.html：(<a href="http://www.domain2.com/b.html">http://www.domain2.com/b.html</a>)</p><pre><code>&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain1.com/c.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt;    var iframe = document.getElementById(&#39;iframe&#39;);    // 监听a.html传来的hash值，再传给c.html    window.onhashchange = function () &#123;        iframe.src = iframe.src + location.hash;    &#125;;&lt;/script&gt;</code></pre><p>3.）c.html：(<a href="http://www.domain1.com/c.html">http://www.domain1.com/c.html</a>)</p><pre><code>&lt;script&gt;    // 监听b.html传来的hash值    window.onhashchange = function () &#123;        // 再通过操作同域a.html的js回调，将结果传回        window.parent.parent.onCallback(&#39;hello: &#39; + location.hash.replace(&#39;#user=&#39;, &#39;&#39;));    &#125;;&lt;/script&gt;</code></pre><h4 id="四、-window-name-iframe跨域"><a href="#四、-window-name-iframe跨域" class="headerlink" title="四、 window.name + iframe跨域"></a><strong>四、 window.name + iframe跨域</strong></h4><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p><p>1.）a.html：(<a href="http://www.domain1.com/a.html">http://www.domain1.com/a.html</a>)</p><pre><code>var proxy = function(url, callback) &#123;    var state = 0;    var iframe = document.createElement(&#39;iframe&#39;);    // 加载跨域页面    iframe.src = url;    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name    iframe.onload = function() &#123;        if (state === 1) &#123;            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据            callback(iframe.contentWindow.name);            destoryFrame();        &#125; else if (state === 0) &#123;            // 第1次onload(跨域页)成功后，切换到同域代理页面            iframe.contentWindow.location = &#39;http://www.domain1.com/proxy.html&#39;;            state = 1;        &#125;    &#125;;    document.body.appendChild(iframe);    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）    function destoryFrame() &#123;        iframe.contentWindow.document.write(&#39;&#39;);        iframe.contentWindow.close();        document.body.removeChild(iframe);    &#125;&#125;;// 请求跨域b页面数据proxy(&#39;http://www.domain2.com/b.html&#39;, function(data)&#123;    alert(data);&#125;);</code></pre><p>2.）proxy.html：(<a href="http://www.domain1.com/proxy.html">http://www.domain1.com/proxy….</a>)<br>中间代理页，与a.html同域，内容为空即可。</p><p>3.）b.html：(<a href="http://www.domain2.com/b.html">http://www.domain2.com/b.html</a>)</p><pre><code>&lt;script&gt;    window.name = &#39;This is domain2 data!&#39;;&lt;/script&gt;</code></pre><p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h4 id="五、-postMessage跨域"><a href="#五、-postMessage跨域" class="headerlink" title="五、 postMessage跨域"></a><strong>五、 postMessage跨域</strong></h4><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：<br>a.） 页面和其打开的新窗口的数据传递<br>b.） 多窗口之间消息传递<br>c.） 页面与嵌套的iframe消息传递<br>d.） 上面三个场景的跨域数据传递</p><p>用法：postMessage(data,origin)方法接受两个参数<br>data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。<br>origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</p><p>1.）a.html：(<a href="http://www.domain1.com/a.html">http://www.domain1.com/a.html</a>)</p><pre><code>&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt;           var iframe = document.getElementById(&#39;iframe&#39;);    iframe.onload = function() &#123;        var data = &#123;            name: &#39;aym&#39;        &#125;;        // 向domain2传送跨域数据        iframe.contentWindow.postMessage(JSON.stringify(data), &#39;http://www.domain2.com&#39;);    &#125;;    // 接受domain2返回数据    window.addEventListener(&#39;message&#39;, function(e) &#123;        alert(&#39;data from domain2 ---&gt; &#39; + e.data);    &#125;, false);&lt;/script&gt;</code></pre><p>2.）b.html：(<a href="http://www.domain2.com/b.html">http://www.domain2.com/b.html</a>)</p><pre><code>&lt;script&gt;    // 接收domain1的数据    window.addEventListener(&#39;message&#39;, function(e) &#123;        alert(&#39;data from domain1 ---&gt; &#39; + e.data);        var data = JSON.parse(e.data);        if (data) &#123;            data.number = 16;            // 处理后再发回domain1            window.parent.postMessage(JSON.stringify(data), &#39;http://www.domain1.com&#39;);        &#125;    &#125;, false);&lt;/script&gt;</code></pre><h4 id="六、-跨域资源共享（CORS）"><a href="#六、-跨域资源共享（CORS）" class="headerlink" title="六、 跨域资源共享（CORS）"></a><strong>六、 跨域资源共享（CORS）</strong></h4><p>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。</p><p>需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。</p><p>目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。</p><h5 id="1、-前端设置："><a href="#1、-前端设置：" class="headerlink" title="1、 前端设置："></a><strong>1、 前端设置：</strong></h5><p>1.）原生ajax</p><pre><code>// 前端设置是否带cookiexhr.withCredentials = true;</code></pre><p>示例代码：</p><pre><code>var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open(&#39;post&#39;, &#39;http://www.domain2.com:8080/login&#39;, true);xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;);xhr.send(&#39;user=admin&#39;);xhr.onreadystatechange = function() &#123;    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;        alert(xhr.responseText);    &#125;&#125;;</code></pre><p>2.）jQuery ajax</p><pre><code>$.ajax(&#123;    ...   xhrFields: &#123;       withCredentials: true    // 前端设置是否带cookie   &#125;,   crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie    ...&#125;);</code></pre><p>3.）vue框架</p><p>a.) axios设置：</p><pre><code>axios.defaults.withCredentials = true</code></pre><p>b.) vue-resource设置：</p><pre><code>Vue.http.options.credentials = true</code></pre><h5 id="2、-服务端设置："><a href="#2、-服务端设置：" class="headerlink" title="2、 服务端设置："></a><strong>2、 服务端设置：</strong></h5><p>若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。</p><p>1.）Java后台：</p><pre><code>/* * 导入包：import javax.servlet.http.HttpServletResponse; * 接口参数中定义：HttpServletResponse response */// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加&#39;/&#39;response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://www.domain1.com&quot;); // 允许前端带认证cookie：启用此项后，上面的域名不能为&#39;*&#39;，必须指定具体的域名，否则浏览器会提示response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); // 提示OPTIONS预检时，后端需要设置的两个常用自定义头response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,X-Requested-With&quot;);</code></pre><p>2.）Nodejs后台示例：</p><pre><code>var http = require(&#39;http&#39;);var server = http.createServer();var qs = require(&#39;querystring&#39;);server.on(&#39;request&#39;, function(req, res) &#123;    var postData = &#39;&#39;;    // 数据块接收中    req.addListener(&#39;data&#39;, function(chunk) &#123;        postData += chunk;    &#125;);    // 数据接收完毕    req.addListener(&#39;end&#39;, function() &#123;        postData = qs.parse(postData);        // 跨域后台设置        res.writeHead(200, &#123;            &#39;Access-Control-Allow-Credentials&#39;: &#39;true&#39;,     // 后端允许发送Cookie            &#39;Access-Control-Allow-Origin&#39;: &#39;http://www.domain1.com&#39;,    // 允许访问的域（协议+域名+端口）            /*              * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问             */            &#39;Set-Cookie&#39;: &#39;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#39;  // HttpOnly的作用是让js无法读取cookie        &#125;);        res.write(JSON.stringify(postData));        res.end();    &#125;);&#125;);server.listen(&#39;8080&#39;);console.log(&#39;Server is running at port 8080...&#39;);</code></pre><h4 id="七、-nginx代理跨域"><a href="#七、-nginx代理跨域" class="headerlink" title="七、 nginx代理跨域"></a><strong>七、 nginx代理跨域</strong></h4><h5 id="1、-nginx配置解决iconfont跨域"><a href="#1、-nginx配置解决iconfont跨域" class="headerlink" title="1、 nginx配置解决iconfont跨域"></a><strong>1、 nginx配置解决iconfont跨域</strong></h5><p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p><pre><code>location / &#123;  add_header Access-Control-Allow-Origin *;&#125;</code></pre><h5 id="2、-nginx反向代理接口跨域"><a href="#2、-nginx反向代理接口跨域" class="headerlink" title="2、 nginx反向代理接口跨域"></a><strong>2、 nginx反向代理接口跨域</strong></h5><p>跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><p>nginx具体配置：</p><pre><code>#proxy服务器server &#123;    listen       81;    server_name  www.domain1.com;    location / &#123;        proxy_pass   http://www.domain2.com:8080;  #反向代理        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名        index  index.html index.htm;        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*        add_header Access-Control-Allow-Credentials true;    &#125;&#125;</code></pre><p>1.) 前端代码示例：</p><pre><code>var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open(&#39;get&#39;, &#39;http://www.domain1.com:81/?user=admin&#39;, true);xhr.send();</code></pre><p>2.) Nodejs后台示例：</p><pre><code>var http = require(&#39;http&#39;);var server = http.createServer();var qs = require(&#39;querystring&#39;);server.on(&#39;request&#39;, function(req, res) &#123;    var params = qs.parse(req.url.substring(2));    // 向前台写cookie    res.writeHead(200, &#123;        &#39;Set-Cookie&#39;: &#39;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#39;   // HttpOnly:脚本无法读取    &#125;);    res.write(JSON.stringify(params));    res.end();&#125;);server.listen(&#39;8080&#39;);console.log(&#39;Server is running at port 8080...&#39;);</code></pre><h4 id="八、-Nodejs中间件代理跨域"><a href="#八、-Nodejs中间件代理跨域" class="headerlink" title="八、 Nodejs中间件代理跨域"></a><strong>八、 Nodejs中间件代理跨域</strong></h4><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p><h5 id="1、-非vue框架的跨域（2次跨域）"><a href="#1、-非vue框架的跨域（2次跨域）" class="headerlink" title="1、 非vue框架的跨域（2次跨域）"></a><strong>1、 非vue框架的跨域（2次跨域）</strong></h5><p>利用node + express + http-proxy-middleware搭建一个proxy服务器。</p><p>1.）前端代码示例：</p><pre><code>var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问http-proxy-middleware代理服务器xhr.open(&#39;get&#39;, &#39;http://www.domain1.com:3000/login?user=admin&#39;, true);xhr.send();</code></pre><p>2.）中间件服务器：</p><pre><code>var express = require(&#39;express&#39;);var proxy = require(&#39;http-proxy-middleware&#39;);var app = express();app.use(&#39;/&#39;, proxy(&#123;    // 代理跨域目标接口    target: &#39;http://www.domain2.com:8080&#39;,    changeOrigin: true,    // 修改响应头信息，实现跨域并允许带cookie    onProxyRes: function(proxyRes, req, res) &#123;        res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;http://www.domain1.com&#39;);        res.header(&#39;Access-Control-Allow-Credentials&#39;, &#39;true&#39;);    &#125;,    // 修改响应信息中的cookie域名    cookieDomainRewrite: &#39;www.domain1.com&#39;  // 可以为false，表示不修改&#125;));app.listen(3000);console.log(&#39;Proxy server is listen at port 3000...&#39;);</code></pre><p>3.）Nodejs后台同（六：nginx）</p><h5 id="2、-vue框架的跨域（1次跨域）"><a href="#2、-vue框架的跨域（1次跨域）" class="headerlink" title="2、 vue框架的跨域（1次跨域）"></a><strong>2、 vue框架的跨域（1次跨域）</strong></h5><p>利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。</p><p>webpack.config.js部分配置：</p><pre><code>module.exports = &#123;    entry: &#123;&#125;,    module: &#123;&#125;,    ...    devServer: &#123;        historyApiFallback: true,        proxy: [&#123;            context: &#39;/login&#39;,            target: &#39;http://www.domain2.com:8080&#39;,  // 代理跨域目标接口            changeOrigin: true,            secure: false,  // 当代理某些https服务报错时用            cookieDomainRewrite: &#39;www.domain1.com&#39;  // 可以为false，表示不修改        &#125;],        noInfo: true    &#125;&#125;</code></pre><h4 id="九、-WebSocket协议跨域"><a href="#九、-WebSocket协议跨域" class="headerlink" title="九、 WebSocket协议跨域"></a>九、 WebSocket协议跨域</h4><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。<br>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><p>1.）前端代码：</p><pre><code>&lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var socket = io(&#39;http://www.domain2.com:8080&#39;);// 连接成功处理socket.on(&#39;connect&#39;, function() &#123;    // 监听服务端消息    socket.on(&#39;message&#39;, function(msg) &#123;        console.log(&#39;data from server: ---&gt; &#39; + msg);     &#125;);    // 监听服务端关闭    socket.on(&#39;disconnect&#39;, function() &#123;         console.log(&#39;Server socket has closed.&#39;);     &#125;);&#125;);document.getElementsByTagName(&#39;input&#39;)[0].onblur = function() &#123;    socket.send(this.value);&#125;;&lt;/script&gt;</code></pre><p>2.）Nodejs socket后台：</p><pre><code>var http = require(&#39;http&#39;);var socket = require(&#39;socket.io&#39;);// 启http服务var server = http.createServer(function(req, res) &#123;    res.writeHead(200, &#123;        &#39;Content-type&#39;: &#39;text/html&#39;    &#125;);    res.end();&#125;);server.listen(&#39;8080&#39;);console.log(&#39;Server is running at port 8080...&#39;);// 监听socket连接socket.listen(server).on(&#39;connection&#39;, function(client) &#123;    // 接收信息    client.on(&#39;message&#39;, function(msg) &#123;        client.send(&#39;hello：&#39; + msg);        console.log(&#39;data from client: ---&gt; &#39; + msg);    &#125;);    // 断开处理    client.on(&#39;disconnect&#39;, function() &#123;        console.log(&#39;Client socket has closed.&#39;);     &#125;);&#125;);</code></pre><hr><p>参考文档:<a href="https://segmentfault.com/a/1190000011145364">segmentfault平台文章:前端常见跨域解决方案</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-那些你常用又记不住的css</title>
      <link href="/2021/03/18/%E5%89%8D%E7%AB%AF/css/css-%E9%82%A3%E4%BA%9B%E4%BD%A0%E5%B8%B8%E7%94%A8%E5%8F%88%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84css/"/>
      <url>/2021/03/18/%E5%89%8D%E7%AB%AF/css/css-%E9%82%A3%E4%BA%9B%E4%BD%A0%E5%B8%B8%E7%94%A8%E5%8F%88%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84css/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>记录一些常用Css效果</p><span id="more"></span><h2 id="一、设置input-的placeholder的字体样式"><a href="#一、设置input-的placeholder的字体样式" class="headerlink" title="一、设置input 的placeholder的字体样式"></a>一、设置input 的placeholder的字体样式</h2><pre><code class="less">input::-webkit-input-placeholder &#123;    /* Chrome/Opera/Safari */    color: red;&#125;input::-moz-placeholder &#123; /* Firefox 19+ */      color: red;&#125;input:-ms-input-placeholder &#123; /* IE 10+ */    color: red;&#125;input:-moz-placeholder &#123; /* Firefox 18- */    color: red;&#125;</code></pre><h4 id="设置input聚焦时的样式"><a href="#设置input聚焦时的样式" class="headerlink" title="设置input聚焦时的样式"></a>设置input聚焦时的样式</h4><pre><code class="css">input:focus &#123;       background-color: red;&#125;</code></pre><h4 id="取消input的边框"><a href="#取消input的边框" class="headerlink" title="取消input的边框"></a>取消input的边框</h4><pre><code class="css">input &#123;    border: none;    outline: none;&#125;</code></pre><h2 id="二、隐藏滚动条或更改滚动条样式"><a href="#二、隐藏滚动条或更改滚动条样式" class="headerlink" title="二、隐藏滚动条或更改滚动条样式"></a>二、隐藏滚动条或更改滚动条样式</h2><pre><code class="css">/*css主要部分的样式*//*定义滚动条宽高及背景，宽高分别对应横竖滚动条的尺寸*/::-webkit-scrollbar &#123;    width: 10px; /*对垂直流动条有效*/    height: 10px; /*对水平流动条有效*/&#125;/*定义滚动条的轨道颜色、内阴影及圆角*/::-webkit-scrollbar-track&#123;    -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3);    background-color: rosybrown;    border-radius: 3px;&#125;/*定义滑块颜色、内阴影及圆角*/::-webkit-scrollbar-thumb&#123;     border-radius: 7px;    -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3);    background-color: #E8E8E8;&#125;/*定义两端按钮的样式*/::-webkit-scrollbar-button &#123;    background-color:cyan;&#125;/*定义右下角汇合处的样式*/::-webkit-scrollbar-corner &#123;    background:khaki;&#125;</code></pre><h2 id="三、文字超出隐藏并显示省略号"><a href="#三、文字超出隐藏并显示省略号" class="headerlink" title="三、文字超出隐藏并显示省略号"></a>三、文字超出隐藏并显示省略号</h2><h4 id="单行（一定要有宽度）"><a href="#单行（一定要有宽度）" class="headerlink" title="单行（一定要有宽度）"></a>单行（一定要有宽度）</h4><pre><code class="css">p &#123;    width:200rpx;    white-space: nowrap;    overflow: hidden;    text-overflow: ellipsis;&#125;</code></pre><h4 id="多行"><a href="#多行" class="headerlink" title="多行"></a>多行</h4><pre><code class="css">p &#123;    word-break: break-all;    display: -webkit-box;    -webkit-line-clamp: 2;    -webkit-box-orient: vertical;    overflow: hidden;&#125;</code></pre><h2 id="四、控制div内的元素自动换行"><a href="#四、控制div内的元素自动换行" class="headerlink" title="四、控制div内的元素自动换行"></a>四、控制div内的元素自动换行</h2><pre><code class="css">div &#123;    word-wrap: break-word;    word-break：break-all;&#125;</code></pre><h2 id="五、-纯css画三角形"><a href="#五、-纯css画三角形" class="headerlink" title="五、 纯css画三角形"></a>五、 纯css画三角形</h2><pre><code class="css">#demo &#123;    width: 0;    height: 0;    border-width: 20px;    border-style: solid;    border-color: transparent transparent red transparent;&#125;</code></pre><h2 id="六、-绝对定位元素居中（水平和垂直方向）"><a href="#六、-绝对定位元素居中（水平和垂直方向）" class="headerlink" title="六、 绝对定位元素居中（水平和垂直方向）"></a>六、 绝对定位元素居中（水平和垂直方向）</h2><pre><code class="css">#demo &#123;    width: 200px;    height: 200px;    position: absolute;    left: 50%;    top: 50%;    transform: translate(-50%,-50%);    background-color: green;&#125;</code></pre><h2 id="七、表格边框合并"><a href="#七、表格边框合并" class="headerlink" title="七、表格边框合并"></a>七、表格边框合并</h2><pre><code class="css">table,tr,td&#123;    border: 1px solid #333;&#125;table&#123;  border-collapse: collapse;&#125;</code></pre><hr><p>参考文档:<a href="https://zhuanlan.zhihu.com/p/228168219">知乎专栏:那些你常用又记不住的css:</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器端-docker安装Nginx</title>
      <link href="/2021/03/18/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/docker/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF-docker%E5%AE%89%E8%A3%85Nginx/"/>
      <url>/2021/03/18/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/docker/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF-docker%E5%AE%89%E8%A3%85Nginx/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用docker安装nginx,映射目录并配置通过https访问</p><span id="more"></span><h2 id="一-安装docker"><a href="#一-安装docker" class="headerlink" title="一 安装docker"></a>一 安装docker</h2><p>首先了解<a href="https://www.docker.com/">docker</a>,在<strong>centos</strong>下快速通过以下命令安装docker:</p><pre><code>curl -sSL https://get.daocloud.io/docker | sh</code></pre><p>其它系统或其它安装方式可以在<a href="https://www.runoob.com/docker/docker-tutorial.html">菜鸟教程</a>中了解</p><h2 id="二-下载nginx镜像"><a href="#二-下载nginx镜像" class="headerlink" title="二 下载nginx镜像"></a>二 下载nginx镜像</h2><pre><code class="ruby">docker pull nginx:latest</code></pre><p>可以通过以下命令查看是否已经安装nginx</p><pre><code>docker images</code></pre><h2 id="三-启动容器并做好映射"><a href="#三-启动容器并做好映射" class="headerlink" title="三 启动容器并做好映射"></a>三 启动容器并做好映射</h2><h3 id="1-执行以下命令"><a href="#1-执行以下命令" class="headerlink" title="1 执行以下命令"></a>1 执行以下命令</h3><pre><code>docker run --name nginx -d -p 80:80 -p 443:443 \-v /data/nginx/html:/usr/share/nginx/html \-v /data/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \-v /data/nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf \-v /data/nginx/logs:/var/log/nginx \-v /data/nginx/cert:/etc/nginx/cert \nginx</code></pre><h3 id="2-涉及到的指令和文件夹如下"><a href="#2-涉及到的指令和文件夹如下" class="headerlink" title="2 涉及到的指令和文件夹如下:"></a>2 涉及到的指令和文件夹如下:</h3><p><strong>–name=”nginx”:</strong> 为容器指定一个名称；</p><p><strong>-d:</strong> 后台运行容器，并返回容器ID；</p><p><strong>-p:</strong> 指定端口映射，格式为：<strong>主机(宿主)端口:容器端口</strong></p><p>​    映射端口443，用于https请求;</p><p>​    映射端口80，用于http请求；</p><p><strong>-v:</strong>  本地目录:容器目录。例:挂载主机的本地目录 <code>/data/nginx/html</code> 目录到容器的<code>/usr/share/nginx/html</code> 目录，本地目录的路径必须是绝对路径;</p><p>​    <strong>注意</strong>:本地目录可以通过<code>mkdir -p [绝对路径]</code>生成,可以自定义位置,以下展示位置仅供参考,容器目录需要以自身的实际目录位置为准,你需要进入到容器确认文件夹位置;(ps:不会进入到容器看文件夹?点击了解<a href="https://www.runoob.com/docker/docker-container-usage.html">容器使用方法</a>)</p><p>​    <code>/data/nginx/html</code>   用于存放静态资源</p><p>​    <code>/data/nginx/conf/nginx.conf</code>   nginx配置项</p><p>​    <code>/data/nginx/conf.d/default.conf</code>  nginx默认配置项</p><p>​    <code>/data/nginx/logs</code> 存放nginx产生的log日志</p><p>​    <code>/data/nginx/cert</code> 存放证书文件和私钥</p><p>更多详细指令可以在<a href="https://www.runoob.com/docker/docker-run-command.html">菜鸟教程Docker run 命令</a>查看到</p><p>通过<code>docker ps</code>查看是否启动成功,列表中存在nginx并且存在的容器ID与运行时返回的容器ID一致,则为成功</p><h2 id="3-配置访问https"><a href="#3-配置访问https" class="headerlink" title="3 配置访问https"></a>3 配置访问https</h2><p>在<code>/data/nginx/conf/nginx.conf</code>中的<code>http &#123; server &#123;&#125;&#125;</code>中追加ssl配置内容,内容如下</p><pre><code> # 增加ssl    #ssl on;        #如果强制HTTPs访问，这行要打开    ssl_certificate /etc/nginx/cert/com_bundle.crt; #证书位置    ssl_certificate_key /etc/nginx/cert/com.key; #秘钥位置    ssl_session_cache    shared:SSL:1m;    ssl_session_timeout  5m;     # 指定密码为openssl支持的格式     ssl_protocols  SSLv2 SSLv3 TLSv1.2;     ssl_ciphers  HIGH:!aNULL:!MD5;  # 密码加密方式     ssl_prefer_server_ciphers  on;   # 依赖SSLv3和TLSv1协议的服务器密码将优先于客户端密码</code></pre><p>参考完整的<code>nginx.conf</code>配置如下:</p><pre><code>user  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events &#123;    worker_connections  1024;&#125;http &#123;   server &#123;     listen 80 ;# 监听本机所有 ip 上的 80 端口     listen 443 ssl;     server_name www.tangyuxian.com;# 域名：www.example.com 这里 &quot;_&quot; 代表获取匹配所有     root /usr/share/nginx/html/blog;# 站点根目录     index index.html /;    # 增加ssl    #ssl on;        #如果强制HTTPs访问，这行要打开    ssl_certificate /etc/nginx/cert/1_tangyuxian.com_bundle.crt;    ssl_certificate_key /etc/nginx/cert/2_tangyuxian.com.key;    ssl_session_cache    shared:SSL:1m;    ssl_session_timeout  5m;     # 指定密码为openssl支持的格式     ssl_protocols  SSLv2 SSLv3 TLSv1.2;     ssl_ciphers  HIGH:!aNULL:!MD5;  # 密码加密方式     ssl_prefer_server_ciphers  on;   # 依赖SSLv3和TLSv1协议的服务器密码将优先于客户端密码   &#125;    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    include /etc/nginx/conf.d/*.conf;&#125;</code></pre><h2 id="4-对当前容器启动方面操作"><a href="#4-对当前容器启动方面操作" class="headerlink" title="4 对当前容器启动方面操作"></a>4 对当前容器启动方面操作</h2><p>启动已被停止的容器nginx</p><pre><code>docker start nginx</code></pre><p>停止运行中的容器nginx</p><pre><code>docker stop nginx</code></pre><p>重启容器nginx</p><pre><code>docker restart nginx</code></pre>]]></content>
      
      
      <categories>
          
          <category> 服务器端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> docker </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git-git设置代理模式</title>
      <link href="/2021/03/18/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/git-git%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/03/18/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/git-git%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>为git设置代理,分为全局代理和局部代理</p><span id="more"></span><h2 id="设置代理："><a href="#设置代理：" class="headerlink" title="设置代理："></a>设置代理：</h2><h3 id="全局代理"><a href="#全局代理" class="headerlink" title="全局代理"></a>全局代理</h3><p>git config –global http.proxy <code>[IP地址]</code>:<code>[端口号]</code></p><p><strong>例:</strong> git config –global http.proxy 127.0.0.1:1087</p><h3 id="局部代理，在github-clone-仓库内执行"><a href="#局部代理，在github-clone-仓库内执行" class="headerlink" title="局部代理，在github clone 仓库内执行"></a>局部代理，在github clone 仓库内执行</h3><p>git config –local http.proxy <code>[IP地址]</code>:<code>[端口号]</code></p><p><strong>例:</strong> git config –local http.proxy 127.0.0.1:1087</p><h2 id="查询是否使用代理："><a href="#查询是否使用代理：" class="headerlink" title="查询是否使用代理："></a>查询是否使用代理：</h2><h3 id="查询全局代理"><a href="#查询全局代理" class="headerlink" title="查询全局代理"></a>查询全局代理</h3><p>git config –global http.proxy</p><h3 id="查询局部代理"><a href="#查询局部代理" class="headerlink" title="查询局部代理"></a>查询局部代理</h3><p>git config –local http.proxy</p><h2 id="取消代理："><a href="#取消代理：" class="headerlink" title="取消代理："></a>取消代理：</h2><p>git config –global –unset http.proxy<br>git config –local –unset http.proxy</p><hr><p>参考文档:<a href="https://www.jianshu.com/p/8c5bb8eee8b2">简述:git设置代理模式，仅为github设置代理</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-Vuex从使用到原理解析</title>
      <link href="/2021/03/16/%E5%89%8D%E7%AB%AF/vue/vue-Vuex%E4%BB%8E%E4%BD%BF%E7%94%A8%E5%88%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>/2021/03/16/%E5%89%8D%E7%AB%AF/vue/vue-Vuex%E4%BB%8E%E4%BD%BF%E7%94%A8%E5%88%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。</p><span id="more"></span><h2 id="一、Vuex是什么"><a href="#一、Vuex是什么" class="headerlink" title="一、Vuex是什么"></a><strong>一、Vuex是什么</strong></h2><p>Vuex是专门为Vuejs应用程序设计的<strong>状态管理工具</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><h3 id="1、Vuex的构成"><a href="#1、Vuex的构成" class="headerlink" title="1、Vuex的构成"></a><strong>1、Vuex的构成</strong></h3><p><img src="https://pic4.zhimg.com/80/v2-f330e46f1a97cfe60b8914802688083b_720w.jpg" alt="img"></p><p>由上图，我们可以看出Vuex有以下几个部分构成：</p><p><strong>1）state</strong></p><p>state是存储的单一状态，是存储的基本数据。</p><p><strong>2）Getters</strong></p><p>getters是store的计算属性，对state的加工，是派生出来的数据。就像computed计算属性一样，getter返回的值会根据它的依赖被缓存起来，且只有当它的依赖值发生改变才会被重新计算。</p><p><strong>3）Mutations</strong></p><p>mutations提交更改数据，使用store.commit方法更改state存储的状态。（mutations同步函数）</p><p><strong>4）Actions</strong></p><p>actions像一个装饰器，提交mutation，而不是直接变更状态。（actions可以包含任何异步操作）</p><p><strong>5）Module</strong></p><p>Module是store分割的模块，每个模块拥有自己的state、getters、mutations、actions。</p><pre><code class="javascript">const moduleA = &#123;  state: &#123; ... &#125;,  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;,  getters: &#123; ... &#125;&#125;const moduleB = &#123;  state: &#123; ... &#125;,  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123;  modules: &#123;    a: moduleA,    b: moduleB  &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态</code></pre><p><strong>6）辅助函数</strong></p><p>Vuex提供了mapState、MapGetters、MapActions、mapMutations等辅助函数给开发在vm中处理store。</p><h3 id="2、Vuex的使用"><a href="#2、Vuex的使用" class="headerlink" title="2、Vuex的使用"></a><strong>2、Vuex的使用</strong></h3><p><img src="https://pic1.zhimg.com/80/v2-90437dee8c4d7b465b2d0e6e07778ff0_720w.png" alt="img"></p><pre><code class="javascript">import Vuex from &#39;vuex&#39;;Vue.use(Vuex); // 1. vue的插件机制，安装vuexlet store = new Vuex.Store(&#123; // 2.实例化store，调用install方法    state,    getters,    modules,    mutations,    actions,    plugins&#125;);new Vue(&#123; // 3.注入store, 挂载vue实例    store,    render: h=&gt;h(app)&#125;).$mount(&#39;#app&#39;);</code></pre><h2 id="二、Vuex的设计思想"><a href="#二、Vuex的设计思想" class="headerlink" title="二、Vuex的设计思想"></a><strong>二、Vuex的设计思想</strong></h2><p>Vuex的设计思想，借鉴了Flux、Redux，将数据存放到全局的store，再将store挂载到每个vue实例组件中，利用Vue.js的细粒度数据响应机制来进行高效的状态更新。</p><p>看了Vuex设计思想，心里难免会有这样的疑问：</p><ul><li>vuex的store是如何挂载注入到组件中呢？</li><li>vuex的state和getters是如何映射到各个组件实例中响应式更新状态呢？</li></ul><h2 id="三、Vuex的原理解析"><a href="#三、Vuex的原理解析" class="headerlink" title="三、Vuex的原理解析"></a><strong>三、Vuex的原理解析</strong></h2><p>我们来看下vuex的源码，分析看看上面2个疑惑的问题：</p><p><strong>疑问1：vuex的store是如何挂载注入到组件中呢？</strong></p><p>1、在vue项目中先安装vuex，核心代码如下：</p><pre><code class="javascript">import Vuex from &#39;vuex&#39;;Vue.use(vuex);// vue的插件机制</code></pre><p>2、利用vue的<a href="https://link.zhihu.com/?target=https://cn.vuejs.org/v2/guide/plugins.html">插件机制</a>，使用Vue.use(vuex)时，会调用vuex的install方法，装载vuex，install方法的代码如下：</p><pre><code class="javascript">export function install (_Vue) &#123;  if (Vue &amp;&amp; _Vue === Vue) &#123;    if (process.env.NODE_ENV !== &#39;production&#39;) &#123;      console.error(        &#39;[vuex] already installed. Vue.use(Vuex) should be called only once.&#39;      )    &#125;    return  &#125;  Vue = _Vue  applyMixin(Vue)&#125;</code></pre><p>3、applyMixin方法使用vue<a href="https://link.zhihu.com/?target=https://cn.vuejs.org/v2/guide/mixins.html">混入机制</a>，vue的生命周期beforeCreate钩子函数前混入vuexInit方法，核心代码如下：</p><pre><code class="javascript">Vue.mixin(&#123; beforeCreate: vuexInit &#125;);function vuexInit () &#123;    const options = this.$options    // store injection    if (options.store) &#123;      this.$store = typeof options.store === &#39;function&#39;        ? options.store()        : options.store    &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123;      this.$store = options.parent.$store    &#125;&#125;</code></pre><p>分析源码，我们知道了vuex是利用vue的mixin混入机制，在beforeCreate钩子前混入vuexInit方法，vuexInit方法实现了store注入vue组件实例，并注册了vuex store的引用属性$store。store注入过程如下图所示：</p><p><img src="https://pic4.zhimg.com/80/v2-a8b969f8771a1fc13b7cedfdfe86f0e7_720w.jpg" alt="img"></p><p><strong>疑问2：vuex的state和getters是如何映射到各个组件实例中响应式更新状态呢？</strong></p><p>store实现的源码在src/store.js</p><p>1、我们在源码中找到resetStoreVM核心方法：</p><pre><code class="javascript">function resetStoreVM (store, state, hot) &#123;  const oldVm = store._vm  // 设置 getters 属性  store.getters = &#123;&#125;  const wrappedGetters = store._wrappedGetters  const computed = &#123;&#125;  // 遍历 wrappedGetters 属性  forEachValue(wrappedGetters, (fn, key) =&gt; &#123;    // 给 computed 对象添加属性    computed[key] = partial(fn, store)    // 重写 get 方法    // store.getters.xx 其实是访问了store._vm[xx]，其中添加 computed 属性    Object.defineProperty(store.getters, key, &#123;      get: () =&gt; store._vm[key],      enumerable: true // for local getters    &#125;)  &#125;)  const silent = Vue.config.silent  Vue.config.silent = true  // 创建Vue实例来保存state，同时让state变成响应式  // store._vm._data.$$state = store.state  store._vm = new Vue(&#123;    data: &#123;      $$state: state    &#125;,    computed  &#125;)  Vue.config.silent = silent  // 只能通过commit方式更改状态  if (store.strict) &#123;    enableStrictMode(store)  &#125;&#125;</code></pre><p>从上面源码，我们可以看出Vuex的state状态是响应式，是借助vue的data是响应式，将state存入vue实例组件的data中；Vuex的getters则是借助vue的计算属性computed实现数据实时监听。</p><p>computed计算属性监听data数据变更主要经历以下几个过程：</p><p><img src="https://pic3.zhimg.com/80/v2-2730644102b66eef140110b814a90496_720w.jpg" alt="img"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>Vuex是通过全局注入store对象，来实现组件间的状态共享。在大型复杂的项目中（多级组件嵌套），需要实现一个组件更改某个数据，多个组件自动获取更改后的数据进行业务逻辑处理，这时候使用vuex比较合适。假如只是多个组件间传递数据，使用vuex未免有点大材小用，其实只用使用组件间常用的通信方法即可。</p><p>Vue组件简单常用的通信方式有以下几种：</p><p>1、父子通信：</p><p>父向子传值，通过props；子向父传值通过events ($emit)；父调用子方法通过ref；provide / inject。</p><p>2、兄弟通信：bus</p><p>3、跨级嵌套通信：bus；provide / inject等。</p><hr><p>文章来源:<a href="https://zhuanlan.zhihu.com/p/78981485">知乎平台慕课网文章:Vuex从使用到原理解析</a></p><p>扩展阅读:<a href="https://www.zhihu.com/question/400812435">为什么vuex不直接挂载到vue原型链上而是使用mixin?</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6-Promise相关</title>
      <link href="/2021/03/11/%E5%89%8D%E7%AB%AF/es6/es6-Promise%E7%9B%B8%E5%85%B3/"/>
      <url>/2021/03/11/%E5%89%8D%E7%AB%AF/es6/es6-Promise%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Promise 对象代表了未来将要发生的事件，用来传递异步操作的消息。</p><span id="more"></span><h2 id="一、Promise-基本特性"><a href="#一、Promise-基本特性" class="headerlink" title="一、Promise 基本特性"></a>一、Promise 基本特性</h2><ol><li><p> Promise 有三种状态：<strong>pending</strong> (进行中)，fulfilled(<strong>resolve</strong>) (已成功)，<strong>rejected</strong> (已失败)</p></li><li><p> Promise 对象接受一个回调函数作为参数，该回调函数接受两个参数，分别是成功时的回调 resolve 和 失败时的回调 reject；另外 resolve 的参数除了正常值以外，还可能是一个 Promise 对象的实例；reject 的参数通常是一个 Error 对象的实例</p></li><li><p> then 方法返回一个新的 Promise 实例，并接受两个参数 onResolved ( fulfilled 状态的回调)，onRejected ( rejected 状态的回调，该参数可选)</p></li><li><p> catch 方法返回一个新的 Promise 实例</p></li><li><p> finally 方法不管 Promise 状态如何都会执行，该方法的回调函数不接受任何参数</p></li><li><p> <strong>Promise.all()</strong> 方法将多个 Promise 实例包装成一个新的 Promise 实例，该方法接受一个由 Promise 对象组成的数组作为参数 （Promise.all() 方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例），注意参数中只要有一个实例触发 catch 方法，都会触发 Promise.all() 方法返回的新实例的 catch 方法，如果参数中的某个实例本身调用了 catch 方法，将不会触发 Promise.all() 方法返回的新实例的 catch 方法</p></li><li><p> Promise.race() 方法的参数与 Promise.all() 方法一样，参数中的实例只要有一个率先改变状态就会将该实例的状态传给 Promise.race() 方法，并将返回值作为 Promise.race() 方法产生的 Promise 实例的返回值</p></li><li><p> Promise.resolve() 将现有对象转为 Promise 对象，如果该方法的参数为一个 Promise 对象，Promise.resolve() 将不做任何处理；如果参数是 thenable 对象（即具有 then 方法），Promise.resolve() 方法将该对象转为 Promise 对象并立即执行 then 方法；如果参数是一个原始值，或者是一个不具有 then 方法的对象，则 Promise.resolve() 返回一个新的 Promise 对象，状态为 fulfilled，其参数将作为 then 方法中 onResolved 回调函数的参数。如果 Promise.resolve() 方法不传入参数，会直接返回一个 fulfilled 状态的 Promise 对象。需要注意的是，立即 resolve() 的 Promise 对象，是在本轮“事件循环（event loop）”结束时执行，而不是在下一轮“事件循环”的开始时执行</p></li><li><p> Promise.reject() 同样返回一个新的 Promise 对象，状态为 rejected，无论传入任何参数都将作为 reject() 的参数</p></li></ol><h2 id="二、Promise-的优点"><a href="#二、Promise-的优点" class="headerlink" title="二、Promise 的优点"></a>二、Promise 的优点</h2><ol><li><p>统一的异步 API</p><p>Promise 的一个重要优点是它将逐渐被用作浏览器的异步 API ，统一现在各种各样的 API ，以及不兼容的模式和写法。</p></li><li><p>Promise 与事件对比</p><p>和事件相比较，Promise 更适合处理一次性的结果，在结果计算出来之前或之后注册回调函数都是可以的，都可以拿到正确的值。Promise 的这个优点很自然。但是，不能使用 Promise 处理多次触发的事件。链式处理是 Promise 的又一优点，但是事件却不能这样链式处理。</p></li><li><p>Promise 和回调对比</p><p>解决了回调地狱的问题，将异步操作以同步操作的流程表达出来。</p></li><li><p>Promise 带来的额外的好处是包含了更好的错误处理方式（包含了异常处理），并且写起来很轻松（因为可以重用一些同步工具，比如 Array.prototype.map()）。</p></li></ol><h2 id="三、Promise-的缺点"><a href="#三、Promise-的缺点" class="headerlink" title="三、Promise 的缺点"></a>三、Promise 的缺点</h2><ol><li><p>无法取消 Promise，一旦新建它就会立即执行，无法中途取消。</p></li><li><p>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</p></li><li><p>当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p></li><li><p>Promise 真正执行回调的时候，定义 Promise 那部分实际上已经执行完了，所以 Promise 的报错堆栈上下文不太友好</p></li></ol><h2 id="四、简单代码实现"><a href="#四、简单代码实现" class="headerlink" title="四、简单代码实现."></a>四、简单代码实现.</h2><p>最简单的 Promise 实现有 7 个主要属性，state(状态），value(成功返回值），reason(错误信息)，resolve 方法，reject 方法，then 方法。</p><h3 id="class版"><a href="#class版" class="headerlink" title="class版"></a>class版</h3><pre><code class="javascript">class Promise&#123;    constructor(executor)&#123;        this.state = &#39;pending&#39;;        this.value = undefined;        this.reason = undefined;        let resolve = value=&gt;&#123;            if(this.state === &#39;pending&#39;)&#123;                this.state = &#39;fulfilled&#39;;                this.value = value;            &#125;        &#125;;        let reject = value=&gt;&#123;            if(this.state === &#39;pending&#39;)&#123;                this.state = &#39;rejected&#39;;                this.reason = value;            &#125;        &#125;;        try&#123;            //立即执行函数            executor(resolve,reject);        &#125;catch(err)&#123;            reject(err);        &#125;    &#125;    then(onFulfilled,onRejected)&#123;        if(this.state === &#39;fulfilled&#39;)&#123;            typeof onFulfilled === &#39;function&#39; &amp;&amp; onFulfilled(this.value);        &#125;;        if(this.state === &#39;rejected&#39;)&#123;            typeof onRejected === &#39;function&#39; &amp;&amp; onRejected(this.reason);        &#125;;    &#125;    &#125;</code></pre><h3 id="function版"><a href="#function版" class="headerlink" title="function版"></a>function版</h3><pre><code class="javascript">function myPromise(constructor)&#123; let self=this;  self.status=&quot;pending&quot; //定义状态改变前的初始状态   self.value=undefined;//定义状态为resolved的时候的状态   self.reason=undefined;//定义状态为rejected的时候的状态   function resolve(value)&#123;    //两个===&quot;pending&quot;，保证了了状态的改变是不不可逆的     if(self.status===&quot;pending&quot;)&#123;      self.value=value;      self.status=&quot;resolved&quot;;     &#125;  &#125;  function reject(reason)&#123;     //两个===&quot;pending&quot;，保证了了状态的改变是不不可逆的     if(self.status===&quot;pending&quot;)&#123;        self.reason=reason;        self.status=&quot;rejected&quot;;       &#125;  &#125;  //捕获构造异常   try&#123;      constructor(resolve,reject);  &#125;catch(e)&#123;    reject(e);    &#125; &#125;myPromise.prototype.then=function(onFullfilled,onRejected)&#123;   let self=this;  switch(self.status)&#123;    case &quot;resolved&quot;: onFullfilled(self.value); break;    case &quot;rejected&quot;: onRejected(self.reason); break;    default:   &#125;&#125;// 测试var p=new myPromise(function(resolve,reject)&#123;resolve(1)&#125;); p.then(function(x)&#123;console.log(x)&#125;)//输出1</code></pre><p>测试：</p><pre><code class="JavaScript">m = new Promise(resolve=&gt;&#123;    console.log(&#39;aaa&#39;)    setTimeout(function()&#123;        resolve(9000)    &#125;, 2000)&#125;)m.then(res=&gt;console.log(res));//执行</code></pre><p>运行起来我们发现只打印了构造函数中的 aaa 而 异步 then  方法并没有执行。</p><p><img src="https://img-blog.csdnimg.cn/20201216161028331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01GV1NDUQ==,size_16,color_FFFFFF,t_70"></p><p>当then里面函数运行时，resolve由于是异步执行的，还没有来得及修改state，此时还是PENDING状态；因此我们需要对异步的情况做一下处理。</p><h3 id="class进阶版"><a href="#class进阶版" class="headerlink" title="class进阶版"></a>class进阶版</h3><pre><code class="JavaScript">class Promise&#123;    constructor(executor)&#123;        this.state = &#39;pending&#39;;        this.value = undefined;        this.reason = undefined;        this.onFulfilled = [];        this.onRejected = [];         try&#123;            executor(this.resolve,this.reject);        &#125;catch(e)&#123;            this.reject(e);        &#125;            &#125;    resolve = (res)=&gt;&#123;        if(this.state === &#39;pending&#39;)&#123;            this.state = &#39;fulfilled&#39;;            this.value = res;            this.onFulfilled.forEach(fn=&gt;fn(res));        &#125;    &#125;     reject = (res)=&gt;&#123;        if(this.state === &#39;pending&#39;)&#123;            this.state = &#39;rejected&#39;;            this.reason = res;            this.onRejected.forEach(fn=&gt;fn(res));        &#125;    &#125;     then = (onFulfilled,onRejected)=&gt;&#123;        if(this.state === &#39;fulfilled&#39;)&#123;            typeof onFulfilled === &#39;function&#39; &amp;&amp; onFulfilled(this.value);        &#125;        if(this.state === &#39;rejected&#39;)&#123;            typeof onRejected === &#39;function&#39; &amp;&amp; onRejected(this.value);        &#125;        if(this.state === &#39;pending&#39;)&#123;            typeof onFulfilled === &#39;function&#39; &amp;&amp; this.onFulfilled.push(onFulfilled);            typeof onRejected === &#39;function&#39; &amp;&amp; this.onRejected.push(onRejected);        &#125;    &#125;&#125;</code></pre><h3 id="function进阶版"><a href="#function进阶版" class="headerlink" title="function进阶版"></a>function进阶版</h3><pre><code class="JavaScript">const PENDING = &quot;pending&quot;; const FULFILLED = &quot;fulfilled&quot;; const REJECTED = &quot;rejected&quot;;function Promise(excutor) &#123;  let that = this; // 缓存当前promise实例例对象  that.status = PENDING; // 初始状态  that.value = undefined; // fulfilled状态时 返回的信息  that.reason = undefined; // rejected状态时 拒绝的原因   that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数  that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数  function resolve(value) &#123; // value成功态时接收的终值    if(value instanceof Promise) &#123;      return value.then(resolve, reject);    &#125;    // 实践中要确保 onFulfilled 和 onRejected ⽅方法异步执⾏行行，且应该在 then ⽅方法被调⽤用的那⼀一轮事件循环之后的新执⾏行行栈中执⾏行行。    setTimeout(() =&gt; &#123;      // 调⽤用resolve 回调对应onFulfilled函数      if (that.status === PENDING) &#123;        // 只能由pending状态 =&gt; fulfilled状态 (避免调⽤用多次resolve reject)        that.status = FULFILLED;        that.value = value;        that.onFulfilledCallbacks.forEach(cb =&gt; cb(that.value));      &#125;    &#125;);  &#125;  function reject(reason) &#123; // reason失败态时接收的拒因    setTimeout(() =&gt; &#123;      // 调⽤用reject 回调对应onRejected函数      if (that.status === PENDING) &#123;        // 只能由pending状态 =&gt; rejected状态 (避免调⽤用多次resolve reject)        that.status = REJECTED;        that.reason = reason;        that.onRejectedCallbacks.forEach(cb =&gt; cb(that.reason));      &#125;    &#125;);  &#125;  // 捕获在excutor执⾏行行器器中抛出的异常  // new Promise((resolve, reject) =&gt; &#123;  //     throw new Error(&#39;error in excutor&#39;)  // &#125;)  try &#123;    excutor(resolve, reject);  &#125; catch (e) &#123;    reject(e);  &#125;&#125;Promise.prototype.then = function(onFulfilled, onRejected) &#123;  const that = this;  let newPromise;  // 处理理参数默认值 保证参数后续能够继续执⾏行行  onFulfilled = typeof onFulfilled === &quot;function&quot; ? onFulfilled : value =&gt; value;  onRejected = typeof onRejected === &quot;function&quot; ? onRejected : reason =&gt; &#123;    throw reason;  &#125;;  if (that.status === FULFILLED) &#123; // 成功态    return newPromise = new Promise((resolve, reject) =&gt; &#123;      setTimeout(() =&gt; &#123;        try&#123;          let x = onFulfilled(that.value);          resolvePromise(newPromise, x, resolve, reject); //新的promise resolve 上⼀一个onFulfilled的返回值        &#125; catch(e) &#123;          reject(e); // 捕获前⾯面onFulfilled中抛出的异常then(onFulfilled, onRejected);        &#125;      &#125;);    &#125;)  &#125;  if (that.status === REJECTED) &#123; // 失败态    return newPromise = new Promise((resolve, reject) =&gt; &#123;      setTimeout(() =&gt; &#123;        try &#123;          let x = onRejected(that.reason);          resolvePromise(newPromise, x, resolve, reject);        &#125; catch(e) &#123;          reject(e);        &#125;      &#125;);    &#125;);  &#125;  if (that.status === PENDING) &#123; // 等待态// 当异步调⽤用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中    return newPromise = new Promise((resolve, reject) =&gt; &#123;      that.onFulfilledCallbacks.push((value) =&gt; &#123;        try &#123;          let x = onFulfilled(value);          resolvePromise(newPromise, x, resolve, reject);        &#125; catch(e) &#123;          reject(e);        &#125;      &#125;);      that.onRejectedCallbacks.push((reason) =&gt; &#123;        try &#123;          let x = onRejected(reason);          resolvePromise(newPromise, x, resolve, reject);        &#125; catch(e) &#123;          reject(e);        &#125;      &#125;);    &#125;);  &#125;&#125;;</code></pre><hr><p>参考文档:<a href="https://blog.csdn.net/MFWSCQ/article/details/108382519">CSDN文章: Promise 的特性、优缺点，内部是如何实现的，动手实现 Promise</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-路由两种模式及其区别</title>
      <link href="/2021/03/03/%E5%89%8D%E7%AB%AF/vue/vue-%E8%B7%AF%E7%94%B1%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/03/03/%E5%89%8D%E7%AB%AF/vue/vue-%E8%B7%AF%E7%94%B1%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>vue-router 有 3 种路由模式：hash、history、abstract。</p><span id="more"></span><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><h3 id="1-hash模式：hash-hashChange"><a href="#1-hash模式：hash-hashChange" class="headerlink" title="1) hash模式：hash + hashChange"></a>1) hash模式：hash + hashChange</h3><p>特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。通过监听 hash（#）的变化来执行js代码 从而实现 页面的改变。 </p><p>核心代码：</p><pre><code class="javascript">window.addEventListener(‘hashchange‘,function()&#123;  self.urlChange()&#125;)</code></pre><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ol><li><p>hash 虽然出现在 url 中，但不会被包括在 http 请求中，它是用来指导浏览器动作的，对服务器端完全无用，因此，改变 hash 不会重新加载页面。</p></li><li><p>可以为 hash 的改变添加监听事件：</p><pre><code class="javascript">window.addEventListener(&quot;hashchange&quot;,funcRef,false)</code></pre></li><li><p>每一次改变 hash(window.localtion.hash)，都会在浏览器访问历史中增加一个记录。</p><p>利用 hash 的以上特点，就可以来实现前端路由”更新视图但不重新请求页面”的功能了。</p><p><strong>HashHistory</strong> 拥有两个方法，一个是 <strong>push</strong>， 一个是 <strong>replace</strong></p><p>即：<strong>HashHistory.push()</strong> 和 <strong>HashHistory.replace()</strong></p></li></ol><h3 id="2-history模式：historyApi-popState"><a href="#2-history模式：historyApi-popState" class="headerlink" title="2) history模式：historyApi + popState"></a>2) history模式：historyApi + popState</h3><p>HTML5推出的history API，由pushState()记录操作历史，监听popstate事件来监听到状态变更；</p><p>因为 只要刷新 这个url（<a href="http://www.ff.ff/jjkj/fdfd/fdf/fd%EF%BC%89%E5%B0%B1%E4%BC%9A%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E7%84%B6%E8%80%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%A0%B9%E6%9C%AC%E6%B2%A1%E6%9C%89%E8%BF%99%E4%B8%AA%E8%B5%84%E6%BA%90%EF%BC%8C%E6%89%80%E4%BB%A5%E5%B0%B1%E4%BC%9A%E6%8A%A5404%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%B0%B1">www.ff.ff/jjkj/fdfd/fdf/fd）就会请求服务器，然而服务器上根本没有这个资源，所以就会报404，解决方案就</a> 配置一下服务器端。</p><p>　<strong>History interface</strong> 是浏览器历史记录栈提供的接口，通过back()、forward()、go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。</p><p>　从 HTML5开始，<strong>History interface</strong> 提供了2个新的方法：pushState()、replaceState() 使得我们可以对浏览器历史记录栈进行修改：</p><pre><code class="JavaScript">　　window.history.pushState(stateObject,title,url)　　window.history,replaceState(stateObject,title,url)</code></pre><p>​        stateObject：当浏览器跳转到新的状态时，将触发 Popstate 事件，该事件将携带这个 stateObject 参数的副本</p><p>　　　　title：所添加记录的标题</p><p>　　　　  url：所添加记录的 url``</p><p>　　　　这<code>2</code>个方法有个共同的特点：当调用他们修改浏览器历史栈后，虽然当前<code>url</code>改变了，但浏览器不会立即发送请求该<code>url</code>，这就为单页应用前端路由，更新视图但不重新请求页面提供了基础</p><ol><li><p>push</p><p> 与hash模式类似，只是将window.hash改为history.pushState</p></li><li><p>replace</p><p>与hash模式类似，只是将window.replace改为history.replaceState</p></li><li><p>监听地址变化</p><p>在HTML5History的构造函数中监听popState（window.onpopstate）</p></li></ol><p>说明：</p><ol><li><p>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</p></li><li><p>history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</p></li><li><p>abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</p></li></ol><hr><p>参考文档:<a href="https://www.cnblogs.com/gaosirs/p/10606266.html">博客园文章:Vue Router 路由实现原理</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-New一个函数和直接调用的区别</title>
      <link href="/2021/03/03/%E5%89%8D%E7%AB%AF/JavaScript/js-New%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%92%8C%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/03/03/%E5%89%8D%E7%AB%AF/JavaScript/js-New%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%92%8C%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用New是构造函数，不使用New是函数调用，同时this指向不同。</p><span id="more"></span><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><pre><code class="javascript">function Test(name, age, job) &#123;　　console.log(this);　　this.name = name;　　this.age = age;　　this.job = job;&#125;</code></pre><p>1、直接调用函数</p><pre><code class="javascript">var test1 = Test(&#39;Tom&#39;, 27, &#39;IT&#39;);//来看下test1的值：console.log(test1); // undefined</code></pre><p>　　<strong>直接调用上下文指向是window</strong></p><p>2、使用new构造函数</p><pre><code class="javascript">　　var test2 = new Test(&#39;Tom&#39;, 27, &#39;IT&#39;);　　//来看下test2的值：　　console.log(test2); 　　console.log(typeof test2); // &quot;object&quot;</code></pre><p>​    <strong>new会使执行函数的上下文指向这个函数的本身。</strong></p><p>最后得出一个猜测：</p><p><strong>如果函数返回值为常规意义上的值类型（Number、String、Boolean）时，new 函数将会返回一个该函数的实例对象，而如果函数返回一个引用类型（Object、Array、Function），虽然new函数与直接调用函数产生的结果等同，但是是两个不同的过程，一个是构造对象、一个是函数调用。</strong></p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>构造函数不需要显示的返回值。使用new来创建对象(调用构造函数)时，如果return的是非对象(数字、字符串、布尔类型等)会忽而略返回值;如果return的是对象，则返回该对象。</p><p>下面简单介绍下，javascript中new对象的过程：如var myObj = newPerson(“aty”,25);</p><ol><li><p>创建一个空的Object对象.var obj = new Object();</p></li><li><p>将构造函数Person中this指向刚创建的obj对象</p></li><li><p>将创建的obj的__proto__指向构造函数Person的prototype。这一步是建立对象和原型直接的对应关系。firefox下通过对象的__proto__属性能够访问到原型，IE下则没有暴露出相应的属性。</p></li><li><p>执行构造函数Person()中的代码</p></li></ol><hr><p>参考文档:<a href="https://www.cnblogs.com/hyshi/p/10901211.html">博客园文章js New一个函数和直接调用的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-防抖和节流</title>
      <link href="/2021/03/02/%E5%89%8D%E7%AB%AF/JavaScript/js-%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
      <url>/2021/03/02/%E5%89%8D%E7%AB%AF/JavaScript/js-%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。</p><span id="more"></span><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h4 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h4><p>函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210525170552.jpeg" alt="img"></p><p>一起来实现个简单的debounce~</p><p>防抖debounce代码：</p><pre><code>// 防抖function debounce(fn, wait) &#123;        var timeout = null;        return function() &#123;                if(timeout !== null)   clearTimeout(timeout);                timeout = setTimeout(fn, wait);        &#125;&#125;// 处理函数function handle() &#123;        console.log(Math.random()); &#125;// 滚动事件window.addEventListener(&#39;scroll&#39;, debounce(handle, 1000));</code></pre><p>当持续触发scroll事件时，事件处理函数handle只在停止滚动1000毫秒之后才会调用一次，也就是说在持续触发scroll事件的过程中，事件处理函数handle一直没有执行。</p><h4 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h4><p>函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下图，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210525170600.jpeg" alt="img"></p><p>函数节流主要有两种实现方法：时间戳和定时器。接下来分别用两种方法实现throttle~</p><p>节流throttle代码（时间戳）：</p><pre><code>var throttle = function(func, delay) &#123;            　　var prev = Date.now();            　　return function() &#123;                　　　　var context = this;                　　　　var args = arguments;                　　　　var now = Date.now();                　　　　if (now - prev &gt;= delay) &#123;                    　　　　　　func.apply(context, args);                    　　　　　　prev = Date.now();                　　　　&#125;            　　&#125;        &#125;        function handle() &#123;            　　console.log(Math.random());        &#125;        window.addEventListener(&#39;scroll&#39;, throttle(handle, 1000));</code></pre><p>当高频事件触发时，第一次会立即执行（给scroll事件绑定函数与真正触发事件的间隔一般大于delay，如果你非要在网页加载1000毫秒以内就去滚动网页的话，我也没办法o(╥﹏╥)o），而后再怎么频繁地触发事件，也都是每delay时间才执行一次。而当最后一次事件触发完毕后，事件也不会再被执行了 （最后一次触发事件与倒数第二次触发事件的间隔小于delay，为什么小于呢？因为大于就不叫高频了呀(<em>╹▽╹</em>)）。</p><p>节流throttle代码（定时器）：</p><pre><code>// 节流throttle代码（定时器）：var throttle = function(func, delay) &#123;                var timer = null;                return function() &#123;                        var context = this;                       var args = arguments;                        if (!timer) &#123;                                timer = setTimeout(function() &#123;                                        func.apply(context, args);                                        timer = null;                                &#125;, delay);                        &#125;                &#125;        &#125;        function handle() &#123;                console.log(Math.random());        &#125;        window.addEventListener(&#39;scroll&#39;, throttle(handle, 1000));</code></pre><pre><code class="javascript">//简单实现function throttle(fn,delay)&#123;    let valid = true    return function() &#123;       if(!valid)&#123;           //休息时间 暂不接客           return false        &#125;       // 工作时间，执行函数并且在间隔期内把状态位设为无效        valid = false        setTimeout(() =&gt; &#123;            fn()            valid = true;        &#125;, delay)    &#125;&#125;</code></pre><p>当触发事件的时候，我们设置一个定时器，再次触发事件的时候，如果定时器存在，就不执行，直到delay时间后，定时器执行执行函数，并且清空定时器，这样就可以设置下个定时器。当第一次触发事件时，不会立即执行函数，而是在delay秒后才执行。而后再怎么频繁触发事件，也都是每delay时间才执行一次。当最后一次停止触发后，由于定时器的delay延迟，可能还会执行一次函数。</p><p>节流中用时间戳或定时器都是可以的。更精确地，可以用时间戳+定时器，当第一次触发事件时马上执行事件处理函数，最后一次触发事件后也还会执行一次事件处理函数。</p><p>节流throttle代码（时间戳+定时器）：</p><pre><code class="javascript">// 节流throttle代码（时间戳+定时器）：var throttle = function(func, delay) &#123;         var timer = null;         var startTime = Date.now();         return function() &#123;                     var curTime = Date.now();                     var remaining = delay - (curTime - startTime);                     var context = this;                     var args = arguments;                     clearTimeout(timer);                      if (remaining &lt;= 0) &#123;                                func.apply(context, args);                                startTime = Date.now();                      &#125; else &#123;                                timer = setTimeout(func, remaining);                      &#125;          &#125;&#125;function handle() &#123;          console.log(Math.random());&#125; window.addEventListener(&#39;scroll&#39;, throttle(handle, 1000));</code></pre><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><pre><code class="javascript">(function () &#123;    const clearTimer = function clearTimer(timer) &#123;        if (timer) &#123;            clearTimeout(timer);        &#125;        return null;    &#125;;    const debounce = function debounce(func, wait, immediate) &#123;        if (typeof func !== &#39;function&#39;) throw new TypeError(`func must be an function`);        if (typeof wait === &#39;boolean&#39;) immediate = wait;        if (typeof wait !== &#39;number&#39;) wait = 500;        if (typeof immediate !== &#39;boolean&#39;) immediate = false;        let timer = null;        return function operate(...params) &#123;            let now = !timer &amp;&amp; immediate,                result;            timer = clearTimer(timer);            timer = setTimeout(() =&gt; &#123;                timer = clearTimer(timer);                if (!immediate) func.call(this, ...params);            &#125;, wait);            if (now) result = func.call(this, ...params);            return result;        &#125;;    &#125;;    const throttle = function throttle(func, wait) &#123;        if (typeof func !== &#39;function&#39;) throw new TypeError(`func must be an function`);        if (typeof wait !== &#39;number&#39;) wait = 500;        let timer = null,            previous = 0;        return function operate(...params) &#123;            let remaining = wait - (+new Date() - previous),                result;            if (remaining &lt;= 0) &#123;                timer = clearTimer(timer);                result = func.call(this, ...params);                previous = +new Date();                return result;            &#125;            if (!timer) &#123;                timer = setTimeout(() =&gt; &#123;                    timer = clearTimer(timer);                    func.call(this, ...params);                    previous = +new Date();                &#125;, remaining);            &#125;        &#125;;    &#125;;    /* 暴露API */    let utils = &#123;        debounce,        throttle    &#125;;    if (typeof define === &quot;function&quot; &amp;&amp; define.amd) define(&quot;utils&quot;, [], () =&gt; utils);    if (typeof module === &quot;object&quot; &amp;&amp; typeof module.exports === &quot;object&quot;) module.exports = utils;    if (typeof window !== &#39;undefined&#39;) window.utils = utils;&#125;)();</code></pre><p>在节流函数内部使用开始时间startTime、当前时间curTime与delay来计算剩余时间remaining，当remaining&lt;=0时表示该执行事件处理函数了（保证了第一次触发事件就能立即执行事件处理函数和每隔delay时间执行一次事件处理函数）。如果还没到时间的话就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处理函数）。当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重新计算一个remaining来判断当前状态。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。</p><p>函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。</p><p>区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。</p><hr><p>参考文档:<a href="https://www.cnblogs.com/momo798/p/9177767.html">博客园文章js防抖和节流:</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-computed和watch的区别</title>
      <link href="/2021/03/02/%E5%89%8D%E7%AB%AF/vue/vue-computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/03/02/%E5%89%8D%E7%AB%AF/vue/vue-computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>computed和watch都是观察页面的数据变化的。</p><span id="more"></span><h4 id="计算属性computed"><a href="#计算属性computed" class="headerlink" title="计算属性computed :"></a><strong>计算属性computed :</strong></h4><ol><li><p>支持缓存，只有依赖数据发生改变，才会重新进行计算</p></li><li><p>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</p></li><li><p>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</p></li><li><p>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</p></li><li><p>如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法</p></li></ol><h4 id="侦听属性watch："><a href="#侦听属性watch：" class="headerlink" title="侦听属性watch："></a><strong>侦听属性watch：</strong></h4><ol><li><p>不支持缓存，数据变，直接会触发相应的操作；</p></li><li><p>watch支持异步；</p></li><li><p>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</p></li><li><p>当一个属性发生变化时，需要执行对应的操作；一对多；</p></li><li><p>监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，</p></li></ol><p>　　immediate：组件加载立即触发回调函数执行，</p><p>　　deep: 深度监听，为了发现<strong>对象内部值</strong>的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-事件绑定原理</title>
      <link href="/2021/03/02/%E5%89%8D%E7%AB%AF/vue/vue-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/"/>
      <url>/2021/03/02/%E5%89%8D%E7%AB%AF/vue/vue-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Vue中通过v-on或其语法糖@指令来给元素绑定事件并且提供了事件修饰符</p><span id="more"></span><p><code>Vue</code>中通过<code>v-on</code>或其语法糖<code>@</code>指令来给元素绑定事件并且提供了事件修饰符，基本流程是进行模板编译生成<code>AST</code>，生成<code>render</code>函数后并执行得到<code>VNode</code>，<code>VNode</code>生成真实<code>DOM</code>节点或者组件时候使用<code>addEventListener</code>方法进行事件绑定。</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><code>v-on</code>与<code>@</code>用于绑定事件监听器，事件类型由参数指定，表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略，用在普通元素上时，只能监听原生<code>DOM</code>事件，用在自定义元素组件上时，也可以监听子组件触发的自定义事件，在监听原生<code>DOM</code>事件时，方法以事件为唯一的参数，如果使用内联语句，语句可以访问一个<code>$event property：v-on:click=&quot;handle(&#39;param&#39;, $event)&quot;</code>，自<code>2.4.0</code>开始<code>v-on</code>同样支持不带参数绑定一个事件或监听器键值对的对象，注意当使用对象语法时，是不支持任何修饰器的。</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul><li><code>.stop</code>: 调用<code>event.stopPropagation()</code>，即阻止事件冒泡。</li><li><code>.prevent</code>: 调用<code>event.preventDefault()</code>，即阻止默认事件。</li><li><code>.capture</code>: 添加事件侦听器时使用<code>capture</code>模式，即使用事件捕获模式处理事件。</li><li><code>.self</code>: 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li><li><code>.&#123;keyCode | keyAlias&#125;</code>: 只当事件是从特定键触发时才触发回调。</li><li><code>.native</code>: 监听组件根元素的原生事件，即注册组件根元素的原生事件而不是组件自定义事件的。</li><li><code>.once</code>: 只触发一次回调。</li><li><code>.left(2.2.0)</code>: 只当点击鼠标左键时触发。</li><li><code>.right(2.2.0)</code>: 只当点击鼠标右键时触发。</li><li><code>.middle(2.2.0)</code>: 只当点击鼠标中键时触发。</li><li><code>.passive(2.3.0)</code>: 以<code>&#123; passive: true &#125;</code>模式添加侦听器，表示<code>listener</code>永远不会调用<code>preventDefault()</code>。</li></ul><h3 id="普通元素"><a href="#普通元素" class="headerlink" title="普通元素"></a>普通元素</h3><pre><code class="html">&lt;!-- 方法处理器 --&gt;&lt;button v-on:click=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 动态事件 (2.6.0+) --&gt;&lt;button v-on:[event]=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 内联语句 --&gt;&lt;button v-on:click=&quot;doThat(&#39;param&#39;, $event)&quot;&gt;&lt;/button&gt;&lt;!-- 缩写 --&gt;&lt;button @click=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 动态事件缩写 (2.6.0+) --&gt;&lt;button @[event]=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 停止冒泡 --&gt;&lt;button @click.stop=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 阻止默认行为 --&gt;&lt;button @click.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 阻止默认行为，没有表达式 --&gt;&lt;form @submit.prevent&gt;&lt;/form&gt;&lt;!--  串联修饰符 --&gt;&lt;button @click.stop.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 键修饰符，键别名 --&gt;&lt;input @keyup.enter=&quot;onEnter&quot;&gt;&lt;!-- 键修饰符，键代码 --&gt;&lt;input @keyup.13=&quot;onEnter&quot;&gt;&lt;!-- 点击回调只会触发一次 --&gt;&lt;button v-on:click.once=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 对象语法 (2.4.0+) --&gt;&lt;button v-on=&quot;&#123; mousedown: doThis, mouseup: doThat &#125;&quot;&gt;&lt;/button&gt;</code></pre><h3 id="组件元素"><a href="#组件元素" class="headerlink" title="组件元素"></a>组件元素</h3><pre><code class="html">&lt;!-- 自定义事件 --&gt;&lt;my-component @my-event=&quot;handleThis&quot;&gt;&lt;/my-component&gt;&lt;!-- 内联语句 --&gt;&lt;my-component @my-event=&quot;handleThis(&#39;param&#39;, $event)&quot;&gt;&lt;/my-component&gt;&lt;!-- 组件中的原生事件 --&gt;&lt;my-component @click.native=&quot;onClick&quot;&gt;&lt;/my-component&gt;</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><code>Vue</code>源码的实现比较复杂，会处理各种兼容问题与异常以及各种条件分支，文章分析比较核心的代码部分，精简过后的版本，重要部分做出注释，<code>commit id</code>为<code>ef56410</code>。</p><h3 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h3><p><code>Vue</code>在挂载实例前，有相当多的工作是进行模板的编译，将<code>template</code>模板进行编译，解析成<code>AST</code>树，再转换成<code>render</code>函数，而在编译阶段，就是对事件的指令做收集处理。<br>在<code>template</code>模板中，定义事件的部分是属于<code>XML</code>的<code>Attribute</code>，所以收集指令时需要匹配<code>Attributes</code>以确定哪个<code>Attribute</code>是属于事件。</p><pre><code class="javascript">Copy// dev/src/compiler/parser/index.js line 23export const onRE = /^@|^v-on:/export const dirRE = process.env.VBIND_PROP_SHORTHAND  ? /^v-|^@|^:|^\.|^#/  : /^v-|^@|^:|^#/// ...const dynamicArgRE = /^\[.*\]$/// ...export const bindRE = /^:|^\.|^v-bind:/  // dev/src/compiler/parser/index.js line 757function processAttrs (el) &#123;  const list = el.attrsList  let i, l, name, rawName, value, modifiers, syncGen, isDynamic  for (i = 0, l = list.length; i &lt; l; i++) &#123;    name = rawName = list[i].name    value = list[i].value    if (dirRE.test(name)) &#123; // 匹配指令属性      // mark element as dynamic      el.hasBindings = true      // modifiers      modifiers = parseModifiers(name.replace(dirRE, &#39;&#39;)) // 将修饰符解析      // support .foo shorthand syntax for the .prop modifier      if (process.env.VBIND_PROP_SHORTHAND &amp;&amp; propBindRE.test(name)) &#123;        (modifiers || (modifiers = &#123;&#125;)).prop = true        name = `.` + name.slice(1).replace(modifierRE, &#39;&#39;)      &#125; else if (modifiers) &#123;        name = name.replace(modifierRE, &#39;&#39;)      &#125;      if (bindRE.test(name)) &#123; // v-bind // 处理v-bind的情况        // ...      &#125; else if (onRE.test(name)) &#123; // v-on // 处理事件绑定        name = name.replace(onRE, &#39;&#39;) // 将事件名匹配        isDynamic = dynamicArgRE.test(name) // 动态事件绑定        if (isDynamic) &#123; // 如果是动态事件          name = name.slice(1, -1) // 去掉两端的 []        &#125;        addHandler(el, name, value, modifiers, false, warn, list[i], isDynamic) // 处理事件收集      &#125; else &#123; // normal directives // 处理其他指令        // ...      &#125;    &#125; else &#123;      // literal attribute // 处理文字属性      // ...    &#125;  &#125;&#125;</code></pre><p>通过<code>addHandler</code>方法，为<code>AST</code>树添加事件相关的属性以及对事件修饰符进行处理。</p><pre><code class="javascript">// dev/src/compiler/helpers.js line 69export function addHandler (  el: ASTElement,  name: string,  value: string,  modifiers: ?ASTModifiers,  important?: boolean,  warn?: ?Function,  range?: Range,  dynamic?: boolean) &#123;  modifiers = modifiers || emptyObject  // passive 和 prevent 不能同时使用，具体是由passive模式的性质决定的  // 详细可以参阅 https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener  // warn prevent and passive modifier  /* istanbul ignore if */  if (    process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn &amp;&amp;    modifiers.prevent &amp;&amp; modifiers.passive  ) &#123;    warn(      &#39;passive and prevent can\&#39;t be used together. &#39; +      &#39;Passive handler can\&#39;t prevent default event.&#39;,      range    )  &#125;  // 标准化click.right和click.middle，因为它们实际上不会触发。  // 从技术上讲，这是特定于浏览器的，但是至少目前来说，浏览器是唯一具有右键/中间点击的目标环境。  // normalize click.right and click.middle since they don&#39;t actually fire  // this is technically browser-specific, but at least for now browsers are  // the only target envs that have right/middle clicks.  if (modifiers.right) &#123; // 将鼠标右键点击标准化 右键点击默认的是 contextmenu 事件    if (dynamic) &#123; // 如果是动态事件      name = `($&#123;name&#125;)===&#39;click&#39;?&#39;contextmenu&#39;:($&#123;name&#125;)` // 动态确定事件名    &#125; else if (name === &#39;click&#39;) &#123; // 如果不是动态事件且是鼠标右击      name = &#39;contextmenu&#39; // 则直接替换为contextmenu事件      delete modifiers.right // 删除modifiers的right属性    &#125;  &#125; else if (modifiers.middle) &#123; // 同样标准化处理鼠标中键点击的事件    if (dynamic) &#123; // 如果是动态事件      name = `($&#123;name&#125;)===&#39;click&#39;?&#39;mouseup&#39;:($&#123;name&#125;)` // 动态确定事件名    &#125; else if (name === &#39;click&#39;) &#123; // 如果不是动态事件且是鼠标中键点击      name = &#39;mouseup&#39; // 处理为mouseup事件    &#125;  &#125;  // 下面是对捕获、一次触发、passive模式的modifiers处理，主要是为事件添加 !、~、&amp; 标记  // 这一部分标记可以在Vue官方文档中查阅   // https://cn.vuejs.org/v2/guide/render-function.html#%E4%BA%8B%E4%BB%B6-amp-%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6  // check capture modifier  if (modifiers.capture) &#123;    delete modifiers.capture    name = prependModifierMarker(&#39;!&#39;, name, dynamic)  &#125;  if (modifiers.once) &#123;    delete modifiers.once    name = prependModifierMarker(&#39;~&#39;, name, dynamic)  &#125;  /* istanbul ignore if */  if (modifiers.passive) &#123;    delete modifiers.passive    name = prependModifierMarker(&#39;&amp;&#39;, name, dynamic)  &#125;    // events 用来记录绑定的事件  let events  if (modifiers.native) &#123; // 如果是要触发根元素原生事件则直接取得nativeEvents    delete modifiers.native    events = el.nativeEvents || (el.nativeEvents = &#123;&#125;)  &#125; else &#123; // 否则取得events    events = el.events || (el.events = &#123;&#125;)  &#125;      // 将事件处理函数作为handler  const newHandler: any = rangeSetItem(&#123; value: value.trim(), dynamic &#125;, range)  if (modifiers !== emptyObject) &#123;    newHandler.modifiers = modifiers  &#125; // 绑定的事件可以多个，回调也可以多个，最终会合并到数组中  const handlers = events[name]  /* istanbul ignore if */  if (Array.isArray(handlers)) &#123;    important ? handlers.unshift(newHandler) : handlers.push(newHandler)  &#125; else if (handlers) &#123;    events[name] = important ? [newHandler, handlers] : [handlers, newHandler]  &#125; else &#123;    events[name] = newHandler  &#125;  el.plain = false&#125;</code></pre><h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>接下来需要将<code>AST</code>语法树转<code>render</code>函数，在这个过程中会加入对事件的处理，首先模块导出了<code>generate</code>函数，<code>generate</code>函数即会返回<code>render</code>字符串，在这之前会调用<code>genElement</code>函数，而在上述<code>addHandler</code>方法处理的最后执行了<code>el.plain = false</code>，这样在<code>genElement</code>函数中会调用<code>genData</code>函数，而在<code>genData</code>函数中即会调用<code>genHandlers</code>函数。</p><pre><code class="javascript">// dev/src/compiler/codegen/index.js line 42export function generate (  ast: ASTElement | void,  options: CompilerOptions): CodegenResult &#123;  const state = new CodegenState(options)  const code = ast ? genElement(ast, state) : &#39;_c(&quot;div&quot;)&#39;  return &#123;    render: `with(this)&#123;return $&#123;code&#125;&#125;`, // 即render字符串    staticRenderFns: state.staticRenderFns  &#125;&#125;// dev/src/compiler/codegen/index.js line 55export function genElement (el: ASTElement, state: CodegenState): string &#123;    // ...    let code    if (el.component) &#123;      code = genComponent(el.component, el, state)    &#125; else &#123;      let data      if (!el.plain || (el.pre &amp;&amp; state.maybeComponent(el))) &#123;        data = genData(el, state)      &#125;      const children = el.inlineTemplate ? null : genChildren(el, state, true)      code = `_c(&#39;$&#123;el.tag&#125;&#39;$&#123;        data ? `,$&#123;data&#125;` : &#39;&#39; // data      &#125;$&#123;        children ? `,$&#123;children&#125;` : &#39;&#39; // children      &#125;)`    &#125;    // ...&#125;// dev/src/compiler/codegen/index.js line 219export function genData (el: ASTElement, state: CodegenState): string &#123;  let data = &#39;&#123;&#39;  // ...  // event handlers  if (el.events) &#123;    data += `$&#123;genHandlers(el.events, false)&#125;,`  &#125;  if (el.nativeEvents) &#123;    data += `$&#123;genHandlers(el.nativeEvents, true)&#125;,`  &#125;  // ...  data = data.replace(/,$/, &#39;&#39;) + &#39;&#125;&#39;  // ...  return data&#125;// dev/src/compiler/to-function.js line 12 function createFunction (code, errors) &#123;  try &#123;    return new Function(code) // 将render字符串转为render函数  &#125; catch (err) &#123;    errors.push(&#123; err, code &#125;)    return noop  &#125;&#125;</code></pre><p>可以看到无论是处理普通元素事件还是组件根元素原生事件都会调用<code>genHandlers</code>函数，<code>genHandlers</code>函数即会遍历解析好的<code>AST</code>树中事件属性，拿到<code>event</code>对象属性，并根据属性上的事件对象拼接成字符串。</p><pre><code class="javascript">// dev/src/compiler/codegen/events.js line 3const fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=&gt;|^function(?:\s+[\w$]+)?\s*\(/const fnInvokeRE = /\([^)]*?\);*$/const simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\[&#39;[^&#39;]*?&#39;]|\[&quot;[^&quot;]*?&quot;]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/// dev/src/compiler/codegen/events.js line 7// KeyboardEvent.keyCode aliasesconst keyCodes: &#123; [key: string]: number | Array&lt;number&gt; &#125; = &#123;  esc: 27,  tab: 9,  enter: 13,  space: 32,  up: 38,  left: 37,  right: 39,  down: 40,  &#39;delete&#39;: [8, 46]&#125;// KeyboardEvent.key aliasesconst keyNames: &#123; [key: string]: string | Array&lt;string&gt; &#125; = &#123;  // #7880: IE11 and Edge use `Esc` for Escape key name.  esc: [&#39;Esc&#39;, &#39;Escape&#39;],  tab: &#39;Tab&#39;,  enter: &#39;Enter&#39;,  // #9112: IE11 uses `Spacebar` for Space key name.  space: [&#39; &#39;, &#39;Spacebar&#39;],  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.  up: [&#39;Up&#39;, &#39;ArrowUp&#39;],  left: [&#39;Left&#39;, &#39;ArrowLeft&#39;],  right: [&#39;Right&#39;, &#39;ArrowRight&#39;],  down: [&#39;Down&#39;, &#39;ArrowDown&#39;],  // #9112: IE11 uses `Del` for Delete key name.  &#39;delete&#39;: [&#39;Backspace&#39;, &#39;Delete&#39;, &#39;Del&#39;]&#125;&#125;// dev/src/compiler/codegen/events.js line 37// #4868: modifiers that prevent the execution of the listener// need to explicitly return null so that we can determine whether to remove// the listener for .onceconst genGuard = condition =&gt; `if($&#123;condition&#125;)return null;`const modifierCode: &#123; [key: string]: string &#125; = &#123;  stop: &#39;$event.stopPropagation();&#39;,  prevent: &#39;$event.preventDefault();&#39;,  self: genGuard(`$event.target !== $event.currentTarget`),  ctrl: genGuard(`!$event.ctrlKey`),  shift: genGuard(`!$event.shiftKey`),  alt: genGuard(`!$event.altKey`),  meta: genGuard(`!$event.metaKey`),  left: genGuard(`&#39;button&#39; in $event &amp;&amp; $event.button !== 0`),  middle: genGuard(`&#39;button&#39; in $event &amp;&amp; $event.button !== 1`),  right: genGuard(`&#39;button&#39; in $event &amp;&amp; $event.button !== 2`)&#125;// dev/src/compiler/codegen/events.js line 55export function genHandlers (  events: ASTElementHandlers,  isNative: boolean): string &#123;  const prefix = isNative ? &#39;nativeOn:&#39; : &#39;on:&#39;  let staticHandlers = ``  let dynamicHandlers = ``  for (const name in events) &#123; // 遍历AST解析后的事件属性    const handlerCode = genHandler(events[name]) // 将事件对象转换成可拼接的字符串    if (events[name] &amp;&amp; events[name].dynamic) &#123;      dynamicHandlers += `$&#123;name&#125;,$&#123;handlerCode&#125;,`    &#125; else &#123;      staticHandlers += `&quot;$&#123;name&#125;&quot;:$&#123;handlerCode&#125;,`    &#125;  &#125;  staticHandlers = `&#123;$&#123;staticHandlers.slice(0, -1)&#125;&#125;`  if (dynamicHandlers) &#123;    return prefix + `_d($&#123;staticHandlers&#125;,[$&#123;dynamicHandlers.slice(0, -1)&#125;])`  &#125; else &#123;    return prefix + staticHandlers  &#125;&#125;// dev/src/compiler/codegen/events.js line 96function genHandler (handler: ASTElementHandler | Array&lt;ASTElementHandler&gt;): string &#123;  if (!handler) &#123;    return &#39;function()&#123;&#125;&#39;  &#125;  // 事件绑定可以多个，多个在解析AST树时会以数组的形式存在，如果有多个则会递归调用getHandler方法返回数组。  if (Array.isArray(handler)) &#123;    return `[$&#123;handler.map(handler =&gt; genHandler(handler)).join(&#39;,&#39;)&#125;]`  &#125;  const isMethodPath = simplePathRE.test(handler.value) // 调用方法为 doThis 型  const isFunctionExpression = fnExpRE.test(handler.value) // 调用方法为 () =&gt; &#123;&#125; or function() &#123;&#125; 型  const isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, &#39;&#39;)) // 调用方法为 doThis($event) 型  if (!handler.modifiers) &#123; // 没有修饰符    if (isMethodPath || isFunctionExpression) &#123; // 符合这两个条件则直接返回      return handler.value    &#125;    /* istanbul ignore if */    if (__WEEX__ &amp;&amp; handler.params) &#123;      return genWeexHandler(handler.params, handler.value)    &#125;    return `function($event)&#123;$&#123; // 返回拼接的匿名函数的字符串      isFunctionInvocation ? `return $&#123;handler.value&#125;` : handler.value    &#125;&#125;` // inline statement  &#125; else &#123; // 处理具有修饰符的情况    let code = &#39;&#39;    let genModifierCode = &#39;&#39;    const keys = []    for (const key in handler.modifiers) &#123;  // 遍历modifiers上记录的修饰符      if (modifierCode[key]) &#123;        genModifierCode += modifierCode[key]  // 根据修饰符添加对应js的代码        // left/right        if (keyCodes[key]) &#123;          keys.push(key)        &#125;      &#125; else if (key === &#39;exact&#39;) &#123; // 针对exact的处理        const modifiers: ASTModifiers = (handler.modifiers: any)        genModifierCode += genGuard(          [&#39;ctrl&#39;, &#39;shift&#39;, &#39;alt&#39;, &#39;meta&#39;]            .filter(keyModifier =&gt; !modifiers[keyModifier])            .map(keyModifier =&gt; `$event.$&#123;keyModifier&#125;Key`)            .join(&#39;||&#39;)        )      &#125; else &#123;        keys.push(key) // 如果修饰符不是以上修饰符，则会添加到keys数组中      &#125;    &#125;    if (keys.length) &#123;      code += genKeyFilter(keys) // 处理其他修饰符 即keyCodes中定义的修饰符    &#125;    // Make sure modifiers like prevent and stop get executed after key filtering    if (genModifierCode) &#123;      code += genModifierCode    &#125;    // 根据三种不同的书写模板返回不同的字符串    const handlerCode = isMethodPath      ? `return $&#123;handler.value&#125;($event)`      : isFunctionExpression        ? `return ($&#123;handler.value&#125;)($event)`        : isFunctionInvocation          ? `return $&#123;handler.value&#125;`          : handler.value    /* istanbul ignore if */    if (__WEEX__ &amp;&amp; handler.params) &#123;      return genWeexHandler(handler.params, code + handlerCode)    &#125;    return `function($event)&#123;$&#123;code&#125;$&#123;handlerCode&#125;&#125;`  &#125;&#125;// dev/src/compiler/codegen/events.js line 175function genFilterCode (key: string): string &#123;  const keyVal = parseInt(key, 10)  if (keyVal) &#123; // 如果key是数字，则直接返回$event.keyCode!==$&#123;keyVal&#125;    return `$event.keyCode!==$&#123;keyVal&#125;`  &#125;  const keyCode = keyCodes[key]  const keyName = keyNames[key]  // 返回_k函数，它的第一个参数是$event.keyCode，  // 第二个参数是key的值，  // 第三个参数就是key在keyCodes中对应的数字。  return (    `_k($event.keyCode,` +    `$&#123;JSON.stringify(key)&#125;,` +    `$&#123;JSON.stringify(keyCode)&#125;,` +    `$event.key,` +    `$&#123;JSON.stringify(keyName)&#125;` +    `)`  )&#125;</code></pre><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p>前面介绍了如何编译模板提取事件收集指令以及生成<code>render</code>字符串和<code>render</code>函数，但是事件真正的绑定到<code>DOM</code>上还是离不开事件注册，此阶段就发生在<code>patchVnode</code>过程中，在生成完成<code>VNode</code>后，进行<code>patchVnode</code>过程中创建真实<code>DOM</code>时会进行事件注册的相关钩子处理。</p><pre><code class="javascript">// dev/src/core/vdom/patch.js line 33const hooks = [&#39;create&#39;, &#39;activate&#39;, &#39;update&#39;, &#39;remove&#39;, &#39;destroy&#39;]// dev/src/core/vdom/patch.js line 125function createElm (    vnode,    insertedVnodeQueue,    parentElm,    refElm,    nested,    ownerArray,    index  ) &#123;  // ...  if (isDef(data)) &#123;    invokeCreateHooks(vnode, insertedVnodeQueue)  &#125;  // ...&#125;// dev/src/core/vdom/patch.js line 303// 在之前cbs经过处理 // 这里cbs.create包含如下几个回调：// updateAttrs、updateClass、updateDOMListeners、updateDOMProps、updateStyle、update、updateDirectivesfunction invokeCreateHooks (vnode, insertedVnodeQueue) &#123;    for (let i = 0; i &lt; cbs.create.length; ++i) &#123;      cbs.create[i](emptyNode, vnode)    &#125;    i = vnode.data.hook // Reuse variable    if (isDef(i)) &#123;      if (isDef(i.create)) i.create(emptyNode, vnode)      if (isDef(i.insert)) insertedVnodeQueue.push(vnode)    &#125;&#125;</code></pre><p><code>invokeCreateHooks</code>就是一个模板指令处理的任务，他分别针对不同的指令为真实阶段创建不同的任务，针对事件，这里会调<code>updateDOMListeners</code>对真实的<code>DOM</code>节点注册事件任务。</p><pre><code class="javascript">// dev/src/platforms/web/runtime/modules/events.js line 105function updateDOMListeners (oldVnode: VNodeWithData, vnode: VNodeWithData) &#123;  if (isUndef(oldVnode.data.on) &amp;&amp; isUndef(vnode.data.on)) &#123;  // on是事件指令的标志    return  &#125;  // 新旧节点不同的事件绑定解绑  const on = vnode.data.on || &#123;&#125;  const oldOn = oldVnode.data.on || &#123;&#125;  // 拿到需要添加事件的真实DOM节点  target = vnode.elm  // normalizeEvents是对事件兼容性的处理  normalizeEvents(on)  // 调用updateListeners方法，并将on作为参数传进去  updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context)  target = undefined&#125;// dev/src/core/vdom/helpers/update-listeners.js line line 53export function updateListeners (  on: Object,  oldOn: Object,  add: Function,  remove: Function,  createOnceHandler: Function,  vm: Component) &#123;  let name, def, cur, old, event  for (name in on) &#123; // 遍历事件    def = cur = on[name]    old = oldOn[name]    event = normalizeEvent(name)    /* istanbul ignore if */    if (__WEEX__ &amp;&amp; isPlainObject(def)) &#123;      cur = def.handler      event.params = def.params    &#125;    if (isUndef(cur)) &#123; // 事件名非法的报错处理      process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(        `Invalid handler for event &quot;$&#123;event.name&#125;&quot;: got ` + String(cur),        vm      )    &#125; else if (isUndef(old)) &#123; // 旧节点不存在      if (isUndef(cur.fns)) &#123; // createFunInvoker返回事件最终执行的回调函数        cur = on[name] = createFnInvoker(cur, vm)      &#125;      if (isTrue(event.once)) &#123;  // 只触发一次的事件        cur = on[name] = createOnceHandler(event.name, cur, event.capture)      &#125;      // 执行真正注册事件的执行函数      add(event.name, cur, event.capture, event.passive, event.params)    &#125; else if (cur !== old) &#123;      old.fns = cur      on[name] = old    &#125;  &#125;  for (name in oldOn) &#123; // 旧节点存在，解除旧节点上的绑定事件    if (isUndef(on[name])) &#123;      event = normalizeEvent(name)      // 移除事件监听      remove(event.name, oldOn[name], event.capture)    &#125;  &#125;&#125;// dev/src/platforms/web/runtime/modules/events.js line 32// 在执行完回调之后，移除事件绑定function createOnceHandler (event, handler, capture) &#123;  const _target = target // save current target element in closure  return function onceHandler () &#123;    const res = handler.apply(null, arguments)    if (res !== null) &#123;      remove(event, onceHandler, capture, _target)    &#125;  &#125;&#125;</code></pre><p>最终添加与移除事件都是调用的<code>add</code>与<code>remove</code>方法，最终调用的方法即<code>DOM</code>的<code>addEventListener</code>方法与<code>removeEventListener</code>方法。</p><pre><code class="javascript">// dev/src/platforms/web/runtime/modules/events.js line 46function add (  name: string,  handler: Function,  capture: boolean,  passive: boolean) &#123;  // async edge case #6566: inner click event triggers patch, event handler  // attached to outer element during patch, and triggered again. This  // happens because browsers fire microtask ticks between event propagation.  // the solution is simple: we save the timestamp when a handler is attached,  // and the handler would only fire if the event passed to it was fired  // AFTER it was attached.  if (useMicrotaskFix) &#123;    const attachedTimestamp = currentFlushTimestamp    const original = handler    handler = original._wrapper = function (e) &#123;      if (        // no bubbling, should always fire.        // this is just a safety net in case event.timeStamp is unreliable in        // certain weird environments...        e.target === e.currentTarget ||        // event is fired after handler attachment        e.timeStamp &gt;= attachedTimestamp ||        // bail for environments that have buggy event.timeStamp implementations        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState        // #9681 QtWebEngine event.timeStamp is negative value        e.timeStamp &lt;= 0 ||        // #9448 bail if event is fired in another document in a multi-page        // electron/nw.js app, since event.timeStamp will be using a different        // starting reference        e.target.ownerDocument !== document      ) &#123;        return original.apply(this, arguments)      &#125;    &#125;  &#125;  target.addEventListener(    name,    handler,    supportsPassive      ? &#123; capture, passive &#125;      : capture  )&#125;// dev/src/platforms/web/runtime/modules/events.js line 92function remove (  name: string,  handler: Function,  capture: boolean,  _target?: HTMLElement) &#123;  (_target || target).removeEventListener(    name,    handler._wrapper || handler,    capture  )&#125;</code></pre><hr><p>参考文档:<a href="https://www.cnblogs.com/WindrunnerMax/p/13629209.html">博客园文章:Vue事件绑定原理</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-生命周期</title>
      <link href="/2021/03/02/%E5%89%8D%E7%AB%AF/vue/vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2021/03/02/%E5%89%8D%E7%AB%AF/vue/vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>总共分为8个阶段：创建前/后，载入前/后，更新前/后，销毁前/后。</p><span id="more"></span><h2 id="分析总结"><a href="#分析总结" class="headerlink" title="分析总结"></a>分析总结</h2><h4 id="1､创建前-后："><a href="#1､创建前-后：" class="headerlink" title="1､创建前/后："></a><strong>1､创建前/后：</strong></h4><h5 id="1-beforeCreate阶段："><a href="#1-beforeCreate阶段：" class="headerlink" title="1) beforeCreate阶段："></a>1) beforeCreate阶段：</h5><p>vue实例的挂载元素el和数据对象data都为undefined，还未初始化。</p><p>说明：在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。</p><h5 id="2-created阶段："><a href="#2-created阶段：" class="headerlink" title="2) created阶段："></a>2) created阶段：</h5><p>vue实例的数据对象data有了，el还没有。</p><p>说明：可以做一些初始数据的获取，在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。</p><h4 id="2､载入前-后："><a href="#2､载入前-后：" class="headerlink" title="2､载入前/后："></a><strong>2､载入前/后：</strong></h4><h5 id="1-beforeMount阶段："><a href="#1-beforeMount阶段：" class="headerlink" title="1) beforeMount阶段："></a>1) beforeMount阶段：</h5><p>vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点。</p><p>说明：当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。</p><h5 id="2-mounted阶段："><a href="#2-mounted阶段：" class="headerlink" title="2) mounted阶段："></a>2) mounted阶段：</h5><p>vue实例挂载完成，data.message成功渲染。</p><p>说明：在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。</p><h4 id="3､更新前-后："><a href="#3､更新前-后：" class="headerlink" title="3､更新前/后："></a><strong>3､更新前/后</strong>：</h4><h5 id="1-beforeUpdate阶段："><a href="#1-beforeUpdate阶段：" class="headerlink" title="1) beforeUpdate阶段："></a>1) beforeUpdate阶段：</h5><p>响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器。</p><p>说明：可以在当前阶段进行更改数据，不会造成重渲染。</p><h5 id="2-updated阶段："><a href="#2-updated阶段：" class="headerlink" title="2) updated阶段："></a>2) updated阶段：</h5><p>虚拟DOM重新渲染和打补丁之后调用，组成新的DOM已经更新，避免在这个钩子函数中操作数据，防止死循环。</p><p>说明：当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</p><h4 id="4､销毁前-后："><a href="#4､销毁前-后：" class="headerlink" title="4､销毁前/后："></a><strong>4､销毁前/后</strong>：</h4><h5 id="1-beforeDestroy阶段："><a href="#1-beforeDestroy阶段：" class="headerlink" title="1) beforeDestroy阶段："></a>1) beforeDestroy阶段：</h5><p>实例销毁前调用，实例还可以用，this能获取到实例，常用于销毁定时器，解绑事件。</p><p>说明：在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。</p><h5 id="2-destroyed阶段："><a href="#2-destroyed阶段：" class="headerlink" title="2) destroyed阶段："></a>2) destroyed阶段：</h5><p>实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁。</p><p>说明：当前阶段组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</p><h4 id="补充回答："><a href="#补充回答：" class="headerlink" title="补充回答："></a>补充回答：</h4><p>第一次页面加载时会触发：beforeCreate, created, beforeMount, mounted。</p><ol><li><p> created 实例已经创建完成，因为它是最早触发的原因可以进行一些数据，资源的请求。(服务器渲染支持created方法)</p></li><li><p> mounted 实例已经挂载完成，可以进行一些DOM操作。(接口请求)</p></li></ol><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/lifecycle.js">https://github.com/vuejs/vue/blob/dev/src/core/instance/lifecycle.js</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-{}与new Object()的区别是什么?</title>
      <link href="/2021/02/25/%E5%89%8D%E7%AB%AF/JavaScript/js-%7B%7D%E4%B8%8Enew%20Object()%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2021/02/25/%E5%89%8D%E7%AB%AF/JavaScript/js-%7B%7D%E4%B8%8Enew%20Object()%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>{} 这个叫做对象字面量,new Object()中没有传入参数，与{}是一样的</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><pre><code class="javascript">var a = &#123;&#125;;var b = new Object();</code></pre><p>这两种创建对象方式,从测试效果来看，{}会快一点。</p><p>{} 这个叫做对象字面量</p><p>如果new Object()中没有传入参数，与{}是一样的。</p><p>但是如果传入不同的参数，会有不同的效果。</p><p>传入String 返回String，类似new String()</p><p>传入Number 返回Number，类似new Number()</p><p>传入Object 返回Object，其实没啥用</p><pre><code class="javascript">var Obj = function() &#123;&#125;;var a = &#123;&#125;;var b = new Object();var c = new Obj();</code></pre><p> c最快，a次之，b最慢</p><p>一般来说,{}是字面量，可以立即求值，而new Object()本质上是方法（只不过这个方法是内置的）调用，既然是方法调用，就涉及到在proto链中遍历该方法，当找到该方法后，又会生产方法调用必须的堆栈信息，方法调用结束后，还要释放该堆栈</p><hr><p>参考文档:<a href="https://www.jianshu.com/p/5d7fe194649e">简书文章:{}与new Object()的区别是什么?</a></p><p>扩展阅读:<a href="https://www.jb51.net/article/129589.htm">脚本之家文章:new Array()和var arr=[]用法区别</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-prototype和__proto__</title>
      <link href="/2021/02/24/%E5%89%8D%E7%AB%AF/JavaScript/js-prototype%E5%92%8C__proto__/"/>
      <url>/2021/02/24/%E5%89%8D%E7%AB%AF/JavaScript/js-prototype%E5%92%8C__proto__/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>prototype是函数才有的属性;__proto__是每个对象都有的属性</p><span id="more"></span><h4 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h4><p>JavaScript的原型是一个很让人头疼的事情，一来<code>prototype</code>容易与<code>__proto__</code>混淆，二来它们之间的各种指向实在有些复杂，(关键Function和Object的关系复杂，他们的关系，可以阅读一下这篇文章<a href="https://www.jianshu.com/p/5727780214ac">这篇文章</a>)。<br> 原型是一个对象，其他对象可以通过它实现属性继承。</p><pre><code class="jsx"> let obj = Object.create(Object.prototype);console.log(obj);</code></pre><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210830113716.webp" alt="img"></p><h4 id="2、prototype和-proto-的区别"><a href="#2、prototype和-proto-的区别" class="headerlink" title="2、prototype和__proto__的区别"></a>2、prototype和__proto__的区别</h4><h5 id="prototype是函数才有的属性，切记，切记"><a href="#prototype是函数才有的属性，切记，切记" class="headerlink" title="prototype是函数才有的属性，切记，切记"></a>prototype是函数才有的属性，切记，切记</h5><p>具体原因，可以看看阮一峰大神的这篇文章<a href="https://links.jianshu.com/go?to=http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html">Javascript继承机制的设计思想</a>，里面介绍了<code>prototype</code>的设计由来。</p><h5 id="proto-是每个对象都有的属性"><a href="#proto-是每个对象都有的属性" class="headerlink" title="__proto__是每个对象都有的属性"></a><code>__proto__</code>是每个对象都有的属性</h5><p>它不是一个规范属性，该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它。<code>__proto__</code>属性已在ECMAScript 6语言规范中标准化，用于确保Web浏览器的兼容性，因此它未来将被支持。它已被不推荐使用, 现在更推荐使用<code>Object.getPrototypeOf/Reflect.getPrototypeOf</code>和<code>Object.setPrototypeOf/Reflect.setPrototypeOf</code>。<br> <strong>注意：大多数情况下，<code>__proto__</code>可以理解为“构造器的原型”，即<code>__proto__</code>===<code>constructor.prototype</code>,但是通过 Object.create()创建的对象有可能不是， Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code>，下面会有实例解释</strong></p><pre><code class="jsx">      let obj =｛｝;      console.log(&quot;obj:&quot;, obj);      console.log(&quot;obj.prototype:&quot;, obj.prototype);      console.log(&quot;obj.__proto__:&quot;, obj.__proto__);      console.log(&quot;====================================&quot;);      function myFunc() &#123;&#125;      console.log(&quot;myFunc.prototype:&quot;,myFunc.prototype);      console.log(&quot;myFunc.__proto__:&quot;,myFunc.__proto__);</code></pre><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210830113755.webp" alt="img"></p><p>打印出的结果很容易就证明上面的结论了。([native code] 指的是底层代码)</p><h4 id="3、-proto-指向"><a href="#3、-proto-指向" class="headerlink" title="3、__proto__指向"></a>3、__proto__指向</h4><p><code>__proto__</code>是每个对象有的属性，那我们就从对象下手，我们列举几种常见创建对象的方式，来看看他们的<code>__proto__</code>指向。</p><h5 id="1、字面量方式"><a href="#1、字面量方式" class="headerlink" title="1、字面量方式"></a>1、字面量方式</h5><pre><code class="tsx">    let obj = &#123;&#125;;    console.log(&quot;obj.__proto__:&quot;, obj.__proto__);    console.log( obj.__proto__===obj.constructor.prototype);</code></pre><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210830114754.webp" alt="img"></p><h5 id="2、构造器"><a href="#2、构造器" class="headerlink" title="2、构造器"></a>2、构造器</h5><pre><code class="tsx">      let objP = function() &#123;&#125;;      let obj = new objP();      console.log(&quot;obj.__proto__:&quot;, obj.__proto__);      console.log(obj.__proto__ === obj.constructor.prototype);      let objO = new Object();      console.log(&quot;objO.__proto__:&quot;, objO.__proto__);      console.log(objO.__proto__ === objO.constructor.prototype);</code></pre><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210830114806.webp" alt="img"></p><h5 id="3、-Object-create"><a href="#3、-Object-create" class="headerlink" title="3、 Object.create()"></a>3、 Object.create()</h5><pre><code class="tsx">      let a1 = &#123; a: 1 &#125;;      let a2 = Object.create(a1);      console.log(&quot;a2.__proto__:&quot;,a2.__proto__); //Object &#123;a: 1&#125;      console.log(a2.__proto__ === a1.constructor.prototype); //false      let a3 = Object.create(a1.__proto__);      console.log(&quot;a3.__proto__&quot;,a3.__proto__);       console.log(a3.__proto__ === a1.constructor.prototype); //true</code></pre><p><img src="http://cdn.tangyuxian.com/PicGoImages/20210830114904.webp" alt="img"> </p><p>从结果可以看到，第二部分中的结论，大多数情况下，<code>__proto__</code>可以理解为“构造器的原型”，即<code>__proto__</code>===<code>constructor.prototype</code>,但是通过 Object.create()创建的对象有可能不是， Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code>。</p><hr><p>参考文档:<a href="https://www.jianshu.com/p/3d756c5bba16">简书文章:prototype和__proto__</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-this指向问题</title>
      <link href="/2021/02/24/%E5%89%8D%E7%AB%AF/JavaScript/js-this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/"/>
      <url>/2021/02/24/%E5%89%8D%E7%AB%AF/JavaScript/js-this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>function(){} 和 () =&gt;{} 中this指向的问题</p><span id="more"></span><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><h4 id="普通函数中this"><a href="#普通函数中this" class="headerlink" title="普通函数中this"></a>普通函数中this</h4><ol><li><p>this总是代表它的直接调用者(js的this是执行上下文), 例如 obj.func ,那么func中的this就是obj</p></li><li><p>在默认情况(非严格模式下,未使用 ‘use strict’),没找到直接调用者,则this指的是 window (约定俗成)</p></li><li><p>在严格模式下,没有直接调用者的函数中的this是 undefined</p></li><li><p>使用call,apply,bind(ES5新增)绑定的,this指的是 绑定的对象</p></li></ol><p>注意：普通函数中，内层函数不能从外层函数中继承this的值，在内层函数中，this会是window或者undefined，临时变量self用来将外部的this值导入到内部函数中（另外的方式是在内部函数执行.bind(this)）</p><h4 id="es6箭头函数"><a href="#es6箭头函数" class="headerlink" title="es6箭头函数"></a>es6箭头函数</h4><p>箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象),而不是执行时的对象, 定义它的时候,可能环境是window; 箭头函数可以方便地让我们在 setTimeout ,setInterval中方便的使用this。</p><p>当在函数中使用一个变量的时候,首先在本函数内部查找该变量,如果找不到则找其父级函数,最后直到window,全局变量默认挂载在window对象下</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h4 id="1、普通函数中内层函数"><a href="#1、普通函数中内层函数" class="headerlink" title="1、普通函数中内层函数"></a>1、普通函数中内层函数</h4><pre><code class="js">function fun()&#123;    var self = this;    setTimeout(function()&#123;        console.log(this);// window        console.log(self);// &#123;id: 001&#125;        console.log(&#39;id: &#39;, self.id);// id:001    &#125;,500);&#125;fun.call(&#123;id:001&#125;);</code></pre><h4 id="2、普通函数中内层函数-bind-this"><a href="#2、普通函数中内层函数-bind-this" class="headerlink" title="2、普通函数中内层函数.bind(this)"></a>2、普通函数中内层函数.bind(this)</h4><pre><code class="javascript">function fun()&#123;    var self = this;    setTimeout(function()&#123;        console.log(this); //&#123;id: 1&#125;        console.log(self); //&#123;id: 1&#125;        console.log(&#39;id: &#39;, self.id); //id: 1    &#125;.bind(this),500);&#125;fun.call(&#123;id:001&#125;);</code></pre><h4 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h4><pre><code class="javascript">  function Fun()&#123;    console.log(&quot;args:fun:&quot;,arguments); //args:[2,2,3,4]    setTimeout(() =&gt;&#123;      console.log(&quot;args:()=&gt;&#123;&#125;:&quot;,arguments); //args:[2,2,3,4]    &#125;,500);    setTimeout(function()&#123;      console.log(&quot;args:function()&#123;&#125;&quot;,arguments); //    &#125;,500);  &#125;  new Fun(2,2,3,4)</code></pre><h4 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、</h4><pre><code class="javascript">var obj = &#123;   say: function () &#123;     setTimeout(() =&gt; &#123;       console.log(this)     &#125;);   &#125; &#125; obj.say(); // obj</code></pre><h4 id="5、"><a href="#5、" class="headerlink" title="5、"></a>5、</h4><pre><code class="javascript">var obj = &#123;say: function () &#123;  var f1 = () =&gt; &#123;    console.log(this); // obj    setTimeout(() =&gt; &#123;      console.log(this); // obj    &#125;)  &#125;  f1();  &#125;&#125;obj.say()</code></pre><h4 id="6、"><a href="#6、" class="headerlink" title="6、"></a>6、</h4><pre><code class="javascript">var obj = &#123;say: function () &#123;  var f1 = function () &#123;    console.log(this); // window, f1调用时,没有直接调用者,也就是没有宿主对象,默认是window    setTimeout(() =&gt; &#123;      console.log(this); // window    &#125;)  &#125;;   var f2 = ()=&gt;&#123;      console.log(this); //say f2调用时,this默认指向所处的对象(宿主对象),不是执行对象   &#125;;    f1();    f2();  &#125;&#125;obj.say()</code></pre><h4 id="7、严格模式"><a href="#7、严格模式" class="headerlink" title="7、严格模式"></a>7、严格模式</h4><pre><code class="javascript">var obj = &#123;say: function () &#123;  &#39;use strict&#39;;  var f1 = function () &#123;  console.log(this); // undefined  setTimeout(() =&gt; &#123;    console.log(this); // undefined  &#125;)  &#125;;  f1(); &#125;&#125;obj.say()</code></pre><h4 id="8、总结"><a href="#8、总结" class="headerlink" title="8、总结"></a>8、总结</h4><pre><code class="javascript">  var a = &#39;window&#39;;  var id = &#39;1&#39;;  var obj2 = &#123;    id: &#39;2&#39;,    a: &#39;obj2&#39;  &#125;  var obj = &#123;    a: &#39;obj&#39;,    id: &#39;3&#39;,    say1: () =&gt; &#123;      console.log(this.a);      console.log(this.id);    &#125;,    say2: function() &#123;      var f1 = () =&gt; &#123;        console.log(this.a);        console.log(this.id);      &#125;      f1();    &#125;,    say3: () =&gt; &#123;      var f1 = () =&gt; &#123;        console.log(this.a);        console.log(this.id);      &#125;      f1();    &#125;  &#125;  console.log(&#39;================================&#39;);  obj.say1.call(obj2) //window 1(箭头函数this指向不可被改变)  console.log(&#39;================================&#39;);  obj.say2.call(obj2)//obj2 2  console.log(&#39;================================&#39;);  obj.say3.call(obj2)//window 1  console.log(&#39;================================&#39;);  obj.say1()//window 1  console.log(&#39;================================&#39;);  obj.say2()//obj 3  console.log(&#39;================================&#39;);  obj.say3()//window 1  console.log(&#39;================================&#39;);</code></pre><hr><p>参考文档:<a href="https://blog.csdn.net/qq_36356218/article/details/80908021">CSDN文章:function(){} 和 () =&gt;{} 中this指向的问题</a>;</p><p>扩展阅读:<a href="https://blog.csdn.net/u012719257/article/details/46006671">CSDN文章:使用(function() {}).call(this);包裹代码有什么好处，什么时候应该这样做?</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-响应式原理</title>
      <link href="/2021/02/23/%E5%89%8D%E7%AB%AF/vue/vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
      <url>/2021/02/23/%E5%89%8D%E7%AB%AF/vue/vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>vue是基于 Object.defineProperty 来实现数据响应;</p><span id="more"></span><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><h4 id="根据数据类型来做不同处理，数组和对象类型当值变化时如何劫持。"><a href="#根据数据类型来做不同处理，数组和对象类型当值变化时如何劫持。" class="headerlink" title="根据数据类型来做不同处理，数组和对象类型当值变化时如何劫持。"></a>根据数据类型来做不同处理，数组和对象类型当值变化时如何劫持。</h4><ol><li><p>对象内部通过defineReactive方法，使用 Object.defineProperty() 监听数据属性的 get 来进行数据依赖收集，再通过 set 来完成数据更新的派发；</p></li><li><p>数组则通过重写数组方法来实现的。扩展它的 7 个变更⽅法，通过监听这些方法可以做到依赖收集和派发更新；</p></li></ol><p>多层对象是通过递归来实现劫持，vue3中是使用 proxy来实现响应式数据</p><p>补充回答：</p><p>内部依赖收集是怎么做到的，每个属性都拥有自己的dep属性，存放他所依赖的 watcher，当属性变化后会通知自己对应的 watcher去更新。</p><h4 id="响应式流程："><a href="#响应式流程：" class="headerlink" title="响应式流程："></a>响应式流程：</h4><p>1､defineReactive  把数据定义成响应式的；</p><p>2､给属性增加一个 dep，用来收集对应的那些watcher；</p><p>3､等数据变化进行更新</p><p>dep.depend() // get 取值：进行依赖收集</p><p>dep.notify() // set 设置时：通知视图更新</p><h4 id="性能优化相关的内容："><a href="#性能优化相关的内容：" class="headerlink" title="性能优化相关的内容："></a>性能优化相关的内容：</h4><p>1)对象层级过深，性能就会差。</p><p>2)不需要响应数据的内容不要放在data中。</p><p>3)object.freeze()  可以冻结数据。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h4 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h4><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js">https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js</a></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h6 id="初步"><a href="#初步" class="headerlink" title="初步"></a>初步</h6><p>最近一段时间在阅读Vue源码，从它的核心原理入手，开始了源码的学习，而其核心原理就是其数据的响应式，讲到Vue的响应式原理，我们可以从它的兼容性说起，Vue不支持IE8以下版本的浏览器，因为Vue是基于 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a> 来实现数据响应的，而        Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因；Vue通过Object.defineProperty的 <strong>getter/setter</strong> 对收集的依赖项进行监听,在属性被访问和修改时通知变化,进而更新视图数据；</p><p>受现代JavaScript 的限制 (以及废弃 <strong>Object.observe</strong>)，Vue不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 <strong>getter/setter</strong> 转化过程，所以属性必须在 <strong>data</strong> 对象上存在才能让Vue转换它，这样才能让它是响应的。</p><p><img src="http://cdn.tangyuxian.com/PicGoImages/202202271821632.webp" alt="img"></p><p>我们这里是根据Vue2.3源码进行分析,Vue数据响应式变化主要涉及 <strong>Observer</strong>, <strong>Watcher</strong> , <strong>Dep</strong> 这三个主要的类；因此要弄清Vue响应式变化需要明白这个三个类之间是如何运作联系的；以及它们的原理，负责的逻辑操作。那么我们从一个简单的Vue实例的代码来分析Vue的响应式原理</p><pre><code class="javascript">var vue = new Vue(&#123;    el: &quot;#app&quot;,    data: &#123;        name: &#39;Junga&#39;    &#125;,    created () &#123;        this.helloWorld()    &#125;,    methods: &#123;        helloWorld: function() &#123;            console.log(&#39;my name is&#39; + this.name)        &#125;    &#125;    ...&#125;)</code></pre><h5 id="Vue初始化实例"><a href="#Vue初始化实例" class="headerlink" title="Vue初始化实例"></a>Vue初始化实例</h5><p>根据Vue的<a href="https://cn.vuejs.org/v2/guide/instance.html#%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90">生命周期</a>我们知道，Vue首先会进行init初始化操作；源码在<a href="https://github.com/tangyuxian/Vue-learn/blob/master/core/instance/init.js">src/core/instance/init.js</a>中</p><pre><code class="javascript">/*初始化生命周期*/initLifecycle(vm)/*初始化事件*/initEvents(vm)Object.defineProperty /*初始化render*/initRender(vm)/*调用beforeCreate钩子函数并且触发beforeCreate钩子事件*/callHook(vm, &#39;beforeCreate&#39;)initInjections(vm) // resolve injections before data/props/*初始化props、methods、data、computed与watch*/initState(vm)initProvide(vm) // resolve provide after data/props/*调用created钩子函数并且触发created钩子事件*/callHook(vm, &#39;created&#39;)</code></pre><p>以上代码可以看到 <strong>initState(vm)</strong> 是用来初始化props,methods,data,computed和watch;</p><p><a href="https://github.com/tangyuxian/Vue-learn/blob/master/core/instance/state.js">src/core/instance/state.js</a></p><pre><code class="javascript">/*初始化props、methods、data、computed与watch*/export function initState (vm: Component) &#123;  vm._watchers = []  const opts = vm.$options  /*初始化props*/  if (opts.props) initProps(vm, opts.props)  /*初始化方法*/  if (opts.methods) initMethods(vm, opts.methods)  /*初始化data*/  if (opts.data) &#123;    initData(vm)  &#125; else &#123;    /*该组件没有data的时候绑定一个空对象*/    observe(vm._data = &#123;&#125;, true /* asRootData */)  &#125;  /*初始化computed*/  if (opts.computed) initComputed(vm, opts.computed)  /*初始化watchers*/  if (opts.watch) initWatch(vm, opts.watch)&#125;.../*初始化data*/function initData (vm: Component) &#123;  /*得到data数据*/  let data = vm.$options.data  data = vm._data = typeof data === &#39;function&#39;    ? getData(data, vm)    : data || &#123;&#125;defi  ...  //遍历data中的数据  while (i--) &#123;    /*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*/    if (props &amp;&amp; hasOwn(props, keys[i])) &#123;      process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(        `The data property &quot;$&#123;keys[i]&#125;&quot; is already declared as a prop. ` +        `Use prop default value instead.`,        vm      )    &#125; else if (!isReserved(keys[i])) &#123;      /*判断是否是保留字段*/      /*这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上*/      proxy(vm, `_data`, keys[i])    &#125;  &#125;  // observe data  /*这里通过observe实例化Observe对象，开始对数据进行绑定，asRootData用来根数据，用来计算实例化根数据的个数，下面会进行递归observe进行对深层对象的绑定。则asRootData为非true*/  observe(data, true /* asRootData */)&#125;</code></pre><h6 id="1、initData"><a href="#1、initData" class="headerlink" title="1、initData"></a>1、initData</h6><p>现在我们重点分析下<strong>initData</strong>，这里主要做了两件事，一是将_data上面的数据代理到vm上，二是通过执行 observe(data, true / <em>asRootData</em> /)将所有data变成可观察的，即对data定义的每个属性进行getter/setter操作，这里就是Vue实现响应式的基础；<strong>observe</strong>的实现如下 <a href="https://github.com/tangyuxian/Vue-learn/blob/master/core/observer/index.js">src/core/observer/index.js</a></p><pre><code class="javascript"> /*尝试创建一个Observer实例（__ob__），如果成功创建Observer实例则返回新的Observer实例，如果已有Observer实例则返回现有的Observer实例。*/export function observe (value: any, asRootData: ?boolean): Observer | void &#123;  if (!isObject(value)) &#123;    return  &#125;  let ob: Observer | void  /*这里用__ob__这个属性来判断是否已经有Observer实例，如果没有Observer实例则会新建一个Observer实例并赋值给__ob__这个属性，如果已有Observer实例则直接返回该Observer实例，这里可以看Observer实例化的代码def(value, &#39;__ob__&#39;, this)*/  if (hasOwn(value, &#39;__ob__&#39;) &amp;&amp; value.__ob__ instanceof Observer) &#123;    ob = value.__ob__  &#125; else if (    /*这里的判断是为了确保value是单纯的对象，而不是函数或者是Regexp等情况。而且该对象在shouldConvert的时候才会进行Observer。这是一个标识位，避免重复对value进行Observer    */    observerState.shouldConvert &amp;&amp;    !isServerRendering() &amp;&amp;    (Array.isArray(value) || isPlainObject(value)) &amp;&amp;    Object.isExtensible(value) &amp;&amp;    !value._isVue  ) &#123;    ob = new Observer(value)  &#125;  if (asRootData &amp;&amp; ob) &#123;     /*如果是根数据则计数，后面Observer中的observe的asRootData非true*/    ob.vmCount++  &#125;  return ob&#125;</code></pre><p>这里 <strong>new Observer(value)</strong> 就是实现响应式的核心方法之一了，通过它将data转变可以成观察的，而这里正是我们开头说的，用了 <strong>Object.defineProperty</strong> 实现了data的 <strong>getter/setter</strong> 操作，通过 <strong>Watcher</strong> 来观察数据的变化，进而更新到视图中。</p><h6 id="2、Observer"><a href="#2、Observer" class="headerlink" title="2、Observer"></a>2、Observer</h6><p>Observer类是将每个目标对象（即data）的键值转换成getter/setter形式，用于进行依赖收集以及调度更新。</p><p><a href="https://github.com/tangyuxian/Vue-learn/blob/master/core/observer/index.js">src/core/observer/index.js</a></p><pre><code class="javascript">export class Observer &#123;  value: any;  dep: Dep;  vmCount: number; // number of vms that has this object as root $data  constructor (value: any) &#123;    this.value = value    this.dep = new Dep()    this.vmCount = 0    /* 将Observer实例绑定到data的__ob__属性上面去，之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了，def方法定义可以参考/src/core/util/lang.js*/    def(value, &#39;__ob__&#39;, this)    if (Array.isArray(value)) &#123;      /*如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。*/      const augment = hasProto        ? protoAugment  /*直接覆盖原型的方法来修改目标对象*/        : copyAugment   /*定义（覆盖）目标对象或数组的某一个方法*/      augment(value, arrayMethods, arrayKeys)      /*如果是数组则需要遍历数组的每一个成员进行observe*/      this.observeArray(value)    &#125; else &#123;      /*如果是对象则直接walk进行绑定*/      this.walk(value)    &#125;,    walk (obj: Object) &#123;      const keys = Object.keys(obj)      /*walk方法会遍历对象的每一个属性进行defineReactive绑定*/      for (let i = 0; i &lt; keys.length; i++) &#123;        defineReactive(obj, keys[i], obj[keys[i]])      &#125;    &#125;  &#125;</code></pre><ol><li>首先将Observer实例绑定到data的<strong>ob</strong>属性上面去，防止重复绑定；</li><li>若data为数组，先实现对应的<a href="https://cn.vuejs.org/v2/guide/list.html#%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95">变异方法</a>（这里变异方法是指Vue重写了数组的7种原生方法，这里不做赘述，后续再说明），再将数组的每个成员进行observe，使之成响应式数据；</li><li>否则执行walk()方法，遍历data所有的数据，进行getter/setter绑定，这里的核心方法就是 <strong>defineReative(obj, keys[i], obj[keys[i]])</strong></li></ol><pre><code>export function defineReactive (  obj: Object,  key: string,  val: any,  customSetter?: Function) &#123;  /*在闭包中定义一个dep对象*/  const dep = new Dep()  const property = Object.getOwnPropertyDescriptor(obj, key)  if (property &amp;&amp; property.configurable === false) &#123;    return  &#125;  /*如果之前该对象已经预设了getter以及setter函数则将其取出来，新定义的getter/setter中会将其执行，保证不会覆盖之前已经定义的getter/setter。*/  // cater for pre-defined getter/setters  const getter = property &amp;&amp; property.get  const setter = property &amp;&amp; property.set  /*对象的子对象递归进行observe并返回子节点的Observer对象*/  let childOb = observe(val)  Object.defineProperty(obj, key, &#123;    enumerable: true,    configurable: true,    get: function reactiveGetter () &#123;      /*如果原本对象拥有getter方法则执行*/      const value = getter ? getter.call(obj) : val      if (Dep.target) &#123;        /*进行依赖收集*/        dep.depend()        if (childOb) &#123;          /*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*/          childOb.dep.depend()        &#125;        if (Array.isArray(value)) &#123;          /*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/          dependArray(value)        &#125;      &#125;      return value    &#125;,    set: function reactiveSetter (newVal) &#123;      /*通过getter方法获取当前值，与新值进行比较，一致则不需要执行下面的操作*/      const value = getter ? getter.call(obj) : val      /* eslint-disable no-self-compare */      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;        return      &#125;      /* eslint-enable no-self-compare */      if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; customSetter) &#123;        customSetter()      &#125;      if (setter) &#123;        /*如果原本对象拥有setter方法则执行setter*/        setter.call(obj, newVal)      &#125; else &#123;        val = newVal      &#125;      /*新的值需要重新进行observe，保证数据响应式*/      childOb = observe(newVal)      /*dep对象通知所有的观察者*/      dep.notify()    &#125;  &#125;)&#125;复制代码</code></pre><p>其中getter方法：</p><ol><li>先为每个data声明一个 <strong>Dep</strong> 实例对象，被用于getter时执行dep.depend()进行收集相关的依赖;</li><li>根据Dep.target来判断是否收集依赖，还是普通取值。Dep.target是在什么时候，如何收集的后面再说明，先简单了解它的作用，</li></ol><p>那么问题来了，我们为啥要收集相关依赖呢？</p><pre><code class="javascript">new Vue(&#123;    template:         `&lt;div&gt;            &lt;span&gt;text1:&lt;/span&gt; &#123;&#123;text1&#125;&#125;            &lt;span&gt;text2:&lt;/span&gt; &#123;&#123;text2&#125;&#125;        &lt;div&gt;`,    data: &#123;        text1: &#39;text1&#39;,        text2: &#39;text2&#39;,        text3: &#39;text3&#39;    &#125;&#125;);</code></pre><p>我们可以从以上代码看出，data中text3并没有被模板实际用到，为了提高代码执行效率，我们没有必要对其进行响应式处理，因此，依赖收集简单点理解就是收集只在实际页面中用到的data数据，然后打上标记，这里就是标记为Dep.target。</p><p>在setter方法中:</p><ol><li>获取新的值并且进行observe，保证数据响应式；</li><li>通过dep对象通知所有观察者去更新数据，从而达到响应式效果。</li></ol><p>在Observer类中，我们可以看到在getter时，dep会收集相关依赖，即收集依赖的watcher，然后在setter操作时候通过dep去通知watcher,此时watcher就执行变化，我们用一张图描述这三者之间的关系：<br><img src="https://user-gold-cdn.xitu.io/2018/2/8/1617554b5e866e59?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="关系图"></p><p>从图我们可以简单理解：Dep可以看做是书店，Watcher就是书店订阅者，而Observer就是书店的书，订阅者在书店订阅书籍，就可以添加订阅者信息，一旦有新书就会通过书店给订阅者发送消息。</p><h6 id="3、Watcher"><a href="#3、Watcher" class="headerlink" title="3、Watcher"></a>3、Watcher</h6><p>Watcher是一个观察者对象。依赖收集以后Watcher对象会被保存在Dep的subs中，数据变动的时候Dep会通知Watcher实例，然后由Watcher实例回调cb进行视图的更新。</p><p><a href="https://github.com/tangyuxian/Vue-learn/blob/master/core/observer/watcher.js">src/core/observer/watcher.js</a></p><pre><code class="javascript">export default class Watcher &#123;  constructor (    vm: Component,    expOrFn: string | Function,    cb: Function,    options?: Object  ) &#123;    this.vm = vm    /*_watchers存放订阅者实例*/    vm._watchers.push(this)    // options    if (options) &#123;      this.deep = !!options.deep      this.user = !!options.user      this.lazy = !!options.lazy      this.sync = !!options.sync    &#125; else &#123;      this.deep = this.user = this.lazy = this.sync = false    &#125;    this.cb = cb    this.id = ++uid // uid for batching    this.active = true    this.dirty = this.lazy // for lazy watchers    this.deps = []    this.newDeps = []    this.depIds = new Set()    this.newDepIds = new Set()    this.expression = process.env.NODE_ENV !== &#39;production&#39;      ? expOrFn.toString()      : &#39;&#39;    // parse expression for getter    /*把表达式expOrFn解析成getter*/    if (typeof expOrFn === &#39;function&#39;) &#123;      this.getter = expOrFn    &#125; else &#123;      this.getter = parsePath(expOrFn)      if (!this.getter) &#123;        this.getter = function () &#123;&#125;        process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(          `Failed watching path: &quot;$&#123;expOrFn&#125;&quot; ` +          &#39;Watcher only accepts simple dot-delimited paths. &#39; +          &#39;For full control, use a function instead.&#39;,          vm        )      &#125;    &#125;    this.value = this.lazy      ? undefined      : this.get()  &#125;  /**   * Evaluate the getter, and re-collect dependencies.   */   /*获得getter的值并且重新进行依赖收集*/  get () &#123;    /*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*/    pushTarget(this)    let value    const vm = this.vm    /*执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。      在将Dep.target设置为自生观察者实例以后，执行getter操作。      譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c，      那么在执行getter的时候就会触发a跟c两个数据的getter函数，      在getter函数中即可判断Dep.target是否存在然后完成依赖收集，      将该观察者对象放入闭包中的Dep的subs中去。*/    if (this.user) &#123;      try &#123;        value = this.getter.call(vm, vm)      &#125; catch (e) &#123;        handleError(e, vm, `getter for watcher &quot;$&#123;this.expression&#125;&quot;`)      &#125;    &#125; else &#123;      value = this.getter.call(vm, vm)    &#125;    // &quot;touch&quot; every property so they are all tracked as    // dependencies for deep watching    /*如果存在deep，则触发每个深层对象的依赖，追踪其变化*/    if (this.deep) &#123;      /*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*/      traverse(value)    &#125;    /*将观察者实例从target栈中取出并设置给Dep.target*/    popTarget()    this.cleanupDeps()    return value  &#125;  /**   * Add a dependency to this directive.   */   /*添加一个依赖关系到Deps集合中*/  addDep (dep: Dep) &#123;    const id = dep.id    if (!this.newDepIds.has(id)) &#123;      this.newDepIds.add(id)      this.newDeps.push(dep)      if (!this.depIds.has(id)) &#123;        dep.addSub(this)      &#125;    &#125;  &#125;  /**   * Clean up for dependency collection.   */   /*清理依赖收集*/  cleanupDeps () &#123;    /*移除所有观察者对象*/    ...  &#125;  /**   * Subscriber interface.   * Will be called when a dependency changes.   */   /*      调度者接口，当依赖发生改变的时候进行回调。   */  update () &#123;    /* istanbul ignore else */    if (this.lazy) &#123;      this.dirty = true    &#125; else if (this.sync) &#123;      /*同步则执行run直接渲染视图*/      this.run()    &#125; else &#123;      /*异步推送到观察者队列中，下一个tick时调用。*/      queueWatcher(this)    &#125;  &#125;  /**   * Scheduler job interface.   * Will be called by the scheduler.   */   /*      调度者工作接口，将被调度者回调。    */  run () &#123;    if (this.active) &#123;      /* get操作在获取value本身也会执行getter从而调用update更新视图 */      const value = this.get()      if (        value !== this.value ||        // Deep watchers and watchers on Object/Arrays should fire even        // when the value is the same, because the value may        // have mutated.        /*            即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。        */        isObject(value) ||        this.deep      ) &#123;        // set new value        const oldValue = this.value        /*设置新的值*/        this.value = value        /*触发回调*/        if (this.user) &#123;          try &#123;            this.cb.call(this.vm, value, oldValue)          &#125; catch (e) &#123;            handleError(e, this.vm, `callback for watcher &quot;$&#123;this.expression&#125;&quot;`)          &#125;        &#125; else &#123;          this.cb.call(this.vm, value, oldValue)        &#125;      &#125;    &#125;  &#125;  /**   * Evaluate the value of the watcher.   * This only gets called for lazy watchers.   */   /*获取观察者的值*/  evaluate () &#123;    this.value = this.get()    this.dirty = false  &#125;  /**   * Depend on all deps collected by this watcher.   */   /*收集该watcher的所有deps依赖*/  depend () &#123;    let i = this.deps.length    while (i--) &#123;      this.deps[i].depend()    &#125;  &#125;  /**   * Remove self from all dependencies&#39; subscriber list.   */   /*将自身从所有依赖收集订阅列表删除*/  teardown () &#123;   ...  &#125;&#125;</code></pre><h6 id="4、Dep"><a href="#4、Dep" class="headerlink" title="4、Dep"></a>4、Dep</h6><p>被Observer的data在触发 <strong>getter</strong> 时，<strong>Dep</strong> 就会收集依赖的 <strong>Watcher</strong> ，其实 <strong>Dep</strong> 就像刚才说的是一个书店，可以接受多个订阅者的订阅，当有新书时即在data变动时，就会通过 <strong>Dep</strong> 给 <strong>Watcher</strong> 发通知进行更新。</p><p><a href="https://github.com/tangyuxian/Vue-learn/blob/master/core/observer/dep.js">src/core/observer/dep.js</a></p><pre><code class="javascript">export default class Dep &#123;  static target: ?Watcher;  id: number;  subs: Array&lt;Watcher&gt;;  constructor () &#123;    this.id = uid++    this.subs = []  &#125;  /*添加一个观察者对象*/  addSub (sub: Watcher) &#123;    this.subs.push(sub)  &#125;  /*移除一个观察者对象*/  removeSub (sub: Watcher) &#123;    remove(this.subs, sub)  &#125;  /*依赖收集，当存在Dep.target的时候添加观察者对象*/  depend () &#123;    if (Dep.target) &#123;      Dep.target.addDep(this)    &#125;  &#125;  /*通知所有订阅者*/  notify () &#123;    // stabilize the subscriber list first    const subs = this.subs.slice()    for (let i = 0, l = subs.length; i &lt; l; i++) &#123;      subs[i].update()    &#125;  &#125;&#125;</code></pre><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>其实在 <strong>Vue</strong> 中初始化渲染时，视图上绑定的数据就会实例化一个 <strong>Watcher</strong>，依赖收集就是是通过属性的 <strong>getter</strong> 函数完成的，文章一开始讲到的 <strong>Observer</strong> 、<strong>Watcher</strong> 、<strong>Dep</strong> 都与依赖收集相关。其中 <strong>Observer</strong> 与 <strong>Dep</strong>        是一对一的关系， <strong>Dep</strong> 与 <strong>Watcher</strong> 是多对多的关系，<strong>Dep</strong> 则是 <strong>Observer</strong> 和 <strong>Watcher</strong> 之间的纽带。依赖收集完成后，当属性变化会执行被 <strong>Observer</strong> 对象的 <strong>dep.notify()</strong> 方法，这个方法会遍历订阅者（Watcher）列表向其发送消息，        <strong>Watcher</strong> 会执行 <strong>run</strong> 方法去更新视图，我们再来看一张图总结一下：<br><img src="http://cdn.tangyuxian.com/PicGoImages/202202271819467.webp" alt="img"></p><ol><li><p>在 <strong>Vue</strong> 中模板编译过程中的指令或者数据绑定都会实例化一个 <strong>Watcher</strong> 实例，实例化过程中会触发 <strong>get()</strong> 将自身指向 <strong>Dep.target</strong>;</p></li><li><p>data在 <strong>Observer</strong> 时执行 <strong>getter</strong> 会触发 <strong>dep.depend()</strong> 进行依赖收集;依赖收集的结果：</p><p>  1.data在 <strong>Observer</strong> 时闭包的dep实例的subs添加观察它的 <strong>Watcher</strong> 实例；</p><p>  2.Watcher** 的deps中添加观察对象 <strong>Observer</strong> 时的闭包dep；</p></li><li><p>当data中被 <strong>Observer</strong> 的某个对象值变化后，触发subs中观察它的watcher执行 <strong>update()</strong> 方法，最后实际上是调用watcher的回调函数cb，进而更新视图。</p></li></ol><hr><p>参考文档:<a href="https://juejin.cn/post/6844903561327820808">掘金文章:理解vue相应原理</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-Vue.use()原理及使用</title>
      <link href="/2021/02/22/%E5%89%8D%E7%AB%AF/vue/vue-Vue.use()%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/02/22/%E5%89%8D%E7%AB%AF/vue/vue-Vue.use()%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>vue.use 是用来使用插件的，我们可以在插件中扩展全局组件、指令、原型方法等。</p><span id="more"></span><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><h4 id="主要执行流程"><a href="#主要执行流程" class="headerlink" title="主要执行流程"></a>主要执行流程</h4><p>1､检查插件是否注册，若已注册，则直接跳出；</p><p>2､处理入参，将第一个参数之后的参数归集，并在首部塞入 this 上下文；</p><p>3､执行注册方法，调用定义好的 install 方法，传入处理的参数，若没有 install 方法并且插件本身为 function 则直接进行注册；</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol><li><p>插件不能重复的加载:install 方法的第一个参数是vue的构造函数，其他参数是Vue.set中除了第一个参数的其他参数； 代码：args.unshift(this)</p></li><li><p>调用插件的install 方法 代码：typeof plugin.install === ‘function’</p></li><li><p>插件本身是一个函数，直接让函数执行。 代码：plugin.apply(null, args)</p></li><li><p>缓存插件。 代码：installedPlugins.push(plugin)</p></li></ol><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h4 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h4><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/global-api/use.js">https://github.com/vuejs/vue/blob/dev/src/core/global-api/use.js</a></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h6 id="1举例分析"><a href="#1举例分析" class="headerlink" title="1举例分析"></a>1举例分析</h6><p>创建两个文件</p><pre><code class="javascript">// plugins.jsconst Plugin1 = &#123;  install(a,b)&#123;    console.log(&#39;Plugin1 第一个参数：&#39;,a)    console.log(&#39;Plugin1 第二个参数：&#39;,b)  &#125;&#125;function Plugin2(a,b)&#123;  console.log(&#39;Plugin2 第一个参数：&#39;,a)  console.log(&#39;Plugin2 第二个参数：&#39;,b)&#125;export&#123;Plugin1,Plugin2&#125;</code></pre><pre><code class="javascript">// use.js import Vue from &#39;vue&#39;import &#123;Plugin1,Plugin2&#125; from &#39;./plugins&#39;Vue.use(Plugin1,&#39;参数1&#39;)Vue.use(Plugin2,&#39;参数A&#39;)</code></pre><pre><code class="javascript">// main.jsimport Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;import router from &#39;./router&#39;import &#39;./assets/plugins/use&#39;Vue.config.productionTip = falsenew Vue(&#123;  router,  store,  render: h =&gt; h(App)&#125;).$mount(&#39;#app&#39;)</code></pre><p>从中可以发现我们在 plugin1 中的 install 方法编写的两个 console 都打印出来，第一个打印出来的是Vue对象，第二个是我们传入的参数。<br>而 plugin2 没有 install 方法，它本身就是一个方法，也能打印两个参数，第一个是Vue对象，第二个是我们传入的参数。<br>那么现在我们是不是大概对Vue.use有一个模糊的猜想.</p><h6 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h6><p><strong>toArray 源码</strong></p><pre><code class="javascript">export function toArray (list: any, start?: number): Array&lt;any&gt; &#123;  start = start || 0  let i = list.length - start  const ret: Array&lt;any&gt; = new Array(i)  while (i--) &#123;    ret[i] = list[i + start]  &#125;  return ret&#125;</code></pre><p><strong>use源码</strong></p><pre><code class="javascript">import &#123; toArray &#125; from &#39;../util/index&#39;export function initUse (Vue: GlobalAPI) &#123;  Vue.use = function (plugin: Function | Object) &#123;    const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))    if (installedPlugins.indexOf(plugin) &gt; -1) &#123;      return this    &#125;    // additional parameters    const args = toArray(arguments, 1)    args.unshift(this)    if (typeof plugin.install === &#39;function&#39;) &#123;      plugin.install.apply(plugin, args)    &#125; else if (typeof plugin === &#39;function&#39;) &#123;      plugin.apply(null, args)    &#125;    installedPlugins.push(plugin)    return this  &#125;&#125;</code></pre><p>从源码中我们可以发现 vue 首先判断这个插件是否被注册过，不允许重复注册，并且接收的 plugin 参数的限制是 Function | Object 两种类型。<br>对于这两种类型有不同的处理。<br>首先将我们传入的参数整理成数组： const args = toArray(arguments, 1)；<br>再将 Vue 对象添加到这个数组的起始位置 args.unshift(this) ,这里的 this 指向 Vue 对象；<br>如果我们传入的 plugin(Vue.use的第一个参数) 的 install 是一个方法。也就是说如果我们传入一个对象，对象中包含 install 方法，那么我们就调用这个 plugin 的 install 方法并将整理好的数组当成参数传入 install 方法中， plugin.install.apply(plugin, args)；<br>如果我们传入的 plugin 就是一个函数,那么我们就直接调用这个函数并将整理好的数组当成参数传入， plugin.apply(null, args)；<br>之后给这个插件添加至已经添加过的插件数组中，标示已经注册过 installedPlugins.push(plugin)；<br>最后返回 Vue 对象。</p><h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><p>通过以上分析我们可以知道，在我们以后编写插件的时候可以有两种方式。<br>一种是将这个插件的逻辑封装成一个对象，最后将在 install 编写业务代码暴露给 Vue 对象。这样做的好处是可以添加任意参数在这个对象上方便将 install 函数封装得更加精简，可拓展性也比较高。<br>还有一种则是将所有逻辑都编写成一个函数暴露给 Vue。<br>其实两种方法原理都一样，无非第二种就是将这个插件直接当成 install 函数来处理。<br>个人觉得第一种方式比较合理。</p><hr><p>参考文档:<a href="https://blog.csdn.net/ZYS10000/article/details/107246076/">csdn上的文章:Vue中 Vue.use() 原理及使用</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-new Vue()中发生了什么?</title>
      <link href="/2021/02/22/%E5%89%8D%E7%AB%AF/vue/Vue-new%20Vue()%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/2021/02/22/%E5%89%8D%E7%AB%AF/vue/Vue-new%20Vue()%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>new Vue()是实例化一个Vue对象,在构造函数中执行_init(options)，随后导入五大Mixin,进行实例化的初始化过程</p><span id="more"></span><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><h4 id="五大Mixin-进行实例化的初始化过程如下"><a href="#五大Mixin-进行实例化的初始化过程如下" class="headerlink" title="五大Mixin,进行实例化的初始化过程如下"></a>五大Mixin,进行实例化的初始化过程如下</h4><ol><li>initMixin(Vue)  <em>// options初始化</em></li><li>stateMixin(Vue) <em>// 状态（props、state、computed、watch）</em></li><li>eventsMixin(Vue) <em>// 事件</em></li><li>lifecycleMixin(Vue) <em>// 生命周期</em></li><li>renderMixin(Vue) <em>// 页面渲染</em></li></ol><h4 id="含义简介"><a href="#含义简介" class="headerlink" title="含义简介"></a>含义简介</h4><p>initLifecycle:初始化生命周期</p><p>initEvents：初始化事件</p><p>initRender：渲染页面</p><p>callHook(vm,’beforeCreate’) ：beforeCreate钩子函数</p><p>initState：初始化状态 props data computed watch methods</p><p>callHook(vm,’created’):created钩子函数</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h4 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h4><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/init.js">https://github.com/vuejs/vue/blob/dev/src/core/instance/init.js</a></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h6 id="1-vue入口：new-Vue-构造函数"><a href="#1-vue入口：new-Vue-构造函数" class="headerlink" title="1. vue入口：new Vue()构造函数"></a>1. vue入口：new Vue()构造函数</h6><pre><code class="jsx">// vue/src/platform/web/entry-runtime.js/* @flow  */import Vue from &#39;./runtime/index&#39;export default Vue</code></pre><p>从vue1到vue2的迭代上，vue采用了flow进行静态代码类型检查</p><pre><code class="jsx"> // vue/src/platform/web/runtime/index.jsimport Vue from &#39;core/index&#39;import config from &#39;core/config&#39;import &#123; extend, noop &#125; from &#39;shared/util&#39;import &#123; mountComponent &#125; from &#39;core/instance/lifecycle&#39;import &#123; devtools, inBrowser, isChrome &#125; from &#39;core/util/index&#39;</code></pre><p>继续找到Vue的引用所在地</p><pre><code class="jsx">// vue/src/core/instance/index.jsimport &#123; initMixin &#125; from &#39;./init&#39;import &#123; stateMixin &#125; from &#39;./state&#39;import &#123; renderMixin &#125; from &#39;./render&#39;import &#123; eventsMixin &#125; from &#39;./events&#39;import &#123; lifecycleMixin &#125; from &#39;./lifecycle&#39;import &#123; warn &#125; from &#39;../util/index&#39;function Vue (options) &#123;  if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp;    !(this instanceof Vue)  ) &#123;    warn(&#39;Vue is a constructor and should be called with the `new` keyword&#39;)  &#125;  this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue</code></pre><h6 id="2-构造函数干了什么"><a href="#2-构造函数干了什么" class="headerlink" title="2. 构造函数干了什么"></a>2. 构造函数干了什么</h6><p>到这里，我们可以在上述代码中看到Vue的构造函数，在构造函数中执行了<code>_init</code>，随后执行了导入的五大Mixin，进行实例化的初始化过程</p><pre><code class="cpp">initMixin(Vue)  // options初始化stateMixin(Vue) // 状态（props、state、computed、watch）eventsMixin(Vue) // 事件lifecycleMixin(Vue) // 生命周期renderMixin(Vue) // 页面渲染</code></pre><p>找到<code>_init</code>执行函数</p><pre><code class="jsx">export function initMixin (Vue: Class&lt;Component&gt;) &#123;  Vue.prototype._init = function (options?: Object) &#123;    const vm: Component = this    // a uid    vm._uid = uid++    ...</code></pre><p>这个函数主要对我们在实例化中的配置与默认配置进行了合并，并且依次执行了以下几步</p><pre><code class="javascript">initLifecycle(vm)initEvents(vm)initRender(vm)callHook(vm, &#39;beforeCreate&#39;)initInjections(vm) // resolve injections before data/propsinitState(vm)initProvide(vm) // resolve provide after data/propscallHook(vm, &#39;created&#39;)/* istanbul ignore if */if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) &#123;  vm._name = formatComponentName(vm, false)  mark(endTag)  measure(`vue $&#123;vm._name&#125; init`, startTag, endTag)&#125;if (vm.$options.el) &#123;  vm.$mount(vm.$options.el)&#125;</code></pre><p>initLifecycle： 初始化生命周期<br> initEvents： 初始化事件<br> initRender： 渲染页面<br> callHook(vm, ‘beforeCreate’)： beforeCreate钩子函数<br> initState：初始化状态  props data computed  watch methods<br> callHook(vm, ‘created’)：created钩子函数</p><p>我们重点关注下 initState中的 initData，也就是老生常谈的数据双向绑定</p><pre><code class="javascript">function initData (vm: Component) &#123;let data = vm.$options.datadata = vm._data = typeof data === &#39;function&#39;  ? getData(data, vm)  : data || &#123;&#125;if (!isPlainObject(data)) &#123;  data = &#123;&#125;  process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(    &#39;data functions should return an object:\n&#39; +    &#39;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#39;,    vm  )&#125;// proxy data on instanceconst keys = Object.keys(data)const props = vm.$options.propsconst methods = vm.$options.methodslet i = keys.lengthwhile (i--) &#123;  const key = keys[i]  if (process.env.NODE_ENV !== &#39;production&#39;) &#123;    if (methods &amp;&amp; hasOwn(methods, key)) &#123;      warn(        `Method &quot;$&#123;key&#125;&quot; has already been defined as a data property.`,        vm      )    &#125;  &#125;  if (props &amp;&amp; hasOwn(props, key)) &#123;    process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(      `The data property &quot;$&#123;key&#125;&quot; is already declared as a prop. ` +      `Use prop default value instead.`,      vm    )  &#125; else if (!isReserved(key)) &#123;    proxy(vm, `_data`, key)  &#125;&#125;  // observe data  observe(data, true /* asRootData */)&#125;</code></pre><p>在上面的代码中找到两个关键字 <code>proxy</code> 和 <code>observe</code><br> 前者的作用：<br> 我们在vue中调用数据： this.demo = 123<br> 但是在源码初始化的过程中，是这样的 this._data.demo = 123<br> proxy就是将key值做了代理，简化了调用，方便了我们</p><p>后者的作用：<br> 开始进行双向数据绑定  observe(data, true /* asRootData */)</p><p>简化后的observe</p><pre><code class="javascript">export function observe (value) &#123;    if (!isObject(value)) &#123;        return    &#125;    let ob = new Observer(value)    return ob&#125;export class Observer &#123;    constructor (value) &#123;        this.value = value        this.dep = new Dep()        this.vmCount = 0        def(value, &#39;__ob__&#39;, this)        this.walk(value)    &#125;    walk (obj) &#123;        const keys = Object.keys(obj)        for (let i = 0; i &lt; keys.length; i++) &#123;            defineReactive(obj, keys[i], obj[keys[i]])        &#125;    &#125;&#125;export function defineReactive (obj, key, val) &#123;    const dep = new Dep()    let childOb = observe(val)    Object.defineProperty(obj, key, &#123;        enumerable: true,        configurable: true,        // 取值时给数据添加依赖        get: function reactiveGetter () &#123;            const value = val            if (Dep.target) &#123;                dep.depend()                if (childOb) &#123;                    childOb.dep.depend()                &#125;            &#125;            return value        &#125;,        // 赋值时通知数据依赖更新        set: function reactiveSetter (newVal) &#123;            const value = val            if (newVal === value) &#123;                return            &#125;            val = newVal            childOb = observe(newVal)            dep.notify()        &#125;    &#125;)&#125;</code></pre><p>这里在简单阐述下vue双向数据绑定的原理：</p><p>发布者-订阅者 + 数据劫持</p><p>在上述的代码中，重点关注 <code>defineReactive</code>函数，对vue对象中的每个属性进行了递归遍历的监听，利用 <code>Object.defineProperty</code>对每个属性进行监听，在取值的时候添加依赖进行依赖收集，在复制的时候进行通知订阅者进行依赖更新。</p><hr><p>参考文档:<a href="https://www.jianshu.com/p/5ca5f40e4810">简书上的文章:new Vue大致干了啥</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-基于vue的SEO方案</title>
      <link href="/2021/02/20/%E5%89%8D%E7%AB%AF/vue/vue-%E5%9F%BA%E4%BA%8Evue%E7%9A%84SEO%E6%96%B9%E6%A1%88/"/>
      <url>/2021/02/20/%E5%89%8D%E7%AB%AF/vue/vue-%E5%9F%BA%E4%BA%8Evue%E7%9A%84SEO%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因vue是spa单页面应用,对seo不友好,所以针对该问题整合了目前网上提到的解决方案以供参考</p><span id="more"></span><h2 id="了解SEO"><a href="#了解SEO" class="headerlink" title="了解SEO"></a>了解SEO</h2><p>搜索引擎优化（Search engine optimization，简称seo），指为了提升网页在搜索引擎自然搜索结果中（非商业性推广结果）的收录数量以及排序位置而做的优化行为，是为了从搜索引擎中获得更多的免费流量，以及更好的展现形象。</p><h2 id="seo对vue单页面不友好的原因"><a href="#seo对vue单页面不友好的原因" class="headerlink" title="seo对vue单页面不友好的原因"></a>seo对vue单页面不友好的原因</h2><ul><li>爬虫在爬取的过程中，不会去执行js，所以隐藏在js中的跳转也不会获取到</li><li>vue通过js控制路由然后渲染出对应的页面，而搜索引擎蜘蛛是不会去执行页面的js的，导致搜索引擎蜘蛛只能收录index.html一个页面，在百度中就搜索不到相关的子页面的内容。</li><li>我们加载页面的时候,浏览器的渲染包含:html的解析、dom树的构建、cssom构建、javascript解析、布局、绘制,当解析到javascript的时候才回去触发vue的渲染,然后元素挂载到id为app的div上,这个时候我们才能看到我们页面的内容,所以即使vue渲染机制很快我们仍然能够看到一段时间的白屏情况,用户体验不好</li></ul><h2 id="常见解决方案"><a href="#常见解决方案" class="headerlink" title="常见解决方案"></a>常见解决方案</h2><ul><li>1.SSR服务器渲染；</li><li>2.静态化；</li><li>3.预渲染prerender-spa-plugin；</li><li>4.使用Phantomjs针对爬虫做处理。</li></ul><h4 id="1-SSR服务器渲染"><a href="#1-SSR服务器渲染" class="headerlink" title="1.SSR服务器渲染"></a>1.SSR服务器渲染</h4><p>关于服务器渲染：Vue官网介绍，对Vue版本有要求，对服务器也有一定要求，需要支持nodejs环境。</p><p>使用SSR权衡之处：</p><ul><li>开发条件所限，浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行；</li><li>环境和部署要求更高，需要Node.js server 运行环境；</li><li>高流量的情况下，请准备相应的服务器负载，并明智地采用缓存策略。</li></ul><h6 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h6><ul><li>更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面；</li><li>更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。</li></ul><h6 id="不足：（开发中遇到的坑）"><a href="#不足：（开发中遇到的坑）" class="headerlink" title="不足：（开发中遇到的坑）"></a>不足：（开发中遇到的坑）</h6><p>1.一套代码两套执行环境，会引起各种问题，比如服务端没有window、document对象，处理方式是增加判断，如果是客户端才执行：</p><pre><code class="javascript">if(process.browser)&#123; console.log(window);&#125;</code></pre><p>引用npm包，带有dom操作的，例如：<code>wowjs</code>，不能用<code>import</code>的方式，改用：</p><pre><code class="javascript">if (process.browser) &#123;     var &#123; WOW &#125; = require(&#39;wowjs&#39;);     require(&#39;wowjs/css/libs/animate.css&#39;); &#125;</code></pre><p>2.Nuxt asyncData方法，初始化页面前先得到数据，但仅限于页面组件调用：</p><pre><code class="javascript">// 并发加载多个接口：  async asyncData (&#123; app, query &#125;) &#123;    let [resA, resB, resC] = await Promise.all([      app.$axios.get(&#39;/api/a&#39;),      app.$axios.get(&#39;/api/b&#39;),      app.$axios.get(&#39;/api/c&#39;),     ])          return &#123;       dataA: resA.data,       dataB: resB.data,       dataC: resC.data,     &#125;  &#125;</code></pre><p>在asyncData中获取参数：</p><pre><code class="javascript">1.获取动态路由参数，如：/list/:id&#39; ==&gt;  &#39;/list/123接收：async asyncData (&#123; app, query &#125;) &#123;  console.log(app.context.params.id) //123&#125;2.获取url?获取参数，如：/list?id=123接收：async asyncData (&#123; app, query &#125;) &#123;  console.log(query.id) //123&#125;</code></pre><p>3.如果你使用<code>v-if</code>语法，部署到线上大概也会遇到这个错误：</p><pre><code class="javascript">Error while initializing app DOMException: Failed to execute &#39;appendChild&#39; on &#39;Node&#39;: This node type does not support this method.    at Object.We [as appendChild]</code></pre><p>根据github nuxt上的issue第1552条提示，要将<code>v-if</code>改为<code>v-show</code>语法。</p><h4 id="2-静态化"><a href="#2-静态化" class="headerlink" title="2.静态化"></a>2.静态化</h4><p>静态化是Nuxt.js打包的另一种方式，算是 Nuxt.js 的一个创新点，页面加载速度很快。 在 Nuxt.js 执行 generate 静态化打包时，动态路由会被忽略。</p><pre><code class="javascript">-| pages/---| index.vue---| users/-----| _id.vue</code></pre><p>需要动态路由先生成静态页面，你需要指定动态路由参数的值，并配置到 routes 数组中去。</p><pre><code class="javascript">// nuxt.config.jsmodule.exports = &#123;  generate: &#123;    routes: [      &#39;/users/1&#39;,      &#39;/users/2&#39;,      &#39;/users/3&#39;    ]  &#125;&#125;</code></pre><p>运行打包，即可看见打包出来的页面。 但是如果路由动态参数的值是动态的而不是固定的，应该怎么做呢？</p><ul><li>使用一个返回 Promise 对象类型 的 函数；</li><li>使用一个回调是 callback(err, params) 的 函数。</li></ul><pre><code class="javascript">// nuxt.config.jsimport axios from &#39;axios&#39;export default &#123;  generate: &#123;    routes: function () &#123;      return axios.get(&#39;https://my-api/users&#39;)      .then((res) =&gt; &#123;        return res.data.map((user) =&gt; &#123;          return &#123;            route: &#39;/users/&#39; + user.id,            payload: user          &#125;        &#125;)      &#125;)    &#125;  &#125;&#125;</code></pre><p>现在我们可以从<code>/users/_id.vue</code>访问的<code>payload</code>，如下所示：</p><pre><code class="javascript">async asyncData (&#123; params, error, payload &#125;) &#123;  if (payload) return &#123; user: payload &#125;  else return &#123; user: await backend.fetchUser(params.id) &#125;&#125;</code></pre><p>如果你的动态路由的参数很多，例如商品详情，可能高达几千几万个。需要一个接口返回所有id，然后打包时遍历id，打包到本地，如果某个商品修改了或者下架了，又要重新打包，数量多的情况下打包也是非常慢的，非常不现实。 优势：</p><ul><li>纯静态文件，访问速度超快；</li><li>对比SSR，不涉及到服务器负载方面问题；</li><li>静态网页不宜遭到黑客攻击，安全性更高。</li></ul><p>不足：</p><ul><li>如果动态路由参数多的话不适用。</li></ul><h4 id="3-预渲染prerender-spa-plugin"><a href="#3-预渲染prerender-spa-plugin" class="headerlink" title="3.预渲染prerender-spa-plugin"></a>3.预渲染prerender-spa-plugin</h4><p>如果你只是用来改善少数营销页面（例如 /, /about, /contact 等）的 SEO，那么你可能需要预渲染。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。</p><pre><code class="javascript">$ cnpm install prerender-spa-plugin --save</code></pre><p>vue cli 3 <code>vue.config.js</code>配置：</p><pre><code class="javascript">const PrerenderSPAPlugin = require(&#39;prerender-spa-plugin&#39;);const Renderer = PrerenderSPAPlugin.PuppeteerRenderer;const path = require(&#39;path&#39;);module.exports = &#123;    configureWebpack: config =&gt; &#123;        if (process.env.NODE_ENV !== &#39;production&#39;) return;        return &#123;            plugins: [                new PrerenderSPAPlugin(&#123;                    // 生成文件的路径，也可以与webpakc打包的一致。                    // 下面这句话非常重要！！！                    // 这个目录只能有一级，如果目录层次大于一级，在生成的时候不会有任何错误提示，在预渲染的时候只会卡着不动。                    staticDir: path.join(__dirname,&#39;dist&#39;),                    // 对应自己的路由文件，比如a有参数，就需要写成 /a/param1。                    routes: [&#39;/&#39;, &#39;/product&#39;,&#39;/about&#39;],                    // 这个很重要，如果没有配置这段，也不会进行预编译                    renderer: new Renderer(&#123;                        inject: &#123;                            foo: &#39;bar&#39;                        &#125;,                        headless: false,                        // 在 main.js 中 document.dispatchEvent(new Event(&#39;render-event&#39;))，两者的事件名称要对应上。                        renderAfterDocumentEvent: &#39;render-event&#39;                    &#125;)                &#125;),            ],        &#125;;    &#125;&#125;</code></pre><p>在main.js中添加：</p><pre><code class="javascript">new Vue(&#123;  router,  render: h =&gt; h(App),  mounted () &#123;    document.dispatchEvent(new Event(&#39;render-event&#39;))  &#125;&#125;).$mount(&#39;#app&#39;)</code></pre><p>注意：router中必须设置 <code>mode: “history”</code>。</p><p>打包出来可以看见文件，打包出文件夹<code>/index.html</code>，例如：<code>about</code> =&gt; <code>about/index.html</code>，里面有html内容。</p><p>优势：</p><ul><li>改动小，引入个插件就完事；</li></ul><p>不足：</p><ul><li>无法使用动态路由；</li><li>只适用少量页面的项目，页面多达几百个的情况下，打包会很很很慢；</li></ul><h4 id="4-使用Phantomjs针对爬虫做处理"><a href="#4-使用Phantomjs针对爬虫做处理" class="headerlink" title="4.使用Phantomjs针对爬虫做处理"></a>4.使用Phantomjs针对爬虫做处理</h4><p>Phantomjs是一个基于webkit内核的无头浏览器，即没有UI界面，即它就是一个浏览器，只是其内的点击、翻页等人为相关操作需要程序设计实现。 虽然“PhantomJS宣布终止开发”，但是已经满足对Vue的SEO处理。 这种解决方案其实是一种旁路机制，原理就是通过Nginx配置，判断访问的来源UA是否是爬虫访问，如果是则将搜索引擎的爬虫请求转发到一个node server，再通过PhantomJS来解析完整的HTML，返回给爬虫。</p><img src="/images/post/phantomjs.png" style="zoom: 50%;" /><p>具体代码戳这里：<a href="https://github.com/lengziyu/vue-seo-phantomjs">vue-seo-phantomjs</a>。 要安装全局<code>phantomjs</code>，局部<code>express</code>，测试：</p><pre><code class="javascript">$ phantomjs spider.js &#39;https://www.baidu.com&#39;</code></pre><p>如果见到在命令行里出现了一推html，那恭喜你，你已经征服PhantomJS啦。 启动之后或者用postman在请求头增加<code>User-Agent</code>值为<code>Baiduspider</code>，效果一样的。</p><p>部署上线 线上要安装<code>node</code>、<code>pm2</code>、<code>phantomjs</code>，nginx相关配置：</p><pre><code class="javascript">upstream spider_server &#123;  server localhost:3000;&#125;server &#123;    listen       80;    server_name  example.com;        location / &#123;      proxy_set_header  Host            $host:$proxy_port;      proxy_set_header  X-Real-IP       $remote_addr;      proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;      if ($http_user_agent ~* &quot;Baiduspider|twitterbot|facebookexternalhit|rogerbot|linkedinbot|embedly|quora link preview|showyoubot|outbrain|pinterest|slackbot|vkShare|W3C_Validator|bingbot|Sosospider|Sogou Pic Spider|Googlebot|360Spider&quot;) &#123;        proxy_pass  http://spider_server;      &#125;    &#125;&#125;</code></pre><p>优势：</p><ul><li>完全不用改动项目代码，按原本的SPA开发即可，对比开发SSR成本小不要太多；</li><li>对已用SPA开发完成的项目，这是不二之选。</li></ul><p>不足：</p><ul><li>部署需要node服务器支持；</li><li>爬虫访问比网页访问要慢一些，因为定时要定时资源加载完成才返回给爬虫；</li><li>如果被恶意模拟百度爬虫大量循环爬取，会造成服务器负载方面问题，解决方法是判断访问的IP，是否是百度官方爬虫的IP。</li></ul><hr><p>引用来源点击<a href="https://cloud.tencent.com/developer/article/1674392">这里</a>,原作者的内容比较详细,里面多补充一些其它必要知识</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序-常用原生功能封装</title>
      <link href="/2021/02/20/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%B8%B8%E7%94%A8%E5%8E%9F%E7%94%9F%E5%8A%9F%E8%83%BD%E5%B0%81%E8%A3%85/"/>
      <url>/2021/02/20/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%B8%B8%E7%94%A8%E5%8E%9F%E7%94%9F%E5%8A%9F%E8%83%BD%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>对微信小程序自身特性的功能进行封装使用</p><span id="more"></span><pre><code class="javascript">/** * 查询授权 * @param &#123;*&#125; scope  */const wxGetSetting = (scope) =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    wx.getSetting(&#123;      success(res) &#123;        if (!res.authSetting[&#39;scope.&#39; + scope]) &#123;          wx.authorize(&#123;            scope: &#39;scope.&#39; + scope,            success(res) &#123;              resolve(res)            &#125;,            fail(err) &#123;              wx.showToast(&#123;                title: &#39;请您到设置页面允许授权&#39;,                icon: &#39;none&#39;              &#125;)              wx.openSetting()              reject(err)            &#125;          &#125;)        &#125; else &#123;          resolve(&#123;&#125;)        &#125;      &#125;,      fail(err) &#123;        reject(err)      &#125;    &#125;)  &#125;)&#125;/** * 微信登录功能 */const wxLogin = () =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    wx.login(&#123;      success: function (res) &#123;        resolve(res)      &#125;    &#125;)  &#125;)&#125;/** * 获取个人信息 */const wxGetUserInfo = () =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    wxGetSetting(&#39;userInfo&#39;).then(res =&gt; &#123;      wx.getUserInfo(&#123;        success: function (res) &#123;          resolve(res)        &#125;      &#125;)    &#125;).catch(err =&gt; &#123;      reject(err)    &#125;)  &#125;)&#125;/** * 保存图片 * @param &#123;*&#125; filePath  */const wxSaveImageToPhotosAlbum = (src,from=&quot;web&quot;) =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    wxGetSetting(&#39;writePhotosAlbum&#39;).then(res =&gt; &#123;      if(from == &quot;local&quot;)&#123;        wx.saveImageToPhotosAlbum(&#123;          filePath:src,          success: function (res) &#123;            resolve(res)          &#125;,fail(e)&#123;            reject(e)          &#125;        &#125;)      &#125;else if(from == &quot;web&quot;)&#123;        let fileName = new Date().valueOf();        wx.downloadFile(&#123;          url:src,          filePath:wx.env.USER_DATA_PATH + &#39;/&#39; + fileName + &#39;.jpg&#39;,          success(image)&#123;            wx.saveImageToPhotosAlbum(&#123;              filePath:image.filePath,              success: function (res) &#123;                resolve(res)              &#125;,fail(e)&#123;                reject(e)              &#125;            &#125;)          &#125;,fail(err)&#123;            reject(err)          &#125;        &#125;)      &#125;else&#123;        reject(&quot;wxSaveImageToPhotosAlbum:from is unknown&quot;)      &#125;    &#125;).catch(err =&gt; &#123;      reject(err)    &#125;)  &#125;)&#125;/** * 复制文字到剪切板 * @param &#123;*&#125; data  */const wxClipboardData = data =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    wx.setClipboardData(&#123;      data: data,      success(res) &#123;        wx.getClipboardData(&#123;          success(res) &#123;            resolve(res)          &#125;,          fail(err) &#123;            reject(err)          &#125;        &#125;)      &#125;,      fail(err) &#123;        reject(err)      &#125;    &#125;)  &#125;)&#125;/** * 打开文档 * @param &#123;*&#125; path  */const wxOpenDocument = path =&gt;&#123;  return new Promise((resolve, reject) =&gt; &#123;    wx.downloadFile(&#123;      url: path,      success: function (res) &#123;        const filePath = res.tempFilePath        wx.openDocument(&#123;          filePath: filePath,          success: function (res) &#123;            resolve(res)          &#125;,fail(err)&#123;            reject(err)          &#125;        &#125;)      &#125;,fail(err)&#123;        reject(err)      &#125;    &#125;)  &#125;)&#125;const wxMakePhoneCall = phone =&gt;&#123;  return new Promise((resolve, reject) =&gt; &#123;  let type = Object.prototype.toString.call(phone);  let phoneArray = []  if(type == &quot;[object String]&quot;)&#123;      phoneArray = [phone]  &#125;else if(type == &quot;[object Number]&quot;)&#123;    phoneArray = [phone.toString]  &#125;else if(type == &quot;[object Array]&quot;)&#123;    phoneArray = phone;  &#125;else&#123;    reject(&quot;wxMakePhoneCall:parameter type is error&quot;);    return;  &#125;  wx.showActionSheet(&#123;    itemList: phoneArray,    success: function (res) &#123;      wx.makePhoneCall(&#123;        phoneNumber: phone, //此号码并非真实电话号码，仅用于测试          success: function () &#123;          resolve()        &#125;,        fail: function (e) &#123;          reject(e)        &#125;      &#125;)      if (!res.cancel) &#123;        reject(res.tapIndex)      &#125;    &#125;  &#125;);&#125;)&#125;/** * 微信拉起支付 * @param &#123;*&#125; data  */const wxPayment = data =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    let &#123;      timeStamp,      nonceStr,      paySign    &#125; = data;    wx.requestPayment(&#123;      timeStamp,      nonceStr,      package:data.package,      signType: &#39;MD5&#39;,      paySign,      success(res) &#123;        resolve(res)      &#125;,      fail(res) &#123;        reject(res)      &#125;    &#125;)  &#125;)&#125;export &#123;  wxGetUserInfo,  wxLogin,  wxSaveImageToPhotosAlbum,  wxClipboardData,  wxOpenDocument,  wxMakePhoneCall,  wxPayment&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序-使用mixin混入</title>
      <link href="/2021/02/20/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%BD%BF%E7%94%A8mixin%E6%B7%B7%E5%85%A5/"/>
      <url>/2021/02/20/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%BD%BF%E7%94%A8mixin%E6%B7%B7%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文用于实现微信小程序的mixin使用</p><span id="more"></span><h2 id="mixin理解"><a href="#mixin理解" class="headerlink" title="mixin理解"></a>mixin理解</h2><p>本意就是混入的意思,利用语言特性进行组合式操作.</p><p>如果你对<a href="https://cn.vuejs.org/v2/guide/mixins.html">vue中的mixin</a>有所了解,那么对mixin一定不会陌生,如果您使用过java语言,那么它解决<a href="https://www.liaoxuefeng.com/wiki/897692888725344/923030524000032">多重继承</a> 带来复杂继承链的问题，或者说是<code>多重继承</code>实现的一种技巧.</p><h2 id="微信小程序中的mixin理解"><a href="#微信小程序中的mixin理解" class="headerlink" title="微信小程序中的mixin理解"></a>微信小程序中的mixin理解</h2><p>了解过vue中的混入思路,我们可以将之转化到微信小程序中,可以劫持Page或者Component,改写函数并最终释放出来</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="javascript">// 保存原生的 Page 函数const originPage = Pageconst originComponent = ComponentPage = (options) =&gt; &#123;  const mixins = options.mixins  // mixins 必须为数组  if (Array.isArray(mixins)) &#123;    delete options.mixins    // mixins 注入并执行相应逻辑    options =  merge(mixins, options)  &#125;  // 释放原生 Page 函数  originPage(options)&#125;Component = (options) =&gt; &#123;  const mixins = options.mixins  // mixins 必须为数组  if (Array.isArray(mixins)) &#123;    delete options.mixins    // mixins 注入并执行相应逻辑    options = merge(mixins, options)  &#125;  // 释放原生 Component 函数  originComponent(options)&#125;// 定义小程序内置的属性/方法const originProperties = [&#39;data&#39;, &#39;properties&#39;, &#39;options&#39;, &#39;methods&#39;,&#39;observers&#39;]const originMethods = [&#39;onLoad&#39;, &#39;onReady&#39;, &#39;onShow&#39;, &#39;onHide&#39;, &#39;onUnload&#39;, &#39;onPullDownRefresh&#39;, &#39;onReachBottom&#39;, &#39;onShareAppMessage&#39;, &#39;onPageScroll&#39;, &#39;onTabItemTap&#39;]function merge(mixins, options) &#123;  mixins.forEach((mixin) =&gt; &#123;    if (Object.prototype.toString.call(mixin) !== &#39;[object Object]&#39;) &#123;      throw new Error(&#39;mixin 类型必须为对象！&#39;)    &#125;    // 遍历 mixin 里面的所有属性    for (let [key, value] of Object.entries(mixin)) &#123;      if (originProperties.includes(key)) &#123;        // 内置对象属性混入        options[key] = &#123;          ...value,          ...options[key]        &#125;      &#125; else if (originMethods.includes(key)) &#123;        // 内置方法属性混入，优先执行混入的部分        const originFunc = options[key]        options[key] = function (...args) &#123;          value.call(this, ...args)          return originFunc &amp;&amp; originFunc.call(this, ...args)        &#125;      &#125; else &#123;        // 自定义方法混入        options = &#123;          ...mixin,          ...options        &#125;      &#125;    &#125;  &#125;)  return options&#125;</code></pre><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>可将其命名为mixin.js存入项目的utils或者core中作为工具;</p><p>在<code>app.js</code>顶部引入</p><pre><code class="javascript">//app.jsimport &#39;./utils/mixins.js&#39;</code></pre><p>可在项目根目录创建<code>common/mixins</code>文件夹,用于存放各种mixin文件</p><h4 id="Page的mixin定义风格如下"><a href="#Page的mixin定义风格如下" class="headerlink" title="Page的mixin定义风格如下:"></a>Page的mixin定义风格如下:</h4><pre><code class="javascript">//listMixin.jsmodule.exports = &#123;  data: &#123;    list: [],    page: 1, //页数    limit: 10, //每页最大数    lastPage: false, //是否为最后一页    isUpload: false, //是否在加载,  &#125;,   /**   * 监听滚动到底部   */  scrolltolower(e) &#123;    console.log(&quot;滚动到底部&quot;, e);    if (!this.data.lastPage &amp;&amp; !this.data.isUpload) &#123;      this.getList() //由被混入的文件实现getList()函数    &#125;;  &#125;&#125;</code></pre><p>使用方法如下:</p><pre><code class="javascript">Page(&#123;  mixins: [require(&#39;/common/mixins/ListMixin.js&#39;)]&#125;)</code></pre><h4 id="Component的mixin定义风格如下"><a href="#Component的mixin定义风格如下" class="headerlink" title="Component的mixin定义风格如下:"></a>Component的mixin定义风格如下:</h4><pre><code class="javascript">//componentListMixin.jsmodule.exports = &#123;  data: &#123;&#125;,  /**   * 组件的属性列表   */  properties: &#123;    //数据集合    list:&#123;      type:Array,      value:[]    &#125;,  &#125;,  methods:&#123;     /**     * 选择某项     */    chooseItem(event)&#123;      let item = event.currentTarget.dataset.cap;      this.triggerEvent(&#39;onChoose&#39;, item, &#123;&#125;)    &#125;  &#125; &#125;</code></pre><p>使用方法如下:</p><pre><code class="javascript">Component(&#123;  mixins: [require(&#39;/common/mixins/componentListMixin.js&#39;)]&#125;)</code></pre><p>功能实现参考了<a href="https://segmentfault.com/a/1190000019527762">此篇</a>文章,并对存在的问题进行修正</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序-Object.entries is not a function解决办法</title>
      <link href="/2021/02/20/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-Object.entries%20is%20not%20a%20function%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2021/02/20/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-Object.entries%20is%20not%20a%20function%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在部分机型上打开开发的小程序,vcosole显示<strong>Object.entries is not a function</strong>这类错误,可以使用以下方法手动添加<strong>Object.entries polyfill</strong>解决</p><span id="more"></span><pre><code>if (!Object.entries)  Object.entries = function( obj )&#123;    var ownProps = Object.keys( obj ),        i = ownProps.length,        resArray = new Array(i); // preallocate the Array    while (i--)      resArray[i] = [ownProps[i], obj[ownProps[i]]];        return resArray;  &#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
